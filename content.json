{"meta":{"title":"Swtpumpkin Blog","subtitle":"Node.js Developer","description":"Node.js Developer","author":"Jeongwon Kim","url":"https://swtpumpkin.github.io","root":"/"},"pages":[],"posts":[{"title":"github all repository names","slug":"git/githubRepoNames","date":"2024-03-27T23:00:00.000Z","updated":"2024-03-28T06:44:39.282Z","comments":true,"path":"git/githubRepoNames/","link":"","permalink":"https://swtpumpkin.github.io/git/githubRepoNames/","excerpt":"","text":"github all repository names권한이 있는 계정의 모든 레포지토리 이름을 가져오는 방법을 안내드리겠습니다. private repo까지 가져오기 위해서는 토큰이 필요합니다. 여기로 이동하여 토큰을 생성합니다. 계정에 따라 2차인증을 요구 할 수 있습니다. Note에는 githubRepoNames와 같이 작성하고, Expiration은 사용 할 시간만 짧게 설정합니다. Select scopes에서는 repo에 체크합니다. 그리고 Generate token을 클릭합니다. 토큰 생성이 완료되면 복사 아이콘을 클릭하여 토큰을 복사합니다. 아래 코드를 참고하여 username과 token을 입력합니다. 아래의 코드를 실행하면 모든 레포지토리 이름을 가져올 수 있습니다. getAllRepositories 함수는 문자열 배열을 반환합니다. 12345678910111213141516171819202122232425262728293031import axios from &quot;axios&quot;;async function getAllRepositories(): Promise&lt;string[]&gt; &#123; const repositories = []; // Replace with your username const username = &quot;&quot;; // Generate a token from https://github.com/settings/tokens and then replace the token const token = &quot;&quot;; let pageNum = 1; while (true) &#123; try &#123; const response = await axios.get( `https://api.github.com/search/repositories?q=user:$&#123;username&#125;&amp;per_page=100&amp;page=$&#123;pageNum&#125;`, &#123; headers: &#123; Authorization: `Bearer $&#123;token&#125;`, &#125;, &#125; ); const items = response.data.items; if (items.length === 0) break; items.forEach((item) =&gt; &#123; repositories.push(item.name); &#125;); pageNum += 1; &#125; catch (error) &#123; console.error(`Failed to fetch repositories. Error: $&#123;error.message&#125;`); &#125; &#125; return repositories;&#125;","categories":[{"name":"git","slug":"git","permalink":"https://swtpumpkin.github.io/categories/git/"}],"tags":[{"name":"git","slug":"git","permalink":"https://swtpumpkin.github.io/tags/git/"},{"name":"github","slug":"github","permalink":"https://swtpumpkin.github.io/tags/github/"},{"name":"repository","slug":"repository","permalink":"https://swtpumpkin.github.io/tags/repository/"},{"name":"name","slug":"name","permalink":"https://swtpumpkin.github.io/tags/name/"},{"name":"레포지토리","slug":"레포지토리","permalink":"https://swtpumpkin.github.io/tags/%EB%A0%88%ED%8F%AC%EC%A7%80%ED%86%A0%EB%A6%AC/"},{"name":"이름","slug":"이름","permalink":"https://swtpumpkin.github.io/tags/%EC%9D%B4%EB%A6%84/"},{"name":"repo","slug":"repo","permalink":"https://swtpumpkin.github.io/tags/repo/"},{"name":"레포","slug":"레포","permalink":"https://swtpumpkin.github.io/tags/%EB%A0%88%ED%8F%AC/"}]},{"title":"Macbook Arm(M1, M2)에서 NVM 특정 버전 설치 시 발생하는 오류 해결","slug":"backend/node/nvmArmError","date":"2023-08-08T23:00:00.000Z","updated":"2023-08-09T06:07:22.725Z","comments":true,"path":"backend/node/nvmArmError/","link":"","permalink":"https://swtpumpkin.github.io/backend/node/nvmArmError/","excerpt":"","text":"최신 Mac은 ARM(M1, M2)칩을 사용하는데 몇몇 특정 Node.js 버전을 설치하려고 할 때 문제가 발생할 수 있습니다. 이 문제는 터미널에서 Rosetta모드로 실행하여 해결 할 수 있습니다. 문제현상1$ nvm install v12 NVM을 사용하여 특정 Node.js 버전을 설치하려고 시도하면 다음과 같은 오류가 발생합니다. 123456789101112Downloading https:&#x2F;&#x2F;nodejs.org&#x2F;dist&#x2F;v12.22.12&#x2F;node-v12.22.12-darwin-arm64.tar.gz...##O&#x3D;-# #Checksums emptytar: Error opening archive: Unrecognized archive formatBinary download failed, trying source.##O&#x3D;-# #Checksums emptytar: Error opening archive: Unrecognized archive formatBinary download failed, trying source.Detected that you have 12 CPU thread(s)Set the number of jobs to 12 - 1 &#x3D; 11 jobs to speed up the buildInstalling node v1.0 and greater from source is not currently supported 해결방법: Rosetta 모드로 터미널 실행Rosetta 모드는 Intel기반 애플리캐이션을 ARM에서 실행하기 위한 에뮬레이션 모드입니다. 이 모드로 터미널을 실행하면 위의 문제를 해결할 수 있습니다. 터미널이 Rosetta 모드로 실행되게 설정합니다. 이렇게 설정해도 기존에 사용하던 명령들은 그대로 사용할 수 있습니다. NVM을 사용하여 특정 Node.js버전을 설치하려면 다음과 같이 실행합니다. 1nvm install v12 이제 Node.js 설치가 정상적으로 진행됩니다. 정리macOS ARM(M1, M2)에서 NVM을 사용하여 특정 Node.js 버전을 설치하려 할 때 발생하는 오류는 Rosetta 모드에서 터미널을 실행하여 해결할 수 있습니다. 이 방법을 사용하면 원활한 Node.js 버전 관리가 가능해집니다. 위의 해결방법을 따라하면서도 문제가 지속되는 경우, NVM 및 Node.js 커뮤니티에서 해당 문제에 대한 추가적인 업데이트나 해결책이 제공되었는지 확인하는 것이 좋습니다.","categories":[{"name":"backend","slug":"backend","permalink":"https://swtpumpkin.github.io/categories/backend/"},{"name":"node","slug":"backend/node","permalink":"https://swtpumpkin.github.io/categories/backend/node/"}],"tags":[{"name":"nvm","slug":"nvm","permalink":"https://swtpumpkin.github.io/tags/nvm/"},{"name":"rosetta","slug":"rosetta","permalink":"https://swtpumpkin.github.io/tags/rosetta/"},{"name":"arm","slug":"arm","permalink":"https://swtpumpkin.github.io/tags/arm/"},{"name":"m1","slug":"m1","permalink":"https://swtpumpkin.github.io/tags/m1/"},{"name":"m2","slug":"m2","permalink":"https://swtpumpkin.github.io/tags/m2/"}]},{"title":"docker node alpine image build python error (feat: bcrypt)","slug":"backend/docker/dockerNodeBuildPythonError","date":"2023-01-26T02:00:00.000Z","updated":"2023-01-26T05:39:41.973Z","comments":true,"path":"backend/docker/dockerNodeBuildPythonError/","link":"","permalink":"https://swtpumpkin.github.io/backend/docker/dockerNodeBuildPythonError/","excerpt":"","text":"docker로 이미지 빌드하는데 python bcrypt 에러가 발생할 때bcrypt라이브러리는 python이 필요합니다.alpine 이미지는 python이 없기 때문에 bcrypt를 설치할 때 에러가 발생합니다. 12345FROM node:16-alpine- 생략 -RUN npm ci --only-production- 생략 -CMD npm start Dockerfile이 이렇게 작성되어 있을 때 python을 설치해주는 명령어를 추가해야합니다. 1RUN apk --no-cache add --virtual builds-deps build-base python 위 명령어는 python을 설치하는 명령어입니다. 123456FROM node:16-alpine- 생략 -RUN apk --no-cache add --virtual builds-deps build-base pythonRUN npm ci --only-production- 생략 -CMD npm start npm ci 명령어 이전에 python을 설치해주는 명령어를 추가하면 됩니다. 다른 해결 방법bcrypt 라이브러리 대신 bcryptjs를 사용하면 됩니다.","categories":[{"name":"backend","slug":"backend","permalink":"https://swtpumpkin.github.io/categories/backend/"},{"name":"docker","slug":"backend/docker","permalink":"https://swtpumpkin.github.io/categories/backend/docker/"}],"tags":[{"name":"docker","slug":"docker","permalink":"https://swtpumpkin.github.io/tags/docker/"},{"name":"error","slug":"error","permalink":"https://swtpumpkin.github.io/tags/error/"},{"name":"bcrypt","slug":"bcrypt","permalink":"https://swtpumpkin.github.io/tags/bcrypt/"},{"name":"도커","slug":"도커","permalink":"https://swtpumpkin.github.io/tags/%EB%8F%84%EC%BB%A4/"},{"name":"buildx","slug":"buildx","permalink":"https://swtpumpkin.github.io/tags/buildx/"},{"name":"python","slug":"python","permalink":"https://swtpumpkin.github.io/tags/python/"},{"name":"alpine","slug":"alpine","permalink":"https://swtpumpkin.github.io/tags/alpine/"}]},{"title":"AWS SSH IDENTIFICATION 에러 (WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED!)","slug":"backend/aws/awsSshIdentificationError","date":"2023-01-26T01:00:00.000Z","updated":"2023-01-26T04:02:45.563Z","comments":true,"path":"backend/aws/awsSshIdentificationError/","link":"","permalink":"https://swtpumpkin.github.io/backend/aws/awsSshIdentificationError/","excerpt":"","text":"서버를 설정하다보면 에러로 서버를 다시 켜는 경우가 있는데 이때 인증서를 사용 할 수 없다는 에러가 발생합니다. 12345678910111213@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED! @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@IT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY!Someone could be eavesdropping on you right now (man-in-the-middle attack)!It is also possible that a host key has just been changed.The fingerprint for the ED25519 key sent by the remote host is- 생략 -Please contact your system administrator.Add correct host key in &#x2F;Users&#x2F;username&#x2F;.ssh&#x2F;known_hosts to get rid of this message.Offending ECDSA key in &#x2F;Users&#x2F;username&#x2F;.ssh&#x2F;known_hosts:30Host key for 주소 has changed and you have requested strict checking.Host key verification failed. 위와 같은 에러가 발생하면서 서버에 접속이 되지 않습니다. 이때는 다음과 같이 해결 할 수 있습니다. 1rm -rf ~&#x2F;.ssh&#x2F;known_hosts known_hosts 파일을 삭제해서 정보를 모두 삭제하는 방법. 1Offending ECDSA key in &#x2F;Users&#x2F;username&#x2F;.ssh&#x2F;known_hosts:30 또는 위 에러와 같이 30번 줄에서 에러가 발생하기 때문에 30번 줄을 삭제하면 됩니다. 1vi ~&#x2F;.ssh&#x2F;known_hosts vi에디터로 known_hosts 파일을 열어서 30번 줄을 삭제하고 저장하면 됩니다.","categories":[{"name":"backend","slug":"backend","permalink":"https://swtpumpkin.github.io/categories/backend/"},{"name":"AWS","slug":"backend/AWS","permalink":"https://swtpumpkin.github.io/categories/backend/AWS/"}],"tags":[{"name":"aws","slug":"aws","permalink":"https://swtpumpkin.github.io/tags/aws/"},{"name":"ssh","slug":"ssh","permalink":"https://swtpumpkin.github.io/tags/ssh/"},{"name":"identification","slug":"identification","permalink":"https://swtpumpkin.github.io/tags/identification/"},{"name":"rsa","slug":"rsa","permalink":"https://swtpumpkin.github.io/tags/rsa/"}]},{"title":"AWS Ubuntu AWS CLI 설치","slug":"backend/aws/awsUbuntuAwsCli","date":"2023-01-26T00:00:00.000Z","updated":"2023-01-26T01:55:42.868Z","comments":true,"path":"backend/aws/awsUbuntuAwsCli/","link":"","permalink":"https://swtpumpkin.github.io/backend/aws/awsUbuntuAwsCli/","excerpt":"","text":"Ubuntu AWS CLI 설치 방법1sudo apt-get update apt-get을 이용하여 update를 진행합니다. 1sudo apt-get install awscli apt-get을 이용하여 awscli를 설치합니다. 1aws --version aws를 이용하여 version을 확인합니다. 12$ aws --versionaws-cli&#x2F;1.22.34 Python&#x2F;3.10.6 Linux&#x2F;5.15.0-1028-aws botocore&#x2F;1.23.34 위와같이 버전이 나오면 설치가 완료된 것입니다.","categories":[{"name":"backend","slug":"backend","permalink":"https://swtpumpkin.github.io/categories/backend/"},{"name":"AWS","slug":"backend/AWS","permalink":"https://swtpumpkin.github.io/categories/backend/AWS/"}],"tags":[{"name":"aws","slug":"aws","permalink":"https://swtpumpkin.github.io/tags/aws/"},{"name":"ubuntu","slug":"ubuntu","permalink":"https://swtpumpkin.github.io/tags/ubuntu/"},{"name":"ec2","slug":"ec2","permalink":"https://swtpumpkin.github.io/tags/ec2/"},{"name":"awscli","slug":"awscli","permalink":"https://swtpumpkin.github.io/tags/awscli/"},{"name":"t4g","slug":"t4g","permalink":"https://swtpumpkin.github.io/tags/t4g/"},{"name":"arm","slug":"arm","permalink":"https://swtpumpkin.github.io/tags/arm/"}]},{"title":"React.js에서 Esc 키로 Tab 닫기","slug":"frontend/react/escCloseTab","date":"2022-10-26T23:00:00.000Z","updated":"2022-10-27T07:53:06.209Z","comments":true,"path":"frontend/react/escCloseTab/","link":"","permalink":"https://swtpumpkin.github.io/frontend/react/escCloseTab/","excerpt":"","text":"Esc 키로 Tab 닫기 이벤트 핸들러로 key down을 체크합니다. 키가 눌렸을 때 esc키가 맞는지 체크합니다. 123456const keyDownHandler = (event) =&gt; &#123; if (event.keyCode === 27) &#123; event.preventDefault(); window.close(); &#125;&#125;; 사용자가 key를 누를때마다 keyDownHandler가 실행됩니다.esc의 keyCode는 27로 esc키가 눌렸는지 체크합니다.window.close() 함수로 해당 tab을 종료합니다.window.close() 함수는 window.open(url, &#39;_blank&#39;)로 열린 새 탭에서만 동작합니다. 12345678910111213141516171819202122import &#123; useEffect &#125; from &#x27;react&#x27;;function App() &#123; useEffect(() =&gt; &#123; const keyDownHandler = (event) =&gt; &#123; if (event.keyCode === 27) &#123; event.preventDefault(); window.close(); &#125; &#125;; document.addEventListener(&#x27;keydown&#x27;, keyDownHandler); return () =&gt; document.removeEventListener(&#x27;keydown&#x27;, keyDownHandler); &#125;, []); return ( &lt;div&gt; &lt;h1&gt;hi&lt;/h1&gt; &lt;/div&gt; );&#125;export default App; React에서는 위와같이 사용하면 됩니다. 1234567891011121314import &#123; useEffect &#125; from &#x27;react&#x27;;export function escCloseTab() &#123; useEffect(() =&gt; &#123; const keyDownHandler = (event) =&gt; &#123; if (event.keyCode === 27) &#123; event.preventDefault(); window.close(); &#125; &#125;; document.addEventListener(&#x27;keydown&#x27;, keyDownHandler); return () =&gt; document.removeEventListener(&#x27;keydown&#x27;, keyDownHandler); &#125;, []);&#125; 여러 페이지에서 탭 닫기 함수를 사용하려면 escCloseTab() 함수를 생성하여 사용하시면 됩니다.","categories":[{"name":"frontend","slug":"frontend","permalink":"https://swtpumpkin.github.io/categories/frontend/"},{"name":"react","slug":"frontend/react","permalink":"https://swtpumpkin.github.io/categories/frontend/react/"}],"tags":[{"name":"react","slug":"react","permalink":"https://swtpumpkin.github.io/tags/react/"},{"name":"esc","slug":"esc","permalink":"https://swtpumpkin.github.io/tags/esc/"},{"name":"tab","slug":"tab","permalink":"https://swtpumpkin.github.io/tags/tab/"},{"name":"close","slug":"close","permalink":"https://swtpumpkin.github.io/tags/close/"},{"name":"탭","slug":"탭","permalink":"https://swtpumpkin.github.io/tags/%ED%83%AD/"},{"name":"버튼","slug":"버튼","permalink":"https://swtpumpkin.github.io/tags/%EB%B2%84%ED%8A%BC/"},{"name":"닫기","slug":"닫기","permalink":"https://swtpumpkin.github.io/tags/%EB%8B%AB%EA%B8%B0/"}]},{"title":"Apply Absolute For Create React App","slug":"frontend/react/ApplyAbsolutePathCRA","date":"2022-05-12T23:00:00.000Z","updated":"2022-05-13T12:51:28.936Z","comments":true,"path":"frontend/react/ApplyAbsolutePathCRA/","link":"","permalink":"https://swtpumpkin.github.io/frontend/react/ApplyAbsolutePathCRA/","excerpt":"","text":"Create React App의 절대경로 설정경로를 src폴더 기준으로 상대경로(../../../component/user)에서 절대경로(component/user)로 변경하는 방법에 대해 알아보려고합니다. 절대경로 설정CRA프로젝트 루트에 jsconfig.json파일을 생성 후 다음과 같이 작성합니다. 123456&#123; &quot;compilerOptions&quot;: &#123; &quot;baseUrl&quot;: &quot;src&quot; &#125;, &quot;include&quot;: [&quot;src&quot;]&#125; eslintrc.js 파일에 다음과 같은 코드를 추가합니다. 1234567settings: &#123; &quot;import&#x2F;resolver&quot;: &#123; node: &#123; paths: [&quot;src&quot;], &#125;, &#125;, &#125;, 위와같이 설정을 완료 후 프로젝트를 재시작하면 절대경로로 설정하여도 Unable to resolve path to module &#39;component/user&#39; 에러가 발생하지 않습니다.","categories":[{"name":"frontend","slug":"frontend","permalink":"https://swtpumpkin.github.io/categories/frontend/"},{"name":"react","slug":"frontend/react","permalink":"https://swtpumpkin.github.io/categories/frontend/react/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://swtpumpkin.github.io/tags/javascript/"},{"name":"create-react-app","slug":"create-react-app","permalink":"https://swtpumpkin.github.io/tags/create-react-app/"},{"name":"react","slug":"react","permalink":"https://swtpumpkin.github.io/tags/react/"},{"name":"absolute-path","slug":"absolute-path","permalink":"https://swtpumpkin.github.io/tags/absolute-path/"},{"name":"cra","slug":"cra","permalink":"https://swtpumpkin.github.io/tags/cra/"},{"name":"절대경로","slug":"절대경로","permalink":"https://swtpumpkin.github.io/tags/%EC%A0%88%EB%8C%80%EA%B2%BD%EB%A1%9C/"},{"name":"relative-path","slug":"relative-path","permalink":"https://swtpumpkin.github.io/tags/relative-path/"},{"name":"상대경로","slug":"상대경로","permalink":"https://swtpumpkin.github.io/tags/%EC%83%81%EB%8C%80%EA%B2%BD%EB%A1%9C/"}]},{"title":"mac 미리보기 오류 해결","slug":"develop/mac-preview","date":"2022-01-27T23:01:00.000Z","updated":"2022-01-28T03:38:27.843Z","comments":true,"path":"develop/mac-preview/","link":"","permalink":"https://swtpumpkin.github.io/develop/mac-preview/","excerpt":"","text":"미리보기 오류맥에서는 space로 사진이나 동영상을 미리보기 할 수 있습니다. 가끔 아래 사진과 같이 사진 또는 동영상 파일의 정보만 보이고 미리보기가 되지 않는 경우도 있습니다. 해결 방법사과마크에서 강제종료를 선택합니다.Finder 선택 후 재실행을 실행합니다.위와 같이 Finder를 재실행 해주면 space로 미리보기 할 수 있습니다.","categories":[{"name":"develop","slug":"develop","permalink":"https://swtpumpkin.github.io/categories/develop/"}],"tags":[{"name":"develop","slug":"develop","permalink":"https://swtpumpkin.github.io/tags/develop/"},{"name":"mac","slug":"mac","permalink":"https://swtpumpkin.github.io/tags/mac/"},{"name":"preview","slug":"preview","permalink":"https://swtpumpkin.github.io/tags/preview/"},{"name":"미리보기","slug":"미리보기","permalink":"https://swtpumpkin.github.io/tags/%EB%AF%B8%EB%A6%AC%EB%B3%B4%EA%B8%B0/"},{"name":"오류","slug":"오류","permalink":"https://swtpumpkin.github.io/tags/%EC%98%A4%EB%A5%98/"}]},{"title":"mac rosetta 설치","slug":"develop/mac-rosetta","date":"2022-01-27T23:00:00.000Z","updated":"2022-01-28T02:39:38.246Z","comments":true,"path":"develop/mac-rosetta/","link":"","permalink":"https://swtpumpkin.github.io/develop/mac-rosetta/","excerpt":"","text":"rosetta?Rosetta를 사용하면 Apple Silicon(m1)에서 Intel 프로그램을 사용 할 수 있습니다. 설치 방법1softwareupdate --install-rosetta 터미널에 위 코드를 입력하여 rosetta를 설치합니다. 12I have read and agree to the terms of the software license agreement. A list of Apple SLAs may be found here: http:&#x2F;&#x2F;www.apple.com&#x2F;legal&#x2F;sla&#x2F;Type A and press return to agree: 위와 같이 동의 여부를 물어보는데 A를 입력하고 enter키를 누르면 설치됩니다.","categories":[{"name":"develop","slug":"develop","permalink":"https://swtpumpkin.github.io/categories/develop/"}],"tags":[{"name":"develop","slug":"develop","permalink":"https://swtpumpkin.github.io/tags/develop/"},{"name":"mac","slug":"mac","permalink":"https://swtpumpkin.github.io/tags/mac/"},{"name":"rosetta","slug":"rosetta","permalink":"https://swtpumpkin.github.io/tags/rosetta/"},{"name":"로제타","slug":"로제타","permalink":"https://swtpumpkin.github.io/tags/%EB%A1%9C%EC%A0%9C%ED%83%80/"}]},{"title":"docker tesla inventory telegram bot","slug":"backend/docker/dockerTeslaInventoryBot","date":"2021-11-20T23:00:00.000Z","updated":"2021-12-03T03:01:43.853Z","comments":true,"path":"backend/docker/dockerTeslaInventoryBot/","link":"","permalink":"https://swtpumpkin.github.io/backend/docker/dockerTeslaInventoryBot/","excerpt":"","text":"tesla inventory bot 사용법Docker 설치tesla inventory bot을 사용하려면 docker가 설치되어있어야 합니다. 1sudo curl -fsSL get.docker.com -o get-docker.sh sudo sudo sh get-docker.sh 위 명령어를 통해 docker를 설치합니다. 1sudo docker --version 위 명령어로 docker 버전확인하여 설치가 잘 되었는지 확인합니다. tesla shop에서 item id 확인DC 콤보 링크로 이동합니다.페이지에서 우클릭하여 검사도구를 켭니다.network탭에서 Fetch/XHR을 선택하고 dc콤보 페이지를 리프레쉬 합니다.Payload탭에서 item id를 확인합니다. telegram bot 생성 및 Chat Id 찾기telegram bot 생성telegram에서 BotFather를 검색 후 채팅방에 들어갑니다.채팅창에 /newbot을 입력하고 사용할 봇의 이름을 입력합니다. 봇 생성이 완료되면 token을 발급해줍니다. 여기의 token을 복사 후 봇 채팅방으로 이동합니다. 채팅방으로 이동하지 않고 chat id확인 시 확인이 불가능합니다. 꼭 채팅방에 입장 후 id 확인 바랍니다. Chat Id 확인여기 사이트로 이동하여 Chat Id 확인합니다.위에서 발급받은 봇의 토큰을 HTTP API Token에 붙여넣기 후 Chat Id를 확인합니다. result-message-chat-id의 id입니다.☆ 만약 result값이 위 사진처럼 빈 배열로 나온다면 봇 채팅방에 들어가서 채팅창에 /start를 입력하시면 됩니다. tesla bot 실행.env 설정1git clone https://github.com/swtpumpkin/tesla-inventory-bot.git &amp;&amp; cd tesla-inventory-bot git을 이용하여 코드를 다운받고 tesla-inventory-bot폴더로 이동합니다. 123TELEGRAM_TOKEN&#x3D;TELEGRAM_CHAT_ID&#x3D;TESLA_PRODUCT_ID&#x3D; .env파일을 생성해야합니다. TELEGRAM_TOKEN에는 telegram에서 생성한 봇의 토큰을 입력합니다. TELEGRAM_CHAT_ID에는 Chat Id 확인을 통해 확인 한 Id를 입력합니다. TESLA_PRODUCT_ID에는 테슬라 Shop 사이트에서 확인한 Id를 입력합니다. 1echo &quot;TELEGRAM_TOKEN=1111111111:xxxxxx-xxxxxxxxxxxxxxxxxxxxxxxxxxxx&quot; &gt;&gt; .env &amp;&amp; echo &quot;TELEGRAM_CHAT_ID=222222222&quot; &gt;&gt; .env &amp;&amp; echo &quot;TESLA_PRODUCT_ID=1656565-10-A&quot; &gt;&gt; .env .env생성이 어려우시면 위 코드 처럼 token, chat id, product id의 쌍따음표 안의 값만 수정 후 실행하시면 됩니다. docker build1sudo docker build -t tesla-inventory-bot . 위 코드를 실행하여 tesla-inventory-bot docker image를 생성합니다. docker run1sudo docker run -d --env-file .env --name teslaCombo --restart=always tesla-inventory-bot 위 코드를 실행하여 tesla-inventory-bot docker 파일을 실행합니다. 구매 완료 시 봇 종료 방법1sudo docker stop teslaCombo &amp;&amp; sudo docker rm teslaCombo docker 종료 후 컨테이너 삭제로 봇을 종료 할 수 있습니다.","categories":[{"name":"backend","slug":"backend","permalink":"https://swtpumpkin.github.io/categories/backend/"},{"name":"docker","slug":"backend/docker","permalink":"https://swtpumpkin.github.io/categories/backend/docker/"}],"tags":[{"name":"ubuntu","slug":"ubuntu","permalink":"https://swtpumpkin.github.io/tags/ubuntu/"},{"name":"docker","slug":"docker","permalink":"https://swtpumpkin.github.io/tags/docker/"},{"name":"도커","slug":"도커","permalink":"https://swtpumpkin.github.io/tags/%EB%8F%84%EC%BB%A4/"},{"name":"telegram","slug":"telegram","permalink":"https://swtpumpkin.github.io/tags/telegram/"},{"name":"bot","slug":"bot","permalink":"https://swtpumpkin.github.io/tags/bot/"},{"name":"tesla","slug":"tesla","permalink":"https://swtpumpkin.github.io/tags/tesla/"},{"name":"inventory","slug":"inventory","permalink":"https://swtpumpkin.github.io/tags/inventory/"},{"name":"shop","slug":"shop","permalink":"https://swtpumpkin.github.io/tags/shop/"}]},{"title":"docker-compose ubuntu 설치","slug":"backend/docker-compose/dockerComposeInstall","date":"2021-04-26T23:02:00.000Z","updated":"2021-04-27T01:19:58.050Z","comments":true,"path":"backend/docker-compose/dockerComposeInstall/","link":"","permalink":"https://swtpumpkin.github.io/backend/docker-compose/dockerComposeInstall/","excerpt":"","text":"docker-compose ubuntu 설치21년4월27일 현재 docker-compose 최신 버전은 1.29.1입니다. 최신 릴리즈 버전을 확인하고 싶으신분은 여기를 클릭해서 확인해주시기 바랍니다. 설치방법1sudo curl -L https:&#x2F;&#x2F;github.com&#x2F;docker&#x2F;compose&#x2F;releases&#x2F;download&#x2F;1.29.1&#x2F;docker-compose-&#96;uname -s&#96;-&#96;uname -m&#96; -o &#x2F;usr&#x2F;local&#x2F;bin&#x2F;docker-compose 최신버전을 확인하고 download path 뒤의 숫자로 된 버전을 변경하여 설치도 가능합니다. 1sudo chmod +x &#x2F;usr&#x2F;local&#x2F;bin&#x2F;docker-compose docker-compose의 권한을 설정합니다. 1docker-compose --version docker-compose의 설치가 잘 되었는지 버전을 확인합니다.","categories":[{"name":"backend","slug":"backend","permalink":"https://swtpumpkin.github.io/categories/backend/"},{"name":"docker-compose","slug":"backend/docker-compose","permalink":"https://swtpumpkin.github.io/categories/backend/docker-compose/"}],"tags":[{"name":"install","slug":"install","permalink":"https://swtpumpkin.github.io/tags/install/"},{"name":"설치","slug":"설치","permalink":"https://swtpumpkin.github.io/tags/%EC%84%A4%EC%B9%98/"},{"name":"ubuntu","slug":"ubuntu","permalink":"https://swtpumpkin.github.io/tags/ubuntu/"},{"name":"docker","slug":"docker","permalink":"https://swtpumpkin.github.io/tags/docker/"},{"name":"도커","slug":"도커","permalink":"https://swtpumpkin.github.io/tags/%EB%8F%84%EC%BB%A4/"},{"name":"docker-compose","slug":"docker-compose","permalink":"https://swtpumpkin.github.io/tags/docker-compose/"},{"name":"우분투","slug":"우분투","permalink":"https://swtpumpkin.github.io/tags/%EC%9A%B0%EB%B6%84%ED%88%AC/"}]},{"title":"git 대소문자 구분","slug":"git/gitUpperLower","date":"2021-04-26T23:00:00.000Z","updated":"2021-04-27T01:08:24.203Z","comments":true,"path":"git/gitUpperLower/","link":"","permalink":"https://swtpumpkin.github.io/git/gitUpperLower/","excerpt":"","text":"git 대소문자 구분에디터에서는 파일명 대소문자 구분이 안되도 알아서 인식한다. 개발 환경에 따라 대소문자 구분없이도 알아서 인식해주면 다행인데 대소문자 구분을 확실히하게 되는경우 에러가 발생 할 수도 있다. 구분해서 인식하는게 맞기때문에 git설정을 변경해주면 해결이 된다. 해결방법1git config core.ignorecase false 위와 같이 깃 설정 하나만 변경해주면 된다.","categories":[{"name":"git","slug":"git","permalink":"https://swtpumpkin.github.io/categories/git/"}],"tags":[{"name":"git","slug":"git","permalink":"https://swtpumpkin.github.io/tags/git/"},{"name":"upper case","slug":"upper-case","permalink":"https://swtpumpkin.github.io/tags/upper-case/"},{"name":"lower case","slug":"lower-case","permalink":"https://swtpumpkin.github.io/tags/lower-case/"},{"name":"대문자","slug":"대문자","permalink":"https://swtpumpkin.github.io/tags/%EB%8C%80%EB%AC%B8%EC%9E%90/"},{"name":"소문자","slug":"소문자","permalink":"https://swtpumpkin.github.io/tags/%EC%86%8C%EB%AC%B8%EC%9E%90/"},{"name":"구분","slug":"구분","permalink":"https://swtpumpkin.github.io/tags/%EA%B5%AC%EB%B6%84/"}]},{"title":"ubuntu에 docker 설치","slug":"backend/docker/dockerUbuntuInstall","date":"2021-04-22T23:00:00.000Z","updated":"2023-01-19T07:06:09.763Z","comments":true,"path":"backend/docker/dockerUbuntuInstall/","link":"","permalink":"https://swtpumpkin.github.io/backend/docker/dockerUbuntuInstall/","excerpt":"","text":"ubuntu에 docker 설치ubuntu에 docker를 설치하여 docker를 사용 할 수 있습니다. docker가 기본적으로 설치되어있지 않기때문에 docker를 설치해줘야 합니다. 설치방법1sudo apt update apt를 이용하여 설치하기때문에 우선 업데이트 합니다. 1sudo apt install apt-transport-https ca-certificates curl software-properties-common docker에 필요한 패키지들을 설치합니다. 1curl -fsSL https:&#x2F;&#x2F;download.docker.com&#x2F;linux&#x2F;ubuntu&#x2F;gpg | sudo apt-key add - docker repository key를 추가합니다. 1sudo apt install docker.io docker를 설치합니다. 1sudo systemctl status docker 위 명령어를 통해 도커의 설치 및 상태를 확인 할 수 있습니다.위 사진과 같이 Active상태가 running이면 잘 작동중입니다. 1sudo chmod 777 &#x2F;var&#x2F;run&#x2F;docker.sock docker를 사용하기 위해서는 root권한이 필요합니다.docker의 권한을 777=rxw로 변경합니다.","categories":[{"name":"backend","slug":"backend","permalink":"https://swtpumpkin.github.io/categories/backend/"},{"name":"docker","slug":"backend/docker","permalink":"https://swtpumpkin.github.io/categories/backend/docker/"}],"tags":[{"name":"install","slug":"install","permalink":"https://swtpumpkin.github.io/tags/install/"},{"name":"ubuntu","slug":"ubuntu","permalink":"https://swtpumpkin.github.io/tags/ubuntu/"},{"name":"docker","slug":"docker","permalink":"https://swtpumpkin.github.io/tags/docker/"},{"name":"도커","slug":"도커","permalink":"https://swtpumpkin.github.io/tags/%EB%8F%84%EC%BB%A4/"},{"name":"우분투","slug":"우분투","permalink":"https://swtpumpkin.github.io/tags/%EC%9A%B0%EB%B6%84%ED%88%AC/"}]},{"title":"도커 데몬 에러","slug":"backend/docker/dockerDaemonError","date":"2021-03-01T23:00:00.000Z","updated":"2021-03-02T00:55:15.467Z","comments":true,"path":"backend/docker/dockerDaemonError/","link":"","permalink":"https://swtpumpkin.github.io/backend/docker/dockerDaemonError/","excerpt":"","text":"에러내용1234swtpumpkin:~&#x2F;docker-compose$ sudo docker-compose upERROR: Couldn&#39;t connect to Docker daemon at http+docker:&#x2F;&#x2F;localhost - is it running?​If it&#39;s at a non-standard location, specify the URL with the DOCKER_HOST environment variable. docker-compose를 사용하려고 하는데 위와 같은 에러가 뜨는 건 docker가 실행되지 않아서입니다. 1sudo systemctl status docker docker의 상태를 보면 실행상태가 아닐거에요. 해결방법1sudo systemctl start docker 위 명령어로 도커를 실행하면 docker-compose를 실행 할 수 있습니다.","categories":[{"name":"backend","slug":"backend","permalink":"https://swtpumpkin.github.io/categories/backend/"},{"name":"docker","slug":"backend/docker","permalink":"https://swtpumpkin.github.io/categories/backend/docker/"}],"tags":[{"name":"localhost","slug":"localhost","permalink":"https://swtpumpkin.github.io/tags/localhost/"},{"name":"docker","slug":"docker","permalink":"https://swtpumpkin.github.io/tags/docker/"},{"name":"도커","slug":"도커","permalink":"https://swtpumpkin.github.io/tags/%EB%8F%84%EC%BB%A4/"},{"name":"docker-compose","slug":"docker-compose","permalink":"https://swtpumpkin.github.io/tags/docker-compose/"},{"name":"daemon","slug":"daemon","permalink":"https://swtpumpkin.github.io/tags/daemon/"},{"name":"데몬","slug":"데몬","permalink":"https://swtpumpkin.github.io/tags/%EB%8D%B0%EB%AA%AC/"}]},{"title":"Docker로 MySQL 사용하기","slug":"backend/docker/dockerMysql","date":"2021-02-03T00:00:00.000Z","updated":"2021-02-03T07:27:37.465Z","comments":true,"path":"backend/docker/dockerMysql/","link":"","permalink":"https://swtpumpkin.github.io/backend/docker/dockerMysql/","excerpt":"","text":"Docker를 이용하여 MySQL 사용docker hub에서 MySQL의 official image를 이용하여 MySQL을 docker로 실행 할 수 있습니다. docker hub의 레포는 여기를 누르시면 볼 수 있습니다. 사용 방법1docker pull mysql 일단 docker hub에서 mysql를 풀받아 이미지를 내려받습니다. 풀 받을때 mysql:tag와 같이 tag를 입력하여 버전을 선택 할 수 있고 tag를 지정하지 않으면 latest버전 이미지를 갖고옵니다. 1docker run -d -p 3306:3306 --restart&#x3D;always -e MYSQL_ROOT_PASSWORD&#x3D;pwd --name mysql mysql --character-set-server&#x3D;utf8mb4 --collation-server&#x3D;utf8mb4_unicode_ci --default-authentication-plugin&#x3D;mysql_native_password -d옵션을 통해 백그라운드로 docker를 실행합니다.-p옵션을 통해 3306포트를 3306포트로 연결합니다.--restart=always 옵션을 사용하면 컴퓨터를 재시작 하더라도 자동으로 실행시켜 줄 수 있습니다.-e MYSQL_ROOT_PASSWORD=pwd 옵션에서 pwd대신 사용하실 password를 입력하시면 됩니다.--name 옵션을 통해 docker의 이름을 mysql로 지정합니다.--character-set-server=utf8mb4 --collation-server=utf8mb4_unicode_ci 옵션을 통해 한글깨짐을 방지합니다.--default-authentication-plugin=mysql_native_password 옵션을 통해 인증 플러그인을 변경합니다. 1docker ps 위 코드를 통해 현재 실행중인 도커 리스트를 볼 수 있습니다.sequel pro나 workbench등 GUI프로그램을 통해 MySQL에 접속하려면 다음과 같은 caching_sha2_password 에러가 발생합니다.비밀번호를 sha2방식으로 암호화 하지 않아 생기는 오류입니다. 1docker exec -i -t mysql bash 위 코드로 mysql docker에 접속합니다. 1mysql -u root -p mysql 설정 때 입력하였던 비밀번호를 이용하여 루트로 접속합니다. 1ALTER USER &#39;root&#39;@&#39;localhost&#39; IDENTIFIED WITH mysql_native_password BY &#39;your password&#39;; your password부분을 설정하였던 비밀번호로 대치 후 입력합니다.위와 같이 쿼리가 정상적으로 실행 됐다면 sequel pro, workbench와 같은 GUI에서 접속이 가능합니다.","categories":[{"name":"backend","slug":"backend","permalink":"https://swtpumpkin.github.io/categories/backend/"},{"name":"docker","slug":"backend/docker","permalink":"https://swtpumpkin.github.io/categories/backend/docker/"}],"tags":[{"name":"docker","slug":"docker","permalink":"https://swtpumpkin.github.io/tags/docker/"},{"name":"mysql","slug":"mysql","permalink":"https://swtpumpkin.github.io/tags/mysql/"},{"name":"dockerHub","slug":"dockerHub","permalink":"https://swtpumpkin.github.io/tags/dockerHub/"},{"name":"caching_sha2_password","slug":"caching-sha2-password","permalink":"https://swtpumpkin.github.io/tags/caching-sha2-password/"}]},{"title":"라즈베리파이 docker-compose 설치","slug":"pi/piDockerCompose","date":"2021-01-31T23:00:00.000Z","updated":"2021-02-01T03:24:08.124Z","comments":true,"path":"pi/piDockerCompose/","link":"","permalink":"https://swtpumpkin.github.io/pi/piDockerCompose/","excerpt":"","text":"라즈베리파이에 docker-compose를 설치하는 방법docker-compose를 설치하기 전 pip3가 설치되어 있어야합니다. python3 및 pip3가 설치되지 않은경우 다음 코드를 통해 설치합니다. 123sudo apt-get install libffi-dev libssl-devsudo apt install python3-devsudo apt-get install -y python3 python3-pip python3과 pip3가 설치되면 다음 코드로 docker-compose를 설치합니다. 1sudo pip3 install docker-compose","categories":[{"name":"pi","slug":"pi","permalink":"https://swtpumpkin.github.io/categories/pi/"}],"tags":[{"name":"docker","slug":"docker","permalink":"https://swtpumpkin.github.io/tags/docker/"},{"name":"pi","slug":"pi","permalink":"https://swtpumpkin.github.io/tags/pi/"},{"name":"라즈베리파이4","slug":"라즈베리파이4","permalink":"https://swtpumpkin.github.io/tags/%EB%9D%BC%EC%A6%88%EB%B2%A0%EB%A6%AC%ED%8C%8C%EC%9D%B44/"},{"name":"라즈베리파이","slug":"라즈베리파이","permalink":"https://swtpumpkin.github.io/tags/%EB%9D%BC%EC%A6%88%EB%B2%A0%EB%A6%AC%ED%8C%8C%EC%9D%B4/"},{"name":"raspberrypi","slug":"raspberrypi","permalink":"https://swtpumpkin.github.io/tags/raspberrypi/"},{"name":"raspberrypi4","slug":"raspberrypi4","permalink":"https://swtpumpkin.github.io/tags/raspberrypi4/"},{"name":"도커","slug":"도커","permalink":"https://swtpumpkin.github.io/tags/%EB%8F%84%EC%BB%A4/"},{"name":"docker-compose","slug":"docker-compose","permalink":"https://swtpumpkin.github.io/tags/docker-compose/"},{"name":"도커컴포즈","slug":"도커컴포즈","permalink":"https://swtpumpkin.github.io/tags/%EB%8F%84%EC%BB%A4%EC%BB%B4%ED%8F%AC%EC%A6%88/"}]},{"title":"docker 데몬 연결 에러(\"Cannot connect to the Docker daemon at unix:///var/run/docker.sock. Is the docker daemon running?\")","slug":"backend/docker/dockerConnectError","date":"2021-01-21T23:03:00.000Z","updated":"2021-01-22T06:39:17.990Z","comments":true,"path":"backend/docker/dockerConnectError/","link":"","permalink":"https://swtpumpkin.github.io/backend/docker/dockerConnectError/","excerpt":"","text":"Cannot connect to the Docker daemon at unix:///var/run/docker.sock. Is the docker daemon running? 에러 해결 방법 docker 상태 확인1sudo systemctl status docker 도커의 상태를 보면 위와같이 도커가 실행되지 않고 있습니다. 시스템데몬(system daemon) 명령어로 docker를 시작합니다.1sudo systemctl start docker 다음 명령어로 도커의 상태를 확인합니다. 1sudo systemctl status docker 상태 확인 명령어로 보면 도커가 잘 실행되고 있는 것을 확인 할 수 있습니다.","categories":[{"name":"backend","slug":"backend","permalink":"https://swtpumpkin.github.io/categories/backend/"},{"name":"docker","slug":"backend/docker","permalink":"https://swtpumpkin.github.io/categories/backend/docker/"}],"tags":[{"name":"docker","slug":"docker","permalink":"https://swtpumpkin.github.io/tags/docker/"},{"name":"error","slug":"error","permalink":"https://swtpumpkin.github.io/tags/error/"},{"name":"도커","slug":"도커","permalink":"https://swtpumpkin.github.io/tags/%EB%8F%84%EC%BB%A4/"},{"name":"connect","slug":"connect","permalink":"https://swtpumpkin.github.io/tags/connect/"},{"name":"에러","slug":"에러","permalink":"https://swtpumpkin.github.io/tags/%EC%97%90%EB%9F%AC/"}]},{"title":"라즈베리파이 docker 제거하는 방법","slug":"pi/piDockerUninstall","date":"2021-01-21T23:01:00.000Z","updated":"2021-01-22T06:19:31.741Z","comments":true,"path":"pi/piDockerUninstall/","link":"","permalink":"https://swtpumpkin.github.io/pi/piDockerUninstall/","excerpt":"","text":"라즈베리파이에 도커를 제거하는 방법도커 설치는 스크립트로 하였지만 제거는 패키지관리자로 할 수 있습니다. 다음 명령어로 도커 제거를 실행합니다. 1sudo apt-get purge docker-ce &amp;&amp; sudo apt-get purge docker-ce-cli 남아있는 도커관련 images, containers, volumes, data를 제거합니다. 1sudo rm -rf &#x2F;var&#x2F;lib&#x2F;docker","categories":[{"name":"pi","slug":"pi","permalink":"https://swtpumpkin.github.io/categories/pi/"}],"tags":[{"name":"docker","slug":"docker","permalink":"https://swtpumpkin.github.io/tags/docker/"},{"name":"pi","slug":"pi","permalink":"https://swtpumpkin.github.io/tags/pi/"},{"name":"라즈베리파이4","slug":"라즈베리파이4","permalink":"https://swtpumpkin.github.io/tags/%EB%9D%BC%EC%A6%88%EB%B2%A0%EB%A6%AC%ED%8C%8C%EC%9D%B44/"},{"name":"라즈베리파이","slug":"라즈베리파이","permalink":"https://swtpumpkin.github.io/tags/%EB%9D%BC%EC%A6%88%EB%B2%A0%EB%A6%AC%ED%8C%8C%EC%9D%B4/"},{"name":"raspberrypi","slug":"raspberrypi","permalink":"https://swtpumpkin.github.io/tags/raspberrypi/"},{"name":"raspberrypi4","slug":"raspberrypi4","permalink":"https://swtpumpkin.github.io/tags/raspberrypi4/"},{"name":"도커","slug":"도커","permalink":"https://swtpumpkin.github.io/tags/%EB%8F%84%EC%BB%A4/"},{"name":"uninstall","slug":"uninstall","permalink":"https://swtpumpkin.github.io/tags/uninstall/"},{"name":"제거","slug":"제거","permalink":"https://swtpumpkin.github.io/tags/%EC%A0%9C%EA%B1%B0/"}]},{"title":"라즈베리파이 docker 설치하는 방법","slug":"pi/piDockerInstall","date":"2021-01-21T23:00:00.000Z","updated":"2021-01-22T05:47:13.555Z","comments":true,"path":"pi/piDockerInstall/","link":"","permalink":"https://swtpumpkin.github.io/pi/piDockerInstall/","excerpt":"","text":"라즈베리파이에 도커를 설치하는 방법 시스템 업데이트와 업그레이드를 합니다.1sudo apt-get update &amp;&amp; sudo apt-get upgrade docker script를 다운받습니다.1curl -fsSL https:&#x2F;&#x2F;get.docker.com -o get-docker.sh 다음 명령어를 사용하여 script를 실행합니다.1sudo sh get-docker.sh docker 설치 확인1sudo docker version docker 버전을 확인했을 때 위와같이 버전이 확인되면 설치가 완료됩니다. docker에 사용자 권한 추가1sudo usermod -aG docker [user_name] user_name에 사용자의 이름을 넣게되면 docker의 관리권한이 생깁니다.라즈베리파이의 기본 유저인 pi를 user_name에 넣게되면 도커를 관리 할 수 있습니다. 1sudo usermod -aG docker pi","categories":[{"name":"pi","slug":"pi","permalink":"https://swtpumpkin.github.io/categories/pi/"}],"tags":[{"name":"install","slug":"install","permalink":"https://swtpumpkin.github.io/tags/install/"},{"name":"설치","slug":"설치","permalink":"https://swtpumpkin.github.io/tags/%EC%84%A4%EC%B9%98/"},{"name":"docker","slug":"docker","permalink":"https://swtpumpkin.github.io/tags/docker/"},{"name":"pi","slug":"pi","permalink":"https://swtpumpkin.github.io/tags/pi/"},{"name":"라즈베리파이4","slug":"라즈베리파이4","permalink":"https://swtpumpkin.github.io/tags/%EB%9D%BC%EC%A6%88%EB%B2%A0%EB%A6%AC%ED%8C%8C%EC%9D%B44/"},{"name":"라즈베리파이","slug":"라즈베리파이","permalink":"https://swtpumpkin.github.io/tags/%EB%9D%BC%EC%A6%88%EB%B2%A0%EB%A6%AC%ED%8C%8C%EC%9D%B4/"},{"name":"raspberrypi","slug":"raspberrypi","permalink":"https://swtpumpkin.github.io/tags/raspberrypi/"},{"name":"raspberrypi4","slug":"raspberrypi4","permalink":"https://swtpumpkin.github.io/tags/raspberrypi4/"},{"name":"도커","slug":"도커","permalink":"https://swtpumpkin.github.io/tags/%EB%8F%84%EC%BB%A4/"}]},{"title":"라즈베리파이 ssd 부팅하는 방법","slug":"pi/piSsd","date":"2021-01-18T23:00:00.000Z","updated":"2021-01-19T04:22:29.212Z","comments":true,"path":"pi/piSsd/","link":"","permalink":"https://swtpumpkin.github.io/pi/piSsd/","excerpt":"","text":"usb를 이용한 라즈베리파이 부팅펌웨어 업데이트를 하면 모든 USB를 통해 라즈베리파이를 부팅 할 수 있습니다. 다음 코드로 펌웨어 및 OS를 업데이트 합니다.123sudo apt updatesudo apt full-upgradesudo rpi-update 라즈베리파이를 재부팅합니다.1sudo reboot 다음 코드로 최신 부트 로더를 설치합니다.1sudo rpi-eeprom-update -d -a 라즈베리파이를 재부팅합니다.1sudo reboot raspi-config를 실행합니다.1sudo raspi-config 6번 Advanced Options를 선택합니다. A6번 Boot Order를 선택합니다. B1번 USB Boot를 선택합니다. OK를 선택합니다. 외장하드 or SSD or USB를 연결 후 시작 -&gt; Accessories에서 SD Card Copier를 선택합니다. Copy From Device에 복사 할 sd card를 선택하고 Copy To Device에 복사 될 외장하드 or SSD or USB를 선택합니다. 모두 삭제 된다는 안내에 동의 후 진행합니다. 복사가 완료되면 다음 코드로 라즈베리파이를 종료합니다. 1sudo shutdown -h now 기존 설치되어있는 sd card를 제거합니다. 라즈베리파이의 전원을 켜면 복사된 장치를 통해 부팅됩니다.","categories":[{"name":"pi","slug":"pi","permalink":"https://swtpumpkin.github.io/categories/pi/"}],"tags":[{"name":"pi","slug":"pi","permalink":"https://swtpumpkin.github.io/tags/pi/"},{"name":"라즈베리파이4","slug":"라즈베리파이4","permalink":"https://swtpumpkin.github.io/tags/%EB%9D%BC%EC%A6%88%EB%B2%A0%EB%A6%AC%ED%8C%8C%EC%9D%B44/"},{"name":"라즈베리파이","slug":"라즈베리파이","permalink":"https://swtpumpkin.github.io/tags/%EB%9D%BC%EC%A6%88%EB%B2%A0%EB%A6%AC%ED%8C%8C%EC%9D%B4/"},{"name":"raspberrypi","slug":"raspberrypi","permalink":"https://swtpumpkin.github.io/tags/raspberrypi/"},{"name":"raspberrypi4","slug":"raspberrypi4","permalink":"https://swtpumpkin.github.io/tags/raspberrypi4/"},{"name":"ssd","slug":"ssd","permalink":"https://swtpumpkin.github.io/tags/ssd/"},{"name":"boot","slug":"boot","permalink":"https://swtpumpkin.github.io/tags/boot/"},{"name":"booting","slug":"booting","permalink":"https://swtpumpkin.github.io/tags/booting/"}]},{"title":"라즈베리파이에서 vim 설치","slug":"pi/piVim","date":"2021-01-17T23:00:00.000Z","updated":"2021-01-18T06:56:37.836Z","comments":true,"path":"pi/piVim/","link":"","permalink":"https://swtpumpkin.github.io/pi/piVim/","excerpt":"","text":"라즈베리파이에서 vi 에디터를 사용하려면 vim을 설치해야합니다. 라즈베리파이 터미널에서 패키지목록을 최신화 시켜줍니다.12sudo apt-get updatesudo apt-get upgrade vim 설치1sudo apt-get install vim 이렇게 하면 간단하게 vim을 설치하였고 이제 vi에디터를 사용 할 수 있습니다.","categories":[{"name":"pi","slug":"pi","permalink":"https://swtpumpkin.github.io/categories/pi/"}],"tags":[{"name":"install","slug":"install","permalink":"https://swtpumpkin.github.io/tags/install/"},{"name":"pi","slug":"pi","permalink":"https://swtpumpkin.github.io/tags/pi/"},{"name":"라즈베리파이4","slug":"라즈베리파이4","permalink":"https://swtpumpkin.github.io/tags/%EB%9D%BC%EC%A6%88%EB%B2%A0%EB%A6%AC%ED%8C%8C%EC%9D%B44/"},{"name":"라즈베리파이","slug":"라즈베리파이","permalink":"https://swtpumpkin.github.io/tags/%EB%9D%BC%EC%A6%88%EB%B2%A0%EB%A6%AC%ED%8C%8C%EC%9D%B4/"},{"name":"raspberrypi","slug":"raspberrypi","permalink":"https://swtpumpkin.github.io/tags/raspberrypi/"},{"name":"raspberrypi4","slug":"raspberrypi4","permalink":"https://swtpumpkin.github.io/tags/raspberrypi4/"},{"name":"vi","slug":"vi","permalink":"https://swtpumpkin.github.io/tags/vi/"},{"name":"vim","slug":"vim","permalink":"https://swtpumpkin.github.io/tags/vim/"}]},{"title":"라즈베리파이 xrdp를 이용하여 원격 접속","slug":"pi/piXrdp","date":"2021-01-04T23:00:00.000Z","updated":"2021-01-18T06:16:24.182Z","comments":true,"path":"pi/piXrdp/","link":"","permalink":"https://swtpumpkin.github.io/pi/piXrdp/","excerpt":"","text":"xrdp 설치방법123sudo apt-get updatesudo apt-get upgradesudo apt-get install xrdp apt-get를 이용하여 xrdp를 설치합니다. 1sudo apt-get update &amp;&amp; sudo apt-get upgrade &amp;&amp; sudo apt-get install xrdp 이렇게 명령어를 작성하여 실행하면 한번에 apt-get으로 update, upgrade, xrdp설치까지 완료됩니다. Microsoft Desktop Remote를 이용하여 원격 접속 라즈베리파이에서 내부할당 ip주소를 알아냅니다.1ifconfig Microsoft Remote Desktop을 설치 후 실행합니다. 설치는 여기에서 앱을 설치하시면 됩니다. Microsoft Remote Desktop에서 Add PC를 선택합니다. PC name에는 ifconfig로 찾았던 ip주소를 입력합니다. Friendly name에는 raspberrypi라고 입력하겠습니다. Friendly name은 옵션이기때문에 원하시는 이름을 입력하시면 됩니다. User account에서 Add User Account...를 선택합니다. Username에는 설정했던 Username을 입력하시고, Password에는 처음 라즈베리파이 설정했을때의 비밀번호를 입력하시면 됩니다. 설정이 완료되면 아래와 같이 목록에 raspberrypi라고 나오는데 더블클릭하여 접속을 시도합니다. username에는 pi, password에는 raspberry라고 입력합니다. 아래와 같이 접속을 성공하면 hdmi케이블 없이 원격으로 접속 할 수 있습니다.","categories":[{"name":"pi","slug":"pi","permalink":"https://swtpumpkin.github.io/categories/pi/"}],"tags":[{"name":"mac","slug":"mac","permalink":"https://swtpumpkin.github.io/tags/mac/"},{"name":"pi","slug":"pi","permalink":"https://swtpumpkin.github.io/tags/pi/"},{"name":"라즈베리파이4","slug":"라즈베리파이4","permalink":"https://swtpumpkin.github.io/tags/%EB%9D%BC%EC%A6%88%EB%B2%A0%EB%A6%AC%ED%8C%8C%EC%9D%B44/"},{"name":"라즈베리파이","slug":"라즈베리파이","permalink":"https://swtpumpkin.github.io/tags/%EB%9D%BC%EC%A6%88%EB%B2%A0%EB%A6%AC%ED%8C%8C%EC%9D%B4/"},{"name":"raspberrypi","slug":"raspberrypi","permalink":"https://swtpumpkin.github.io/tags/raspberrypi/"},{"name":"raspberrypi4","slug":"raspberrypi4","permalink":"https://swtpumpkin.github.io/tags/raspberrypi4/"},{"name":"xrdp","slug":"xrdp","permalink":"https://swtpumpkin.github.io/tags/xrdp/"},{"name":"원격접속","slug":"원격접속","permalink":"https://swtpumpkin.github.io/tags/%EC%9B%90%EA%B2%A9%EC%A0%91%EC%86%8D/"},{"name":"Microsoft","slug":"Microsoft","permalink":"https://swtpumpkin.github.io/tags/Microsoft/"},{"name":"Desktop","slug":"Desktop","permalink":"https://swtpumpkin.github.io/tags/Desktop/"},{"name":"Remote","slug":"Remote","permalink":"https://swtpumpkin.github.io/tags/Remote/"},{"name":"맥북","slug":"맥북","permalink":"https://swtpumpkin.github.io/tags/%EB%A7%A5%EB%B6%81/"}]},{"title":"라즈베리파이4 micro sd 설치","slug":"pi/piStart","date":"2021-01-03T23:00:00.000Z","updated":"2021-01-04T05:11:58.903Z","comments":true,"path":"pi/piStart/","link":"","permalink":"https://swtpumpkin.github.io/pi/piStart/","excerpt":"","text":"Raspberry pi Imager라즈베리파이 이미저를 라즈베리파이 홈페이지에서 다운 받습니다. 여기로 이동하면 Raspberry Pi Imager를 다운받을 수 있습니다. 운영체제에 맞게 설치하시면 됩니다. Raspberry pi Imager를 통한 micro sd os 설치CHOOSE OS를 선택하여 설치 할 OS를 선택합니다.Raspberry Pi OS (32-bit)를 선택합니다.CHOOSE SD CARD를 선택합니다.설치 할 sd card를 선택합니다.WRITE를 선택하여 sd card에 Raspberry Pi OS를 설치합니다.","categories":[{"name":"pi","slug":"pi","permalink":"https://swtpumpkin.github.io/categories/pi/"}],"tags":[{"name":"pi","slug":"pi","permalink":"https://swtpumpkin.github.io/tags/pi/"},{"name":"라즈베리파이4","slug":"라즈베리파이4","permalink":"https://swtpumpkin.github.io/tags/%EB%9D%BC%EC%A6%88%EB%B2%A0%EB%A6%AC%ED%8C%8C%EC%9D%B44/"},{"name":"라즈베리파이","slug":"라즈베리파이","permalink":"https://swtpumpkin.github.io/tags/%EB%9D%BC%EC%A6%88%EB%B2%A0%EB%A6%AC%ED%8C%8C%EC%9D%B4/"},{"name":"raspberrypi","slug":"raspberrypi","permalink":"https://swtpumpkin.github.io/tags/raspberrypi/"},{"name":"raspberrypi4","slug":"raspberrypi4","permalink":"https://swtpumpkin.github.io/tags/raspberrypi4/"},{"name":"microsd","slug":"microsd","permalink":"https://swtpumpkin.github.io/tags/microsd/"},{"name":"imager","slug":"imager","permalink":"https://swtpumpkin.github.io/tags/imager/"},{"name":"os","slug":"os","permalink":"https://swtpumpkin.github.io/tags/os/"}]},{"title":"React Native Android APK","slug":"frontend/reactNative/reactNativeAndroidApk","date":"2020-11-27T01:00:00.000Z","updated":"2020-11-27T01:34:51.913Z","comments":true,"path":"frontend/reactNative/reactNativeAndroidApk/","link":"","permalink":"https://swtpumpkin.github.io/frontend/reactNative/reactNativeAndroidApk/","excerpt":"","text":"Android 앱 설치를 위한 apk 파일 생성 방법1. key storeAndroid용 apk를 만드려면 keystore 파일이 필요합니다. 따라서 keystore파일을 만들겠습니다. 1keytool -genkey -v -keystore your_key_name.keystore -alias your_key_alias -keyalg RSA -keysize 2048 -validity 10000 이렇게 keystore파일을 터미널을 이용해 만들 수 있습니다. 터미널을 켜자마자 위 코드를 실행하면 root dir에 파일이 생성됩니다. your_key_name과 your_key_alias는 원하는 값으로 설정하시면 됩니다. 원하는 값으로 설정 후 터미널에서 실행하면 다음과 같이 나타납니다. 123456789101112131415161718192021222324252627keytool -genkey -v -keystore your_key_name.keystore -alias your_key_alias -keyalg RSA -keysize 2048 -validity 10000키 저장소 비밀번호 입력: &#x2F;&#x2F; 키 저장소의 비밀번호는 6자리 이상으로 설정해야합니다.새 비밀번호 다시 입력:이름과 성을 입력하십시오. [Unknown]: swtpumpkin조직 단위 이름을 입력하십시오. [Unknown]: Company조직 이름을 입력하십시오. [Unknown]: Development Department구&#x2F;군&#x2F;시 이름을 입력하십시오? [Unknown]: Seoul시&#x2F;도 이름을 입력하십시오. [Unknown]: Secho이 조직의 두 자리 국가 코드를 입력하십시오. [Unknown]: KRCN&#x3D;swtpumpkin, OU&#x3D;Google, O&#x3D;Development Department, L&#x3D;Seoul, ST&#x3D;Secho, C&#x3D;KR이(가) 맞습니까? [아니오]: y다음에 대해 유효 기간이 10,000일인 2,048비트 RSA 키 쌍 및 자체 서명된 인증서(SHA256withRSA)를 생성하는 중 : CN&#x3D;swtpumpkin, OU&#x3D;Google, O&#x3D;Development Department, L&#x3D;Seoul, ST&#x3D;Secho, C&#x3D;KR&lt;your_key_alias&gt;에 대한 키 비밀번호를 입력하십시오. (키 저장소 비밀번호와 동일한 경우 Enter 키를 누름):[your_key_name.keystore을(를) 저장하는 중]Warning:JKS 키 저장소는 고유 형식을 사용합니다. &quot;keytool -importkeystore -srckeystore your_key_name.keystore -destkeystore your_key_name.keystore -deststoretype pkcs12&quot;를 사용하는 산업 표준 형식인 PKCS12로 이전하는 것이 좋습니다. 입력값을 모두 입력하면 10000일동안 유효한 keystore파일이 생성됩니다. 2. key store를 프로젝트에 추가your_key_name.keystore 파일을 React Native 프로젝트 내 폴더로 추가해야합니다. 경로는 /android/app폴더에 추가해야합니다.위와 같이 폴더에 keystore를 복사해주면 됩니다. 3. release AAB 생성React Native프로젝트 기준으로 터미널을 실행하겠습니다. 1cd android android 폴더로 이동합니다. 1.&#x2F;gradlew bundleRelease 위 명령어를 android 폴더에서 실행합니다.명령어를 실행하면 /android/app/build/outputs/bundle/release 폴더에 app-release.aab 파일이 생성됩니다. 4. AAB 파일을 APK 파일로 변환1.&#x2F;gradlew app:assembleRelease android 폴더 내에서 위 명령어를 실행합니다.명령어를 실행하면 /android/app/build/outputs/apk/release 폴더에 app-release.apk 파일이 생성됩니다. app-release.apk 파일을 안드로이드로 복사하여 앱을 바로 설치 할 수 있습니다.","categories":[{"name":"frontend","slug":"frontend","permalink":"https://swtpumpkin.github.io/categories/frontend/"},{"name":"reactNative","slug":"frontend/reactNative","permalink":"https://swtpumpkin.github.io/categories/frontend/reactNative/"}],"tags":[{"name":"reactNative","slug":"reactNative","permalink":"https://swtpumpkin.github.io/tags/reactNative/"},{"name":"android","slug":"android","permalink":"https://swtpumpkin.github.io/tags/android/"},{"name":"apk","slug":"apk","permalink":"https://swtpumpkin.github.io/tags/apk/"},{"name":"build","slug":"build","permalink":"https://swtpumpkin.github.io/tags/build/"}]},{"title":"zsh compinit","slug":"develop/zshCompinit","date":"2020-11-19T01:00:00.000Z","updated":"2020-11-19T03:58:38.864Z","comments":true,"path":"develop/zshCompinit/","link":"","permalink":"https://swtpumpkin.github.io/develop/zshCompinit/","excerpt":"","text":"zsh compinit맥 터미널에서 아래와 같은 에러가 발생하는 경우가 있습니다. 12zsh compinit: insecure directories, run compaudit for list.Ignore insecure directories and continue [y] or abort compinit [n]? 해결방법1compaudit | xargs chmod g-w 위 명령어를 터미널에 입력합니다. 1There are insecure directories: 실행결과 위와 같이 출력되면 에러가 발생하지 않습니다.","categories":[{"name":"develop","slug":"develop","permalink":"https://swtpumpkin.github.io/categories/develop/"}],"tags":[{"name":"zsh","slug":"zsh","permalink":"https://swtpumpkin.github.io/tags/zsh/"},{"name":"compinit","slug":"compinit","permalink":"https://swtpumpkin.github.io/tags/compinit/"}]},{"title":"While Statement","slug":"javascript/whileStatement","date":"2020-07-20T23:00:00.000Z","updated":"2020-07-21T04:38:06.402Z","comments":true,"path":"javascript/whileStatement/","link":"","permalink":"https://swtpumpkin.github.io/javascript/whileStatement/","excerpt":"","text":"Whilejavascript에서 While문법은 동일한 동작을 반복 할 수 있습니다. 사용방법12while (condition) &#123;&#125;; while 문법은 위와 같습니다. condition이 true일 때 while문 안의 내용이 실행됩니다. while 문은 세가지(Loop start, Loop end, Loop increment/decrement) 주요 항목이 있습니다. 12345let num = 1; // startwhile (num &lt;= 10) &#123; // end console.log(num); num++; // increment&#125;; num변수가 1로 시작하여 10까지 증가하는 while문을 작성하였습니다. 1234let num = 1; // startwhile (num &lt;= 10) &#123; // end console.log(num);&#125;; 위와같이 num 변수가 증가하는 부분이 없다면 1만 출력하는 무한루프가 생성됩니다. 12345let num = 10; // startwhile (num) &#123; // end console.log(num); num--; // decrement&#125;; num--와 같이 num변수를 감소시키면 0이 false를 의미하기 때문에 반복문이 종료되게 만들 수 있습니다. 12let num = 10;while (num) console.log(num--); while반복문 내 코드가 한 줄이라면 중괄호 없이 사용할 수 있습니다.","categories":[{"name":"javascript","slug":"javascript","permalink":"https://swtpumpkin.github.io/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://swtpumpkin.github.io/tags/javascript/"},{"name":"while statement","slug":"while-statement","permalink":"https://swtpumpkin.github.io/tags/while-statement/"},{"name":"와일문","slug":"와일문","permalink":"https://swtpumpkin.github.io/tags/%EC%99%80%EC%9D%BC%EB%AC%B8/"},{"name":"반복문","slug":"반복문","permalink":"https://swtpumpkin.github.io/tags/%EB%B0%98%EB%B3%B5%EB%AC%B8/"}]},{"title":"Switch Statement","slug":"javascript/switchStatement","date":"2020-07-19T23:00:00.000Z","updated":"2020-07-21T01:18:42.343Z","comments":true,"path":"javascript/switchStatement/","link":"","permalink":"https://swtpumpkin.github.io/javascript/switchStatement/","excerpt":"","text":"Switchjavascript에서 switch문법은 if, else if를 대체 할 수 있습니다. if, else if와 비슷하지만 약간의 문법 차이가 있습니다. 사용방법12345678910111213141516171819const dayNum = new Date().getDay();function ifDay(dayNum) &#123; if (dayNum === 1) &#123; return '월요일'; &#125; else if (dayNum === 2) &#123; return '화요일'; &#125; else if (dayNum === 3) &#123; return '수요일'; &#125; else if (dayNum === 4) &#123; return '목요일'; &#125; else if (dayNum === 5) &#123; return '금요일'; &#125; else if (dayNum === 6 || dayNum === 0) &#123; return '주말'; &#125; else &#123; return '알 수 없음'; &#125;;&#125;console.log(ifDay(dayNum)); if, else if 조건문을 이용해서 오늘의 요일을 알 수 있습니다. 하지만 if, else if를 쓰게되면 모든 if를 순서대로 체크하고 값을 반환하게 됩니다. 하지만 switch를 이용하게 되면 해당하는 코드블록 하나만 실행하게 됩니다. 값이 일치하지 않는다면 기본(default)값이 설정됩니다. 위 값을 switch문으로 변경해보도록 하겠습니다. 12345678910111213141516171819202122232425262728const dayNum = new Date().getDay();function switchDay(dayNum) &#123; switch (dayNum) &#123; case 1: return '월요일'; break; case 2: return '화요일'; break; case 3: return '수요일'; break; case 4: return '목요일'; break; case 5: return '금요일'; break; case 6: case 0: return '주말'; break; default: return '알 수 없음'; break; &#125;;&#125;;console.log(switchDay(dayNum)); 이렇게 switch문으로 사용 할 수 있습니다. 하지만 if, else if문, switch문 보다 속도가 더 빠르고 조건문과 비슷한 Object의 square brackets syntax를 이용한 방법이 있습니다. square brackets syntax를 이용한 유사 조건문123456789101112131415const dayNum = new Date().getDay();function objDay(dayNum) &#123; const dayObj = &#123; 1: '월요일', 2: '화요일', 3: '수요일', 4: '목요일', 5: '금요일', 6: '주말', 0: '주말', &#125;; if(!dayObj[dayNum]) return '알 수 없음'; return dayObj[dayNum];&#125;console.log(objDay(dayNum)); if, switch, object 세가지 조건문 성능을 여기에서 볼 수 있습니다. 간단한 조건문은 Object를 이용하는 것도 한가지 방법입니다. 감사합니다.","categories":[{"name":"javascript","slug":"javascript","permalink":"https://swtpumpkin.github.io/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://swtpumpkin.github.io/tags/javascript/"},{"name":"switch statement","slug":"switch-statement","permalink":"https://swtpumpkin.github.io/tags/switch-statement/"},{"name":"스위치문","slug":"스위치문","permalink":"https://swtpumpkin.github.io/tags/%EC%8A%A4%EC%9C%84%EC%B9%98%EB%AC%B8/"}]},{"title":"styled-components에서 css 변수 사용","slug":"frontend/react/styledComponentsCss","date":"2020-07-07T23:00:00.000Z","updated":"2020-07-09T09:29:29.882Z","comments":true,"path":"frontend/react/styledComponentsCss/","link":"","permalink":"https://swtpumpkin.github.io/frontend/react/styledComponentsCss/","excerpt":"","text":"styled-components에서 css 사용하기styled-components를 사용하면서 공통된 css가 있을 수 있습니다. 자주 사용하는 css를 변수로 선언하고 styled-components에서 재사용 할 수 있습니다. 사용방법1234567import &#123; css &#125; from 'styled-components';export const flexCenterAlign = css` display: flex; align-items: center; justify-content: center;`; flex를 이용하여 중앙 정렬하는 css를 자주 사용해서 styleConstants.ts파일 생성 후 flexCenterAlign변수를 선언 후 export 해줍니다. 123456789101112131415161718192021import React from 'react';import &#123; flexCenterAlign &#125; from 'styles/styleConstants';import styled from 'styled-components';const CenterAlign = styled.div` width: 100px; height: 100px; border: 1px solid black; margin: 10px; $&#123;flexCenterAlign&#125;`;export default (): JSX.Element =&gt; &#123; return ( &lt;&gt; &lt;CenterAlign&gt; 중앙 정렬 &lt;/CenterAlign&gt; &lt;/&gt; );&#125; 템플릿 리터럴 문법에선 백틱(``)안에 표현식삽입법(${})를 이용하여 변수를 사용 할 수 있습니다. 따라서 flexCenterAlign변수를 불러와 해당 변수의 css를 사용 할 수 있습니다.위와 같이 중앙 정렬 text가 flexCenterAlign변수의 값을 사용하여 가운데 정렬된 것을 볼 수 있습니다.","categories":[{"name":"frontend","slug":"frontend","permalink":"https://swtpumpkin.github.io/categories/frontend/"},{"name":"react","slug":"frontend/react","permalink":"https://swtpumpkin.github.io/categories/frontend/react/"}],"tags":[{"name":"css","slug":"css","permalink":"https://swtpumpkin.github.io/tags/css/"},{"name":"react","slug":"react","permalink":"https://swtpumpkin.github.io/tags/react/"},{"name":"styled-components","slug":"styled-components","permalink":"https://swtpumpkin.github.io/tags/styled-components/"}]},{"title":"React Router (Link)","slug":"frontend/react/reactRouterLink","date":"2020-06-29T23:00:00.000Z","updated":"2020-06-30T00:08:55.115Z","comments":true,"path":"frontend/react/reactRouterLink/","link":"","permalink":"https://swtpumpkin.github.io/frontend/react/reactRouterLink/","excerpt":"","text":"React Router DomReact Router Dom을 이용하여 링크를 변경하는 방법에 대해 포스팅하겠습니다. 사용방법1npm i react-router-dom react-router-dom패키지를 설치합니다. 1npm i react-router-dom @types&#x2F;react-router-dom typescript의 경우 위 두 개의 패키지를 설치해야합니다. 12345678910111213import App from './App';import &#123; BrowserRouter &#125; from 'react-router-dom';import React from 'react';import ReactDOM from 'react-dom';ReactDOM.render( &lt;React.StrictMode&gt; &lt;BrowserRouter&gt; &lt;App /&gt; &lt;/BrowserRouter&gt; &lt;/React.StrictMode&gt;, document.getElementById('root')); index.ts에서 react-router-dom패키지의 BrowserRouter를 이용하여 App component를 감쌉니다. BrowserRouter를 이용하여 라우트 기능을 사용하기 때문에 추가하는 것 입니다. 1234567891011121314import &#123;Link&#125; from 'react-router-dom'import React from 'react';const App = () =&gt; &#123; return ( &lt;div&gt; &lt;button&gt;&lt;Link to='/'&gt;home&lt;/Link&gt;&lt;/button&gt; &lt;button&gt;&lt;Link to='/about'&gt;about&lt;/Link&gt;&lt;/button&gt; &lt;button&gt;&lt;Link to='/admin'&gt;admin&lt;/Link&gt;&lt;/button&gt; &lt;/div&gt; );&#125;;export default App; App.ts에서 위 코드와 같이 버튼으로 react-router-dom패키지의 Link함수를 이용합니다. &lt;Link to=&#39;/link&#39;&gt;여기에서 to 다음의 경로가 http://localhost:3000/link과 같이 도메인의 다음 경로가 됩니다.Link를 이용하여 간단하게 버튼을 만들어 보았는데 위처럼 링크는 변경이 됩니다. 하지만 이동된 페이지를 보여주려면 Route기능을 사용하면 됩니다.","categories":[{"name":"frontend","slug":"frontend","permalink":"https://swtpumpkin.github.io/categories/frontend/"},{"name":"react","slug":"frontend/react","permalink":"https://swtpumpkin.github.io/categories/frontend/react/"}],"tags":[{"name":"create-react-app","slug":"create-react-app","permalink":"https://swtpumpkin.github.io/tags/create-react-app/"},{"name":"package","slug":"package","permalink":"https://swtpumpkin.github.io/tags/package/"},{"name":"react-router","slug":"react-router","permalink":"https://swtpumpkin.github.io/tags/react-router/"},{"name":"link","slug":"link","permalink":"https://swtpumpkin.github.io/tags/link/"},{"name":"react-router-dom","slug":"react-router-dom","permalink":"https://swtpumpkin.github.io/tags/react-router-dom/"}]},{"title":"Template Literal","slug":"javascript/templateLiteral","date":"2020-06-23T23:00:00.000Z","updated":"2020-06-24T03:20:29.159Z","comments":true,"path":"javascript/templateLiteral/","link":"","permalink":"https://swtpumpkin.github.io/javascript/templateLiteral/","excerpt":"","text":"Template LiteralTemplate Literal이란 ‘(따음표), “(쌍따음표) 대신 `(백틱)을 이용하여 새로운 문자열 표기법이 추가되었습니다. 문자열 안에서 따음표와 쌍따음표를 사용하려면 \\ (backslash)를 이용했어야 했는데 Template Literal 내에선 \\ (backslash)가 필요없어졌습니다. 문법1const gretting = `Hello`; 일반 문자열처럼 `(백틱)을 이용하여 문자열을 표현 할 수 있습니다. 123const name = 'Kim';const gretting = `Hello`;console.log(`$&#123;gretting&#125;, $&#123;name&#125;!`); // Hello, Kim! 백틱 안 문자열에서 ${}이용하여 변수를 사용 할 수 있습니다. 123const thisYear = 2020;const birthYear = 1990;console.log(`I am $&#123;thisYear - birthYear&#125; years old.`); // I am 30 years old. ${}안에서 변수를 계산 할 수 있습니다. 123456789101112const name = \"Kim\"const thisYear = 2020;const birthYear = 1990;const job = 'developer';console.log(`I'm $&#123;name&#125;.I'm $&#123;thisYear - birthYear&#125; years old.My job is '$&#123;job&#125;'.`);/*I'm Kim.I'm 30 years old.My job is 'developer'.*/ 위 코드와 같이 개행을 할 수 있습니다.","categories":[{"name":"javascript","slug":"javascript","permalink":"https://swtpumpkin.github.io/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://swtpumpkin.github.io/tags/javascript/"},{"name":"template literal","slug":"template-literal","permalink":"https://swtpumpkin.github.io/tags/template-literal/"},{"name":"backtick","slug":"backtick","permalink":"https://swtpumpkin.github.io/tags/backtick/"}]},{"title":"7 Useful Array Methods","slug":"javascript/7UsefulArrayMethods","date":"2020-06-22T23:00:00.000Z","updated":"2020-06-23T07:45:01.516Z","comments":true,"path":"javascript/7UsefulArrayMethods/","link":"","permalink":"https://swtpumpkin.github.io/javascript/7UsefulArrayMethods/","excerpt":"","text":"Array method유용한 배열의 7가지 메소드에 대해 설명드리겠습니다. every배열의 every method는 배열의 모든 원소를 반복하여 하나라도 조건이 맞지 않는다면 즉시 반복을 멈추고 false를 반환합니다. 모든 조건에 맞아야만 true를 반환합니다. 1234const randomNums = [2, 4, 5, 6, 8, 10];randomNums.every(num =&gt; num % 2 === 0); // falseconst evenNums = [2, 4, 6, 8, 10];evenNums.every(num =&gt; num % 2 === 0); // true 위 코드처럼 홀수인지 체크하는 함수를 every method내에서 사용한다면 randomNums 배열은 중간에 홀수인 숫자가 포함되어있기 때문에 3번의 반복 후 바로 false를 반환하고 반복이 종료됩니다. 하지만 evenNums배열은 모든 요소가 짝수로 이루어져있기 때문에 끝까지 반복 후 true를 반환합니다. filter배열의 filter method는 배열의 모든 요소를 반복하면서 조건에 맞는 요소는 남기고 조건에 맞지 않는 요소는 없애 배열을 반환합니다. 12const orderNums = [1, 2, 3, 4, 5, 6, 7, 8];const evenNums = orderNums.filter(num =&gt; num % 2 === 0); // [ 2, 4, 6, 8 ] 위 코드처럼 짝수만으로 이루어진 배열을 만드려면 짝수인지 체크 후 새로운 변수에 담으면 evenNums과 같이 짝수 배열을 반환합니다. find배열의 find method는 배열의 요소를 반복하면서 조건에 맞는 첫번째 요소의 값만 반환합니다. 123const randomNums = [2, 9, 20, 40, 27];randomNums.find(num =&gt; num &gt; 20); // 40randomNums.find(num =&gt; num &gt; 50); // undefined 위 코드를 보면 randomNums배열에서 20보다 큰 수를 순서대로 반복하며 체크 후 조건에 맞는 40을 반환합니다. 40이 20보다 큰 첫번째 요소이기 때문에 40을 반환하고 반복은 바로 종료됩니다. 만약 배열의 모든 요소가 조건에 맞지 않는다면 undefined를 반환합니다. findIndex배열의 findIndex method는 배열의 요소를 반복하면서 조건에 만족하는 첫번째 요소의 index를 즉시 반환 후 반복은 종료됩니다. 모든 배열의 요소가 조건에 만족하지 않는다면 -1을 반환합니다. 123const randomNums = [2, 9, 20, 40, 27];randomNums.findIndex(num =&gt; num === 20); // 2randomNums.findIndex(num =&gt; num === 5); // -1 위 코드를 보면 20과 같은 수는 2번째 index에 존재하여 2를 반환하지만 5와 같은수는 존재하지 않기때문에 -1을 반환합니다. forEach배열의 forEach method는 배열의 모든 요소를 반복합니다. 모든 요소를 반복하지만 아무것도 반환하지 않기때문에 단순 반복용으로 사용합니다. 12const greetings = [\"안녕하세요.\", \"Good morning.\", \"Guten Morgen\", \"おはようございます\", \"早上好\"];greetings.forEach(g =&gt; console.log(g)); forEach는 배열 내 모든 요소를 반복하지만 undefined를 반환합니다. 만약 모든 배열을 순회해야 하지만 배열을 변경해야하지 않는다면 forEach 함수를 사용하면 좋습니다. map배열의 map method는 배열의 모든 각각의 요소에 대해 호출한 결과 값을 배열로 반환합니다. 1234567const peoples = [ &#123;name: \"Kim\", age: 25&#125;, &#123;name: \"Lee\", age: 31&#125;, &#123;name: \"Park\", age: 23&#125;, &#123;name: \"Choi\", age: 30&#125;,];const ages = peoples.map(p =&gt; p.age); 위 코드와 같이 age만 배열에 추가 할 수 있습니다. some배열의 some method는 배열의 요소 중 주어진 조건에 하나라도 맞으면 반복이 종료되고 true를 반환합니다. 모든 배열의 요소들이 조건에 충족하지 않는다면 false를 반환합니다. 12345678const peoples = [ &#123;name: \"Kim\", age: 25&#125;, &#123;name: \"Lee\", age: 31&#125;, &#123;name: \"Park\", age: 23&#125;, &#123;name: \"Choi\", age: 30&#125;,];peoples.some(p =&gt; p.age &gt;= 30) // truepeoples.some(p =&gt; p.age &gt;= 35) // false 위 코드에서 사람들의 나이가 30이상인 사람은 1번째 인덱스에 존재하여 반복이 종료되고 true를 반환하지만 35이상인 사람은 존재하지 않기때문에 모든 배열을 반복한 후 false를 반환합니다.","categories":[{"name":"javascript","slug":"javascript","permalink":"https://swtpumpkin.github.io/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://swtpumpkin.github.io/tags/javascript/"},{"name":"array","slug":"array","permalink":"https://swtpumpkin.github.io/tags/array/"},{"name":"method","slug":"method","permalink":"https://swtpumpkin.github.io/tags/method/"},{"name":"useful","slug":"useful","permalink":"https://swtpumpkin.github.io/tags/useful/"},{"name":"every","slug":"every","permalink":"https://swtpumpkin.github.io/tags/every/"},{"name":"filter","slug":"filter","permalink":"https://swtpumpkin.github.io/tags/filter/"},{"name":"find","slug":"find","permalink":"https://swtpumpkin.github.io/tags/find/"},{"name":"findindex","slug":"findindex","permalink":"https://swtpumpkin.github.io/tags/findindex/"},{"name":"foreach","slug":"foreach","permalink":"https://swtpumpkin.github.io/tags/foreach/"},{"name":"map","slug":"map","permalink":"https://swtpumpkin.github.io/tags/map/"},{"name":"some","slug":"some","permalink":"https://swtpumpkin.github.io/tags/some/"}]},{"title":"Nullish Coalescing Operator (??)","slug":"javascript/nullishCoalescingOperator","date":"2020-06-22T00:00:00.000Z","updated":"2020-06-23T04:44:04.268Z","comments":true,"path":"javascript/nullishCoalescingOperator/","link":"","permalink":"https://swtpumpkin.github.io/javascript/nullishCoalescingOperator/","excerpt":"","text":"Nullish coalescing Operatorjavascript에서 Nullish coalescing Operator를 사용 가능합니다. es2020에 Optional Chaining과 함께 추가되었습니다. typescript 3.7버전에서 이미 추가 된 기능이지만 es2020부터 javascript에서도 사용 가능합니다. Nullish coalescing Operator는 ??라는 연산자 앞에 있는 피연산자 값이 null이나 undefined일 때 연산자 뒤에 있는 값을 반환합니다. 사용법은 ||와 유사하지만 부정의 의미를 갖는 값 중 null과 undefined만 체크한다고 보시면 될 것 같습니다. Usage123456789const a = null ?? \"hello\";const b = '' ?? \"hello\";const c = false ?? \"hello\";const d = 0 ?? \"hello\";const e = undefined ?? \"hello\";const f = &#123;&#125; ?? \"hello\";const g = &#123;&#125;.greeting ?? \"hello\";const h = [] ?? \"hello\";const i = [][1] ?? \"hello\"; 위 코드에서 hello가 되는 변수는 어떤 것일까요? 123456789console.log(a); // 'hello'console.log(b); // ''console.log(c); // falseconsole.log(d); // 0console.log(e); // 'hello'console.log(f); // &#123;&#125;console.log(g); // 'hello'console.log(h); // []console.log(i); // 'hello' 위와 같이 a, e, g, i만 hello가 출력됩니다. a는 ?? 연산자의 앞의 값이 null이기 때문에 연산자 뒤의 hello가 출력됩니다. e, g, i는 undefined이기 때문에 마찬가지로 hello가 출력됩니다. ||연산자는 연산자의 앞 값이 부정적인 값이면 뒤 값이 출력됩니다. 하지만 Nullish coalescing Operator는 오로지 null 또는 undefined만 비교합니다. 123456789const nco = function(pre, post) &#123; if(pre === null || pre === undefined) &#123; return post &#125; else &#123; return pre; &#125;&#125;;console.log(nco(null, 'hello')); // 'hello;console.log(nco(&#123;&#125;, 'hello')); // &#123;&#125; 위 함수처럼 pre의 값을 null 또는 undefined인지 비교하고 맞으면 post 값을 반환하고 아니면 pre 값을 반환한다고 생각하시면 될 것 같습니다.","categories":[{"name":"javascript","slug":"javascript","permalink":"https://swtpumpkin.github.io/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://swtpumpkin.github.io/tags/javascript/"},{"name":"undefined","slug":"undefined","permalink":"https://swtpumpkin.github.io/tags/undefined/"},{"name":"Nullish coalescing","slug":"Nullish-coalescing","permalink":"https://swtpumpkin.github.io/tags/Nullish-coalescing/"}]},{"title":"Remove Duplicate In Array","slug":"javascript/removeDuplicateInArray","date":"2020-06-21T23:00:00.000Z","updated":"2020-06-22T01:50:09.121Z","comments":true,"path":"javascript/removeDuplicateInArray/","link":"","permalink":"https://swtpumpkin.github.io/javascript/removeDuplicateInArray/","excerpt":"","text":"Remove Duplicate In Arrayjavascript es6에서 set를 이용하여 간단하게 중복을 제거 할 수 있습니다. Usage1const balls = [\"⚽\", \"🏀\", \"🏈\", \"🏈\", \"⚾\", \"⚾\", \"🏈\", \"🎾\", \"⚽\"]; balls라는 배열은 럭비공, 야구공, 축구공이 중복으로 들어있습니다. 123const balls = [\"⚽\", \"🏀\", \"🏈\", \"🏈\", \"⚾\", \"⚾\", \"🏈\", \"🎾\", \"⚽\"];const uniqueBall = Array.from(new Set(balls));console.log(uniqueBall); // [ '⚽', '🏀', '🏈', '⚾', '🎾' ]; new Set()을 이용하여 중복이 제거된 객체로 만들고 이를 Array.from을 이용하여 배열로 변환하여 unique한 배열을 만듭니다. 123const balls = [\"⚽\", \"🏀\", \"🏈\", \"🏈\", \"⚾\", \"⚾\", \"🏈\", \"🎾\", \"⚽\"];const uniqueBall = [...new Set(balls)];console.log(uniqueBall); // [ '⚽', '🏀', '🏈', '⚾', '🎾' ]; spread operator를 이용해서 객체를 배열로 변환 할 수 있기때문에 spread operator를 사용해도 됩니다.","categories":[{"name":"javascript","slug":"javascript","permalink":"https://swtpumpkin.github.io/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://swtpumpkin.github.io/tags/javascript/"},{"name":"array","slug":"array","permalink":"https://swtpumpkin.github.io/tags/array/"},{"name":"duplicate","slug":"duplicate","permalink":"https://swtpumpkin.github.io/tags/duplicate/"},{"name":"배열 중복 제거","slug":"배열-중복-제거","permalink":"https://swtpumpkin.github.io/tags/%EB%B0%B0%EC%97%B4-%EC%A4%91%EB%B3%B5-%EC%A0%9C%EA%B1%B0/"}]},{"title":"Clone An Array","slug":"javascript/cloneAnArray","date":"2020-06-18T23:00:00.000Z","updated":"2020-06-19T04:17:54.702Z","comments":true,"path":"javascript/cloneAnArray/","link":"","permalink":"https://swtpumpkin.github.io/javascript/cloneAnArray/","excerpt":"","text":"Clone An Array배열을 복사하는 방법은 여러가지가 있습니다. 배열은 javascript에서 reference value이기 때문에 배열을 복사 할 때 잘 생각하고 복사를 해야합니다. =를 사용해서 값을 복사하면 안되는 이유!12345const animals = [\"🐶\", \"🐱\", \"🐵\", \"🐯\", \"🐷\"];const copiedAnimals = animals;animals.push(\"🐨\");console.log(animals); // [\"🐶\", \"🐱\", \"🐵\", \"🐯\", \"🐷\", \"🐨\"]console.log(copiedAnimals); // [\"🐶\", \"🐱\", \"🐵\", \"🐯\", \"🐷\", \"🐨\"] 배열은 javascript에서 reference value입니다. 따라서 원래의 값에 다른 요소를 추가하거나 제거하게 되면 복사된 값도 변하게 됩니다. 이전 값을 참조하지 않게 복사를 하는 방법123456789const animals = [\"🐶\", \"🐱\", \"🐵\", \"🐯\", \"🐷\"];const mapAnimals = animals.map(a =&gt; a);const sliceAnimals = animals.slice();const jsonAnimals = JSON.parse(JSON.stringify(animals));animals.push(\"🐨\");console.log(animals); // [\"🐶\", \"🐱\", \"🐵\", \"🐯\", \"🐷\", \"🐨\"]console.log(mapAnimals); // [\"🐶\", \"🐱\", \"🐵\", \"🐯\", \"🐷\"];console.log(sliceAnimals); // [\"🐶\", \"🐱\", \"🐵\", \"🐯\", \"🐷\"];console.log(jsonAnimals); // [\"🐶\", \"🐱\", \"🐵\", \"🐯\", \"🐷\"]; es5에선 map 또는 slice를 이용하여 배열을 복사 할 수 있었습니다. JSON.stringify와 JSON.parse 두 기능을 이용하여 복사 할 수 있습니다. 이렇게 복사를 하면 새로운 배열은 이전의 메모리를 참조하지 않습니다. 따라서 복사전 값을 변경하더라도 나머지 값에 영향을 주지 않습니다. es6의 spread operator123456const animals = [\"🐶\", \"🐱\", \"🐵\"];const emotion = [\"😀\", \"😅\", \"😎\"];const sumArray = [...animals, ...emotion];console.log(animals); // [\"🐶\", \"🐱\", \"🐵\"];console.log(emotion); // [\"😀\", \"😅\", \"😎\"];console.log(sumArray); // [\"🐶\", \"🐱\", \"🐵\", \"😀\", \"😅\", \"😎\"]; spread연산자를 사용해서 값을 복사 할 수 있습니다. 이 또한 이전의 메모리를 참조하지 않는 새로운 배열을 생성합니다. 추가로 배열의 복사 방법1234const animals = [\"🐶\", \"🐱\", \"🐵\", \"🐯\", \"🐷\"];const newArr = Array.from(animals);console.log(animals); // [\"🐶\", \"🐱\", \"🐵\", \"🐯\", \"🐷\"];console.log(newArr); // [\"🐶\", \"🐱\", \"🐵\", \"🐯\", \"🐷\"]; Array.from을 사용하면 메모리를 참조하지 않는 배열을 복사 할 수 있습니다.","categories":[{"name":"javascript","slug":"javascript","permalink":"https://swtpumpkin.github.io/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://swtpumpkin.github.io/tags/javascript/"},{"name":"clone array","slug":"clone-array","permalink":"https://swtpumpkin.github.io/tags/clone-array/"},{"name":"배열 복사","slug":"배열-복사","permalink":"https://swtpumpkin.github.io/tags/%EB%B0%B0%EC%97%B4-%EB%B3%B5%EC%82%AC/"}]},{"title":"Destructuring Assignment","slug":"javascript/destructuringAssignment","date":"2020-06-17T23:00:00.000Z","updated":"2020-06-18T08:22:22.614Z","comments":true,"path":"javascript/destructuringAssignment/","link":"","permalink":"https://swtpumpkin.github.io/javascript/destructuringAssignment/","excerpt":"","text":"Destructuring Assignment?Destructuring Assignment이란 구조분해할당이라고 합니다. 구조분해할당은 배열(array)또는 객체(object)의 개별 값을 변수로 저장하는 방법입니다. Array Destructuring12345678910// fruit listconst fruit = [\"apple\", \"peach\", \"melon\", \"kiwi\"];// each elementconst first = fruit[0];const second = fruit[1];const third = fruit[2];console.log(first); // \"apple\"console.log(second); // \"peach\"console.log(third); // \"melon\" 구조분해할당을 사용하지않고 배열의 각각 요소들을 변수로 사용하려면 하나씩 할당해줘야합니다. 기본 할당12345678// fruit listconst fruit = [\"apple\", \"peach\", \"melon\", \"kiwi\"];// each elementconst [first, second, third] = fruit;console.log(first); // \"apple\"console.log(second); // \"peach\"console.log(third); // \"melon\" 구조분해 할당으로 각 요소를 변수에 저장하면 한줄로 줄일 수 있습니다. 일부 반환 값 무시1234567// fruit listconst fruit = [\"apple\", \"peach\", \"melon\", \"kiwi\"];// each elementconst [first, ,third] = fruit;console.log(first); // \"apple\"console.log(third); // \"melon\" 또한 두번째 요소를 사용하지 않고 첫번째와 마지막 요소들만 변수로 저장하려면 가운데 요소에 변수를 할당하지 않고 사용하면 됩니다. 변수에 나머지를 할당1234567// fruit listconst fruit = [\"apple\", \"peach\", \"melon\", \"kiwi\"];// each elementconst [first, ,...etc] = fruit;console.log(first); // \"apple\"console.log(etc); // [\"melon\", \"kiwi\"] 변수로 할당한 나머지 또한 변수로 할당하여 배열로 저장 할 수 있습니다. 변수 값 변환12345let male = \"si-hyen\";let female = \"seo-won\";[male, female] = [female, male];console.log(male); // \"seo-won\"console.log(female); // \"si-hyen\" 변수로 할당한 값을 구조분해할당으로 변환 할 수 있습니다. 함수가 반환한 배열 할당1234567function animals() &#123; return [\"cat\", \"dog\", \"horse\"]&#125;;const [cat, ...anotherAnimals] = animals();console.log(cat) // \"cat\"console.log(anotherAnimals) // [\"dog\", \"horse\"] 함수가 배열을 반환한다면 그 배열의 값을 구조분해할당 할 수 있습니다. Object Destructuring기본 할당12345678910const human = &#123; name: \"kim\", age: 25, gender: \"male\",&#125;;const &#123;name, age, gender&#125; = human;console.log(name); // \"kim\"console.log(age); // 25console.log(gender); // \"male\" 객체의 key값을 변수로 사용하여 구조분해할당을 할 수 있습니다. 새로운 변수로 할당123456const car = &#123; name: \"bus\", color: \"blue\",&#125;;const &#123;name: type&#125; = car;console.log(type); // \"bus\" 객체의 value를 다른 변수를 이용하여 할당 할 수 있습니다. car객체는 name의 key를 갖고있는데 이를 type이란 변수를 선언하여 할당 할 수 있습니다. 객체의 속성 이름과 구조분해123const keyName = \"name\";const &#123;[keyName]: type&#125; = &#123;name: \"bus\", color: \"blue\"&#125;;console.log(type); // \"bus\" 객체의 key값으로 객체리터럴과 비슷하게 구조분해도 가능합니다. 변수에 나머지를 할당1234const &#123;name, age, ...rest&#125; = &#123;name: \"kim\", height: 180, region: \"seoul\", age: 21&#125;;console.log(name); // \"kim\"console.log(age); // 21console.log(rest); // &#123; height: 180, region: \"seoul\" &#125; 배열과 비슷하게 할당하지 않은 나머지 값을 객체로 저장가능합니다. 추가로12345678910const human = &#123; name: \"kim\", age: 25, gender: \"male\",&#125;;const &#123;age, gender, name&#125; = human;console.log(name); // \"kim\"console.log(age); // 25console.log(gender); // \"male\" 객체는 순서와 상관없기 때문에 할당할 변수를 객체의 순서대로 할당하지 않아도 됩니다.","categories":[{"name":"javascript","slug":"javascript","permalink":"https://swtpumpkin.github.io/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://swtpumpkin.github.io/tags/javascript/"},{"name":"Destructuring Assignment","slug":"Destructuring-Assignment","permalink":"https://swtpumpkin.github.io/tags/Destructuring-Assignment/"},{"name":"구조분해할당","slug":"구조분해할당","permalink":"https://swtpumpkin.github.io/tags/%EA%B5%AC%EC%A1%B0%EB%B6%84%ED%95%B4%ED%95%A0%EB%8B%B9/"}]},{"title":"Double Exclamation Operator (!!)","slug":"javascript/doubleExclamationOperator","date":"2020-06-14T23:00:00.000Z","updated":"2020-06-15T00:44:45.934Z","comments":true,"path":"javascript/doubleExclamationOperator/","link":"","permalink":"https://swtpumpkin.github.io/javascript/doubleExclamationOperator/","excerpt":"","text":"Double Exclamation Operator느낌표두개연산자 또는 Double NOT operator라고 불리우는 이 연산자는 오른쪽에 있는 값을 boolean 즉 논리적 값으로 변환해줍니다. 모든 javascript의 값에는 연관된 boolean true 또는 false 값이 있습니다. 따라서 값을 논리값으로 변환하려면 !!를 사용하여 변환 할 수 있습니다. Double Exclamation Usage일반적으로 javascript에서 false로 간주되는 값이 있습니다. null, NaN, undefined 등이 있는데 이 값에 !!를 사용하게 되면 false로 반환합니다. 123console.log(!!null); // falseconsole.log(!!NaN); // falseconsole.log(!!undefined); // false javascript에서 숫자 0은 false를 의미합니다. 0 이외의 숫자는 true입니다. 1234console.log(!!0); // falseconsole.log(!!-0); // falseconsole.log(!!-615); // trueconsole.log(!!2020); // true javascript에서 빈 문자열은 false를 의미합니다. 따라서 &quot;&quot;는 false입니다. 123console.log(!!\"\"); // falseconsole.log(!!\" \"); // trueconsole.log(!!\"string\"); // true javascript에서 객체 또는 배열은 true입니다. 따라서 빈배열을 확인하려면 .length를 이용하여 확인해야합니다. 하지만 빈객체는 다른 방법으로 확인해야합니다. 자세한 확인방법은 여기를 참고해주시기 바랍니다. 123console.log(!!&#123;&#125;); // trueconsole.log(!![]); // trueconsole.log(!![].length); // false 이거만 기억하면 될 것 같다.!!는 boolean으로 바꿔준다!","categories":[{"name":"javascript","slug":"javascript","permalink":"https://swtpumpkin.github.io/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://swtpumpkin.github.io/tags/javascript/"},{"name":"느낌표두개","slug":"느낌표두개","permalink":"https://swtpumpkin.github.io/tags/%EB%8A%90%EB%82%8C%ED%91%9C%EB%91%90%EA%B0%9C/"},{"name":"not operator","slug":"not-operator","permalink":"https://swtpumpkin.github.io/tags/not-operator/"},{"name":"double exclamation","slug":"double-exclamation","permalink":"https://swtpumpkin.github.io/tags/double-exclamation/"}]},{"title":"Javascript Data Structures (Primitive Values)","slug":"javascript/dataStructuresPrimitive","date":"2020-06-11T23:00:00.000Z","updated":"2020-06-12T06:44:29.839Z","comments":true,"path":"javascript/dataStructuresPrimitive/","link":"","permalink":"https://swtpumpkin.github.io/javascript/dataStructuresPrimitive/","excerpt":"","text":"Primitive Values단어 뜻 그대로 원시값입니다. javascript는 Object를 제외한 타입은 모두 변경이 불가능한 값(immutable value)입니다. 원시값은 변수에 할당 할 때 메모리에 고정된 값으로 저장합니다. Kinds of Primitive Values원시값의 종류는 Boolean, Number, String, Null, Undefined, Symbol로 6가지 입니다. BooleanBoolean은 true, false 두가지 값을 가질 수 있습니다. 12const positive = true;const negative = false; Numberjavascript는 정수만을 표현하는 특별한 자료형은 없습니다. Number타입은 크게 세가지 의미있는 상징적인 값들도 표현 할 수 있습니다. 이 값들은 +/-Infinity와 NaN입니다. 123const poZero = 0;const neZero = -0;poZero === neZero // true Number타입에는 두 가지 방식으로 표현 할 수 있는 유일한 값이 있는데 0입니다. 따라서 0과 -0을 비교하게 되면 true를 반환합니다. 12const max = Number.MAX_VALUE;const min = Number.MIN_VALUE; +/-Infinity와 비교하여 크거나 작은지 확인 할 수 있는 상수도 존재합니다. javascript에서 표현 할 수 있는 가장 큰 값과 가장 작은 값을 상수로 저장하여 +/-Infinity를 비교 할 수 있습니다. Stringjavascript의 문자열은 값을 변경 할 수 없습니다. 한 번 문자열이 생성되면 그 문자열을 수정 할 수 없다는 것을 의미합니다. 하지만 원래 문자열에서 일부를 수정하여 수정된 다른 문자열 생성은 가능합니다. 1234567const initString = 'string';console.log(initString); // stringconst addString = initString.concat('Add');console.log(addString); // stringAddconst ingString = initString.substr(3,3);console.log(ingString); // ingconsole.log(initString); // string 위와 같이 Add 문자열을 붙이고 ing 문자열만 따로 떼네어도 원본 initString의 값엔 영향을 주지 않습니다. NullNull의 타입은 딱 한가지 null을 가질 수 있습니다. 1const nullValue = null; Undefined값을 할당하지 않은 변수는 undefined 값을 가집니다. 12let unknown;console.log(unknown); // undefined SymbolSymbol은 유일하고 변경 불가능한 값입니다. es6에서 추가되었습니다. 유일한 객체의 프로퍼티 키를 만들기 위해 주로 사용됩니다. 12345const symbolKey = Symbol('key');console.log(typeof symbolKey); // symbolconst object= &#123;&#125;;object[symbolKey] = 'value';console.log(object[symbolKey]); // value","categories":[{"name":"javascript","slug":"javascript","permalink":"https://swtpumpkin.github.io/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://swtpumpkin.github.io/tags/javascript/"},{"name":"data","slug":"data","permalink":"https://swtpumpkin.github.io/tags/data/"},{"name":"structure","slug":"structure","permalink":"https://swtpumpkin.github.io/tags/structure/"},{"name":"primitive","slug":"primitive","permalink":"https://swtpumpkin.github.io/tags/primitive/"}]},{"title":"deno와 node.js 비교","slug":"backend/deno/denoVsNode","date":"2020-05-15T23:00:00.000Z","updated":"2020-05-18T01:16:54.981Z","comments":true,"path":"backend/deno/denoVsNode/","link":"","permalink":"https://swtpumpkin.github.io/backend/deno/denoVsNode/","excerpt":"","text":"deno로 만드는 서버deno가 2020년 5월 14일 v1.0.0이 릴리즈 되었습니다. deno와 node를 비교하며 웹페이지에 Hello World를 띄워보도록 하겠습니다. node!우선 node를 이용하여 Hello World를 띄우도록 하겠습니다. 1mkdir node &amp;&amp; cd node &amp;&amp; npm init -y node폴더를 만들고 node플더로 이동하여 npm init으로 package.json파일을 생성합니다. 1npm install express npm으로 express를 설치합니다. 1touch index.js index.js 파일을 생성합니다. 12345678const express = require('express');const port = 8000;const app = express();app.get('*', (req, res) =&gt; res.send('Hello World'))app.listen(port, () =&gt; console.log(`http://localhost:$&#123;port&#125;`)) 위 코드를 index.js에 작성합니다. npm으로 설치된 express를 app으로 실행하고 8000번 port를 이용하여 앱을 실행합니다. 1node index.js 터미널에서 node를 이용하여 index.js를 실행합니다.http://localhost:8000로 접속하면 Hello World를 확인 할 수 있습니다. deno!deno를 이용하여 Hello World를 띄우도록 하겠습니다. 1mkdir deno &amp;&amp; cd deno &amp;&amp; touch index.ts deno 폴더를 생성하고 deno 폴더로 이동하여 index.ts 파일을 생성합니다. 12345678910import &#123; serve &#125; from 'https://deno.land/std/http/server.ts';const port = 8000;const s = serve(&#123; port &#125;);console.log(`http://localhost:$&#123;port&#125;`);for await (const req of s) &#123; req.respond(&#123; body: 'Hello World' &#125;);&#125; 위 코드를 index.ts에 작성합니다. https://deno.land/std/http/server.ts url을 이용하여 코드를 불러와 serve 함수를 받고 8000 포트를 사용하고, 응답을 body에 Hello World로 보냅니다. 1deno index.ts deno로 index.ts를 실행하면 error: Found argument &#39;index.ts&#39; which wasn&#39;t expected, or isn&#39;t valid in this context 에러가 발생합니다. deno는 node와는 다르게 옵션을 추가하여 실행해야 합니다. 1deno run --allow-net --allow-read index.ts deno는 docker와 비슷하게 실행해야하는데 --allow-net 옵션으로 네트워크 통신을 허용해야하고 --allow-read 옵션으로 index.ts 파일을 읽을 수 있도록 허용해야합니다.처음 deno로 파일을 실행하게되면 Compile file:///Users/username/Desktop/deno/index.ts와 같이 컴파일을 한 후 파일이 실행됩니다. 정리deno는 node와는 다르게 package.json 파일, node_modules 폴더 등이 필요없고 url을 통해 직접 코드를 불러 올 수 있습니다. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950deno -hdeno 1.0.0A secure JavaScript and TypeScript runtimeDocs: https:&#x2F;&#x2F;deno.land&#x2F;std&#x2F;manual.mdModules: https:&#x2F;&#x2F;deno.land&#x2F;std&#x2F; https:&#x2F;&#x2F;deno.land&#x2F;x&#x2F;Bugs: https:&#x2F;&#x2F;github.com&#x2F;denoland&#x2F;deno&#x2F;issuesTo start the REPL: denoTo execute a script: deno run https:&#x2F;&#x2F;deno.land&#x2F;std&#x2F;examples&#x2F;welcome.tsTo evaluate code in the shell: deno eval &quot;console.log(30933 + 404)&quot;USAGE: deno [OPTIONS] [SUBCOMMAND]OPTIONS: -h, --help Prints help information -L, --log-level &lt;log-level&gt; Set log level [possible values: debug, info] -q, --quiet Suppress diagnostic output -V, --version Prints version informationSUBCOMMANDS: bundle Bundle module and dependencies into single file cache Cache the dependencies completions Generate shell completions doc Show documentation for a module eval Eval script fmt Format source files help Prints this message or the help of the given subcommand(s) info Show info about cache or info related to source file install Install script as an executable repl Read Eval Print Loop run Run a program given a filename or url to the module test Run tests types Print runtime TypeScript declarations upgrade Upgrade deno executable to given versionENVIRONMENT VARIABLES: DENO_DIR Set deno&#39;s base directory (defaults to $HOME&#x2F;.deno) DENO_INSTALL_ROOT Set deno install&#39;s output directory (defaults to $HOME&#x2F;.deno&#x2F;bin) NO_COLOR Set to disable color HTTP_PROXY Proxy address for HTTP requests (module downloads, fetch) HTTPS_PROXY Same but for HTTPS 2020년5월16일 현재 deno의 문서는 아직까지 부족 한 것 같습니다. Docs: https://deno.land/std/manual.md 의 문서 역시 아래와 같이 링크가 깨져있어 볼 수 없습니다.아직 v1.0.0이기 때문에 마이너 업데이트가 필요해 보입니다. 그래도 npm을 벗어난 개발이 매우 흥미롭습니다.","categories":[{"name":"backend","slug":"backend","permalink":"https://swtpumpkin.github.io/categories/backend/"},{"name":"deno","slug":"backend/deno","permalink":"https://swtpumpkin.github.io/categories/backend/deno/"}],"tags":[{"name":"node","slug":"node","permalink":"https://swtpumpkin.github.io/tags/node/"},{"name":"deno","slug":"deno","permalink":"https://swtpumpkin.github.io/tags/deno/"},{"name":"디노","slug":"디노","permalink":"https://swtpumpkin.github.io/tags/%EB%94%94%EB%85%B8/"},{"name":"experience","slug":"experience","permalink":"https://swtpumpkin.github.io/tags/experience/"},{"name":"디노 사용법","slug":"디노-사용법","permalink":"https://swtpumpkin.github.io/tags/%EB%94%94%EB%85%B8-%EC%82%AC%EC%9A%A9%EB%B2%95/"},{"name":"hello world","slug":"hello-world","permalink":"https://swtpumpkin.github.io/tags/hello-world/"}]},{"title":"deno macOS install","slug":"backend/deno/denoInstall","date":"2020-05-14T23:00:00.000Z","updated":"2020-05-15T04:47:38.543Z","comments":true,"path":"backend/deno/denoInstall/","link":"","permalink":"https://swtpumpkin.github.io/backend/deno/denoInstall/","excerpt":"","text":"denodeno는 Javascript와 Typescript를 사용하는 안전한 런타임 입니다.deno를 설치하기 전에 brew로 deno를 설치하는 과정이 있기 때문에 brew가 설치되어있지 않다면 여기로 이동해서 brew를 먼저 설치해주시기 바랍니다. Mac에서 deno를 설치하는 방법에 대해 설명해드리겠습니다. 설치방법1curl -fsSL https:&#x2F;&#x2F;deno.land&#x2F;x&#x2F;install&#x2F;install.sh | sh shell script을 이용하여 deno를 설치합니다. 1brew install deno brew를 이용하여 deno를 설치합니다. 1deno --version 위 명령어로 deno의 버전을 확인 할 수 있는데 zsh: command not found: deno 와 같이 출력이 된다면 설치가 잘 못 된 것 입니다. 1234$ deno --versiondeno 1.0.0v8 8.4.300typescript 3.9.2 위와 같이 deno버전, v8엔진 버전, typescript버전이 잘 출력된다면 설치가 잘 된 것 입니다.","categories":[{"name":"backend","slug":"backend","permalink":"https://swtpumpkin.github.io/categories/backend/"},{"name":"deno","slug":"backend/deno","permalink":"https://swtpumpkin.github.io/categories/backend/deno/"}],"tags":[{"name":"mac","slug":"mac","permalink":"https://swtpumpkin.github.io/tags/mac/"},{"name":"deno","slug":"deno","permalink":"https://swtpumpkin.github.io/tags/deno/"},{"name":"macOS","slug":"macOS","permalink":"https://swtpumpkin.github.io/tags/macOS/"},{"name":"install","slug":"install","permalink":"https://swtpumpkin.github.io/tags/install/"},{"name":"installation","slug":"installation","permalink":"https://swtpumpkin.github.io/tags/installation/"},{"name":"디노","slug":"디노","permalink":"https://swtpumpkin.github.io/tags/%EB%94%94%EB%85%B8/"},{"name":"설치","slug":"설치","permalink":"https://swtpumpkin.github.io/tags/%EC%84%A4%EC%B9%98/"}]},{"title":"AWS Ubuntu Docker-compose Install","slug":"backend/aws/awsUbuntuDockerComposeInstall","date":"2020-05-08T00:00:00.000Z","updated":"2020-05-08T00:53:49.651Z","comments":true,"path":"backend/aws/awsUbuntuDockerComposeInstall/","link":"","permalink":"https://swtpumpkin.github.io/backend/aws/awsUbuntuDockerComposeInstall/","excerpt":"","text":"Ubuntu Docker-compose 설치 방법12sudo curl -L &quot;https:&#x2F;&#x2F;github.com&#x2F;docker&#x2F;compose&#x2F;releases&#x2F;download&#x2F;1.25.5&#x2F;docker-compose-$(uname -s)-$(uname -m)&quot; -o &#x2F;usr&#x2F;local&#x2F;bin&#x2F;docker-compose \\&amp;&amp; sudo chmod +x &#x2F;usr&#x2F;local&#x2F;bin&#x2F;docker-compose 위 코드를 이용하여 docker-compose 1.25.5버전을 설치합니다. 1docker-compose --version docker-compose가 설치 완료되면 위 코드로 docker-compose의 버전을 확인 할 수 있습니다.","categories":[{"name":"backend","slug":"backend","permalink":"https://swtpumpkin.github.io/categories/backend/"},{"name":"AWS","slug":"backend/AWS","permalink":"https://swtpumpkin.github.io/categories/backend/AWS/"}],"tags":[{"name":"install","slug":"install","permalink":"https://swtpumpkin.github.io/tags/install/"},{"name":"aws","slug":"aws","permalink":"https://swtpumpkin.github.io/tags/aws/"},{"name":"ubuntu","slug":"ubuntu","permalink":"https://swtpumpkin.github.io/tags/ubuntu/"},{"name":"Docker-compose","slug":"Docker-compose","permalink":"https://swtpumpkin.github.io/tags/Docker-compose/"}]},{"title":"AWS Ubuntu Docker Install","slug":"backend/aws/awsUbuntuDockerInstall","date":"2020-05-07T23:00:00.000Z","updated":"2020-05-08T00:26:46.736Z","comments":true,"path":"backend/aws/awsUbuntuDockerInstall/","link":"","permalink":"https://swtpumpkin.github.io/backend/aws/awsUbuntuDockerInstall/","excerpt":"","text":"Ubuntu Docker 설치 방법12sudo apt-get update \\&amp;&amp; sudo apt install docker.io apt-get을 업데이트 후 docker.io를 설치해주면 됩니다. 1docker --version 위 명령어를 통해 docker 버전이 확인되면 ubuntu에 docker 설치가 완료된 것입니다. One more thing…docker를 sudo없이 사용하려면? 1sudo usermod -aG docker $USER 위 코드를 터미널에 입력하면 됩니다.","categories":[{"name":"backend","slug":"backend","permalink":"https://swtpumpkin.github.io/categories/backend/"},{"name":"AWS","slug":"backend/AWS","permalink":"https://swtpumpkin.github.io/categories/backend/AWS/"}],"tags":[{"name":"install","slug":"install","permalink":"https://swtpumpkin.github.io/tags/install/"},{"name":"aws","slug":"aws","permalink":"https://swtpumpkin.github.io/tags/aws/"},{"name":"ubuntu","slug":"ubuntu","permalink":"https://swtpumpkin.github.io/tags/ubuntu/"},{"name":"docker","slug":"docker","permalink":"https://swtpumpkin.github.io/tags/docker/"}]},{"title":"AWS Configure","slug":"backend/aws/awsConfigure","date":"2020-05-05T23:00:00.000Z","updated":"2020-05-06T07:54:05.648Z","comments":true,"path":"backend/aws/awsConfigure/","link":"","permalink":"https://swtpumpkin.github.io/backend/aws/awsConfigure/","excerpt":"","text":"AWS CLI configureAWS 명령줄 인터페이스(CLI)는 AWS 서비스를 관리하는 통합 도구입니다. 도구 하나만 다운로드하여 구성하면 여러 AWS 서비스를 명령줄에서 제어하고 스크립트를 통해 자동화할 수 있습니다. 따라서 AWS-CLI를 사용하기 위해선 설정이 필요합니다. 설정 방법aws configure를 하기 전에 IAM에서 AWS Access Key ID와 AWS Secret Access Key가 필요합니다. IAM에서 key와 secret를 발급받고 다음 설정을 따라하시면 됩니다. 1aws configure 처음 aws configure를 터미널에 치게 되면 아래와 같이 4개의 질문이 나오게 됩니다. 1234AWS Access Key ID [None]:AWS Secret Access Key [None]:Default region name [None]:Default output format [None]: 모든 질문은 기본 값이 None으로 되어있습니다. key와 secret을 순서대로 넣고 region name은 여기 코드를 입력하시면 됩니다. output format은 여기에서 Output Format의 형식 중 하나를 입력하시면 됩니다.","categories":[{"name":"backend","slug":"backend","permalink":"https://swtpumpkin.github.io/categories/backend/"},{"name":"AWS","slug":"backend/AWS","permalink":"https://swtpumpkin.github.io/categories/backend/AWS/"}],"tags":[{"name":"aws","slug":"aws","permalink":"https://swtpumpkin.github.io/tags/aws/"},{"name":"configure","slug":"configure","permalink":"https://swtpumpkin.github.io/tags/configure/"}]},{"title":"Docker로 mongoDB 사용하기","slug":"backend/docker/dockerMongo","date":"2020-03-26T00:00:00.000Z","updated":"2020-05-06T07:34:44.381Z","comments":true,"path":"backend/docker/dockerMongo/","link":"","permalink":"https://swtpumpkin.github.io/backend/docker/dockerMongo/","excerpt":"","text":"Docker를 이용하여 mongoDB 사용docker hub에서 mongo의 official image를 이용하여 mongoDB를 docker로 실행 할 수 있습니다. docker hub의 레포는 여기를 누르시면 볼 수 있습니다. 사용 방법1docker pull mongo 일단 docker hub에서 mongo를 풀당겨 이미지를 내려받습니다. 풀 당길때 mongo:tag와 같이 tag를 입력하여 버전을 선택 할 수 있고 tag를 지정하지 않으면 latest버전 이미지를 갖고옵니다. 1docker run --name mongo -p 17017:27017 -d mongo --name 옵션을 통해 docker의 이름을 mongo로 지정합니다.-p옵션을 통해 17017포트를 27017포트로 연결합니다.-d옵션을 통해 백그라운드로 docker를 실행합니다.포트를 17017로 지정 한 이유는 기존에 디비가 이미 로컬에 설치되어 있고 27017가 mongo의 기본포트이므로 docker로 실행되는 mongoDB는 로컬에서 도커로 접속 시 포트가 중복되어 17017로 지정하였습니다. 1docker run --name mongo -p 27017:27017 -d mongo 기존에 mongoDB가 설치되지 않았다면 위와 같이 포트를 27017로 지정해주시면 됩니다.--restart=always 옵션을 사용하면 컴퓨터를 재시작 하더라도 자동으로 실행시켜 줄 수 있습니다. 1docker run --name mongo -p 27017:27017 -d --restart&#x3D;always mongo 위와 같이 실행하게 되면 docker로 컴퓨터를 재시작 할 때마다 실행해주지 않아도 됩니다. 1docker ps 위 코드를 통해 docker 실행 목록을 볼 수 있습니다.위와 같이 mongo는 상태를 보면 알 수 있듯이 잘 실행되고 있습니다.ROBO 3T앱을 통해서 포트를 17017로 설정하고 연결 테스트를 실행해보면 연결이 성공되었다는 것을 볼 수 있습니다. docker를 이용하여 mongoDB를 설치해 봤는데 mongo뿐만 아니라 다른 DB도 docker를 통해 쉽게 설치가 가능합니다.","categories":[{"name":"backend","slug":"backend","permalink":"https://swtpumpkin.github.io/categories/backend/"},{"name":"docker","slug":"backend/docker","permalink":"https://swtpumpkin.github.io/categories/backend/docker/"}],"tags":[{"name":"mongo","slug":"mongo","permalink":"https://swtpumpkin.github.io/tags/mongo/"},{"name":"dockerHub","slug":"dockerHub","permalink":"https://swtpumpkin.github.io/tags/dockerHub/"},{"name":"mongoDB","slug":"mongoDB","permalink":"https://swtpumpkin.github.io/tags/mongoDB/"}]},{"title":"mac 따음표 대쉬 자동변환 해제","slug":"develop/macDashQuote","date":"2020-03-25T23:00:00.000Z","updated":"2020-05-06T07:34:44.382Z","comments":true,"path":"develop/macDashQuote/","link":"","permalink":"https://swtpumpkin.github.io/develop/macDashQuote/","excerpt":"","text":"개발하다보면 --를 —로 또는 &quot;&quot;를 “”로 맥에서 자동 변환해주어서 메모장에 복사해둔 코드가 다시 복사해서 쓰려면 에러가 발생하곤 했습니다. 맥 기능중에 스마트 인용 및 대시 사용이라는 기능이 켜져있는데 이 기능을 끄면 자동변환 되지 않아 에러를 방지 할 수 있습니다. 설정방법시스템 환경설정에서 키보드로 이동합니다.키보드의 텍스트탭에서 스마트 인용 및 대시 사용 체크를 해지하면 따음표나 대쉬가 자동 변환되는 것을 막을 수 있습니다.","categories":[{"name":"develop","slug":"develop","permalink":"https://swtpumpkin.github.io/categories/develop/"}],"tags":[{"name":"develop","slug":"develop","permalink":"https://swtpumpkin.github.io/tags/develop/"},{"name":"mac","slug":"mac","permalink":"https://swtpumpkin.github.io/tags/mac/"},{"name":"따음표","slug":"따음표","permalink":"https://swtpumpkin.github.io/tags/%EB%94%B0%EC%9D%8C%ED%91%9C/"},{"name":"대쉬","slug":"대쉬","permalink":"https://swtpumpkin.github.io/tags/%EB%8C%80%EC%89%AC/"},{"name":"dash","slug":"dash","permalink":"https://swtpumpkin.github.io/tags/dash/"},{"name":"quote","slug":"quote","permalink":"https://swtpumpkin.github.io/tags/quote/"}]},{"title":"github actions node.js test","slug":"git/githubActionTest","date":"2020-03-23T23:00:00.000Z","updated":"2024-03-28T06:11:48.015Z","comments":true,"path":"git/githubActionTest/","link":"","permalink":"https://swtpumpkin.github.io/git/githubActionTest/","excerpt":"","text":"github actions?GitHub Actions을 사용하면 workflow를 통해 build, test, deploy를 자동화 할 수 있습니다. 자세한 정보는 githubAction에서 확인 할 수 있습니다. github actions을 통한 node.js CI 사용방법exampleRepo를 통하여 코드를 볼 수 있습니다. 1234567|____node-docker-example| |____test.js| |____README.md| |____.gitignore| |____package-lock.json| |____package.json| |____app.js 레포의 구조는 위와 같이 생성되어있습니다. 12345678910const express = require(&quot;express&quot;);const app = express();const port = 8080;app.get(&quot;/&quot;, (req, res) =&gt; res.send(&quot;Hello World!&quot;));app.listen(port, () =&gt; console.log(`Example app listening on port $&#123;port&#125;!`));module.exports = app; app.js에는 &#39;/&#39;에서 get요청에 Hello World!텍스트를 리턴하도록 작성하였습니다. 12345678910111213const supertest = require(&quot;supertest&quot;);const expect = require(&quot;chai&quot;).expect;const app = require(&quot;./app&quot;);const agent = supertest.agent(app);describe(&quot;node docker test&quot;, () =&gt; &#123; it(&quot;get test&quot;, () =&gt; &#123; return agent .get(&quot;/&quot;) .expect(200) .then((res) =&gt; expect(res.text).to.be.equal(&quot;Hello World!&quot;)); &#125;);&#125;); test.js에선 루트로 요청했을 때 Hello World!텍스트가 잘 리턴하는지 체크하는 테스트코드를 작성하였습니다.github에서 테스트 할 레포로 이동하여 actions으로 이동합니다.New workflow를 선택하여 이동 후 node.js의 Set up this workflow를 선택합니다.위와 같이 node.js의 기본 workflow를 볼 수 있습니다. 123456789101112131415161718192021222324name: Nodejs example CIon: push: branches: [ master ]jobs: build: runs-on: ubuntu-latest strategy: matrix: node-version: [10.x, 12.x] steps: - uses: actions&#x2F;checkout@v2 - name: Use Node.js $&#123;&#123; matrix.node-version &#125;&#125; uses: actions&#x2F;setup-node@v1 with: node-version: $&#123;&#123; matrix.node-version &#125;&#125; - run: npm ci - run: npm test env: CI: true name은 위 사진과 같이 workflow의 이름을 설정하는 부분입니다.on은 이벤트의 변경사항을 캐치하는 부분입니다. 위와 같이 master브렌치의 push이벤트가 발생하면 다음 절차가 실행됩니다.jobs는 하나의 인스턴스에서 여러 step을 그룹시켜 실행합니다.runs-on은 어느 환경에서 실행 할지 지정합니다.steps는 순차적으로 명령을 실행합니다. 위 코드에선 node mode를 10.x버전과 12.x버전을 각각 실행합니다. 각 버전에서 npm package를 설치 후 테스트를 진행합니다.","categories":[{"name":"git","slug":"git","permalink":"https://swtpumpkin.github.io/categories/git/"}],"tags":[{"name":"git","slug":"git","permalink":"https://swtpumpkin.github.io/tags/git/"},{"name":"github","slug":"github","permalink":"https://swtpumpkin.github.io/tags/github/"},{"name":"actions","slug":"actions","permalink":"https://swtpumpkin.github.io/tags/actions/"},{"name":"CI","slug":"CI","permalink":"https://swtpumpkin.github.io/tags/CI/"}]},{"title":"brew tree","slug":"develop/brewTree","date":"2020-03-23T22:00:00.000Z","updated":"2020-05-06T07:34:44.382Z","comments":true,"path":"develop/brewTree/","link":"","permalink":"https://swtpumpkin.github.io/develop/brewTree/","excerpt":"","text":"tree?파일의 구조를 시각적으로 표현해주는 쉘 명령어입니다. 설치방법1brew install tree brew를 통해 tree를 설치합니다.tree를 설치하자마자 바로 실행하면 zsh: command not found: tree라고 에러가 발생합니다. 1alias tree&#x3D;&quot;find . -print | sed -e &#39;s;[^&#x2F;]*&#x2F;;|____;g;s;____|; |;g&#39;&quot; open ~/.zshrc을 통해 텍스트에디터로 .zshrc파일을 실행 후 위 코드를 추가하고 저장합니다.터미널을 재시작하면 tree명령어를 실행 할 수 있습니다.위와 같은 파일구조를 갖은 폴더에서 tree명령어를 실행하게되면,위와 같이 터미널에 자료구조를 시각적으로 표현해주어 쉽게 볼 수 있습니다.","categories":[{"name":"develop","slug":"develop","permalink":"https://swtpumpkin.github.io/categories/develop/"}],"tags":[{"name":"develop","slug":"develop","permalink":"https://swtpumpkin.github.io/tags/develop/"},{"name":"brew","slug":"brew","permalink":"https://swtpumpkin.github.io/tags/brew/"},{"name":"mac","slug":"mac","permalink":"https://swtpumpkin.github.io/tags/mac/"},{"name":"tree","slug":"tree","permalink":"https://swtpumpkin.github.io/tags/tree/"}]},{"title":"IIFE(Immediately Invoked Function Expression)? 즉시실행함수?","slug":"javascript/whatIsIIFE","date":"2020-02-27T15:00:00.000Z","updated":"2020-05-06T07:34:44.383Z","comments":true,"path":"javascript/whatIsIIFE/","link":"","permalink":"https://swtpumpkin.github.io/javascript/whatIsIIFE/","excerpt":"","text":"IIFE(Immediately Invoked Function Expression)? 즉시실행함수?즉시실햄함수란 정의 된 즉시 실행되는 javascript의 함수힙니다. 일반적으로 함수는 함수선언 또는 함수표현식을 이용하여 함수를 작성하고 함수를 사용하려면 함수를 호출해야합니다. 12345// 함수선언function plus(a,b) &#123; return a + b;&#125;console.log(plus(2,4)); // 6 12345// 함수표현식const plus = function(a,b) &#123; return a + b;&#125;console.log(plus(2,4)); // 6 그러나 IIFE(즉시실행함수)는 익명함수선언 후 함수가 괄호로 묶여있고 ()괄호로 바로 호출하여 컴파일러가 코드를 읽는 즉시 함수를 실행시킵니다. 123(function() &#123; alert(\"Hello Javascript\");&#125;)(); // Hello Javascript 위 코드를 사용하게 되면 컴파일러가 코드를 읽는 즉시 alert로 Hello Javascript가 출력됩니다. IIFE를 사용하는 이유!1234(function() &#123; var hello = \"Hello Javascript\";&#125;)();console.log(hello); // Uncaught ReferenceError: hello is not defined 즉시실행함수를 사용하게 되면 함수내에서 정의된 변수는 함수 외부에서 접근이 불가합니다. 12345678var plus = (function () &#123; var first = 1; var second = 2; return first + second; &#125;)();console.log(plus); // 3console.log(first); // Uncaught ReferenceError: first is not definedconsole.log(second); // Uncaught ReferenceError: second is not defined 즉시실행함수를 변수에 할당하면 즉시실행함수는 저장되지 않고, 함수가 실행된 결과만 저장됩니다. 이 역시 함수 내부에서 선언된 변수에는 접근이 불가합니다. 추가로 익명함수를 사용하여 실수로 함수 호출하는 실수를 막을 수 있습니다.","categories":[{"name":"javascript","slug":"javascript","permalink":"https://swtpumpkin.github.io/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://swtpumpkin.github.io/tags/javascript/"},{"name":"IIFE","slug":"IIFE","permalink":"https://swtpumpkin.github.io/tags/IIFE/"},{"name":"function","slug":"function","permalink":"https://swtpumpkin.github.io/tags/function/"},{"name":"ImmediatelyInvokedFunctionExpression","slug":"ImmediatelyInvokedFunctionExpression","permalink":"https://swtpumpkin.github.io/tags/ImmediatelyInvokedFunctionExpression/"}]},{"title":"javascript 정수 체크","slug":"javascript/checkInteger","date":"2020-02-27T14:00:00.000Z","updated":"2020-05-06T07:34:44.382Z","comments":true,"path":"javascript/checkInteger/","link":"","permalink":"https://swtpumpkin.github.io/javascript/checkInteger/","excerpt":"","text":"javascript에서 정수 체크javascript에서 숫자의 값이 10진수의 정수인지 체크하는 방법에 대해 설명드리겠습니다. 함수를 생성하여 10진수 정수 체크를 해보겠습니다. 함수 생성12345678function isInt(num) &#123; return num % 1 === 0;&#125;console.log(isInt(2020)); // trueconsole.log(isInt(\"10\")); // trueconsole.log(isInt(3.14)); // falseconsole.log(isInt(0.29)); // falseconsole.log(isInt(\"2.29\")); // false isInt라는 함수를 생성하여 parameter로 받은 값을 1로 나눠 나머지가 있는지 체크합니다. 여기서 javascript의 특성상 string으로값을 넘긴 &quot;10&quot;은 숫자로 변환되어 true를 반환합니다. 따라서 형변환을 원하지 않는다면 type 체크를 해야합니다. 1234567function isInt(num) &#123; return typeof num === \"number\" &amp;&amp; num % 1 === 0;&#125;console.log(isInt(2020)); // trueconsole.log(isInt(\"10\")); // falseconsole.log(isInt(3.14)); // falseconsole.log(isInt(0.29)); // false 위와같이 타입체크까지 추가한다면 완벽한 10진수 정수를 체크 할 수 있습니다.","categories":[{"name":"javascript","slug":"javascript","permalink":"https://swtpumpkin.github.io/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://swtpumpkin.github.io/tags/javascript/"},{"name":"integer","slug":"integer","permalink":"https://swtpumpkin.github.io/tags/integer/"},{"name":"number","slug":"number","permalink":"https://swtpumpkin.github.io/tags/number/"}]},{"title":"null과 undefined의 차이","slug":"javascript/differenceBetweenNullAndUndefined","date":"2020-02-25T23:00:00.000Z","updated":"2020-05-06T07:34:44.382Z","comments":true,"path":"javascript/differenceBetweenNullAndUndefined/","link":"","permalink":"https://swtpumpkin.github.io/javascript/differenceBetweenNullAndUndefined/","excerpt":"","text":"null과 undefined의 차이null !== undefined! null과 undefined는 다릅니다. null과 undefined의 차이점에 대해 설명드리겠습니다. nullnull은 비어있거나 존재하지 않는 값입니다. 따라서 null을 할당하면 명시적으로 비어있는 값입니다. 12var nullTest = null;consloe.log(nullTest); // null 따라서 변수에 null을 할당하면 null이 출력됩니다. 12var nullTest = null;console.log(typeof nullTest); // object 추가로 null은 존재하지 않는 값임에도 타입은 object입니다. 이것은 javascript의 흥미로운 이슈 중 하나입니다. undefinedundefined는 변수를 아직 할당하지 않았다는 것을 의미합니다. 변수는 선언되었지만 변수의 값을 할당하지 않으면 undefined입니다. 12var undefinedTest;console.log(undefinedTest); // undefined 따라서 변수를 선언 후 아무것도 할당하지 않았다면 undefined가 출력됩니다. 12var undefinedTest;console.log(typeof undefinedTest); // undefined 아무것도 할당하지 않는 변수의 타입은 null과는 다르게 undefined입니다. 추가로12console.log(null !== undefined); // trueconsole.log(null == undefined); // true 처음 설명에서 null !== undefined는 true라고 설명드렸습니다. 하지만 null == undefined 또한 true입니다. 이는 null과 undefined가 부정을 의미하기 때문에 의미가 같아 true를 반환하는 것입니다.","categories":[{"name":"javascript","slug":"javascript","permalink":"https://swtpumpkin.github.io/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://swtpumpkin.github.io/tags/javascript/"},{"name":"undefined","slug":"undefined","permalink":"https://swtpumpkin.github.io/tags/undefined/"},{"name":"difference","slug":"difference","permalink":"https://swtpumpkin.github.io/tags/difference/"}]},{"title":"Moment Week Of Month","slug":"backend/node/momentWeekOfMonth","date":"2020-02-22T23:00:00.000Z","updated":"2020-02-22T23:55:17.643Z","comments":true,"path":"backend/node/momentWeekOfMonth/","link":"","permalink":"https://swtpumpkin.github.io/backend/node/momentWeekOfMonth/","excerpt":"","text":"Moment를 이용하여 해당 월의 주차 구하기Moment 라이브러리를 이용하여 해당 월의 주차를 구하는 방법에 대해 포스팅하겠습니다. 이미 해당 년도의 오늘날짜가 몇 주차인지 구하는 WeekOfYear는 있지만 WeekOfMonth는 없기때문에 함수로 작성해야합니다. Week of month123456const moment = require('moment');const weekOfMonth = (m) =&gt; m.week() - moment(m).startOf('month').week() + 1;const nowDate = moment().utc(true);console.log(nowDate.format('YYYY년 MM월 ') + weekOfMonth(nowDate) + '주차'); // 2020년 02월 5주차 weekOfMonth함수를 이용하여 moment객체를 매개변수로 받습니다. 해당 날짜의 주차 - 해당 월의 첫 주차 + 1로 현재 달의 주차를 구할 수 있습니다. 123456import moment, &#123;Moment&#125; from 'moment';const weekOfMonth = (m: Moment) =&gt; m.week() - moment(m).startOf('month').week() + 1;const nowDate = moment().utc(true);console.log(nowDate.format('YYYY년 MM월 ') + weekOfMonth(nowDate) + '주차'); // 2020년 02월 5주차 typescript의 경우 weekOfMonth함수의 매개변수 타입을 Moment로 지정해주어야 합니다.","categories":[{"name":"backend","slug":"backend","permalink":"https://swtpumpkin.github.io/categories/backend/"},{"name":"node","slug":"backend/node","permalink":"https://swtpumpkin.github.io/categories/backend/node/"}],"tags":[{"name":"node","slug":"node","permalink":"https://swtpumpkin.github.io/tags/node/"},{"name":"javascript","slug":"javascript","permalink":"https://swtpumpkin.github.io/tags/javascript/"},{"name":"moment","slug":"moment","permalink":"https://swtpumpkin.github.io/tags/moment/"},{"name":"weekofmonth","slug":"weekofmonth","permalink":"https://swtpumpkin.github.io/tags/weekofmonth/"},{"name":"월주차","slug":"월주차","permalink":"https://swtpumpkin.github.io/tags/%EC%9B%94%EC%A3%BC%EC%B0%A8/"}]},{"title":"React Native Navigation Header Hide","slug":"frontend/reactNative/reactNativeNavigationHeaderHide","date":"2020-02-19T23:00:00.000Z","updated":"2020-02-20T23:44:27.164Z","comments":true,"path":"frontend/reactNative/reactNativeNavigationHeaderHide/","link":"","permalink":"https://swtpumpkin.github.io/frontend/reactNative/reactNativeNavigationHeaderHide/","excerpt":"","text":"React Native Navigation Header HideReact Native에서 Navigation의 Header를 숨기는 방법에 대해 설명드리겠습니다. 설정 방법우선 React Native의 Navigation의 기본 설정은 여기를 참고하시기 바랍니다. tsx1234567891011121314151617import * as React from 'react';import &#123;NavigationContainer&#125; from '@react-navigation/native';import &#123;createStackNavigator&#125; from '@react-navigation/stack';import Home from './src/views/Home';const Stack = createStackNavigator();const App = () =&gt; &#123; return ( &lt;NavigationContainer&gt; &lt;Stack.Navigator&gt; &lt;Stack.Screen name=\"Home\" component=&#123;Home&#125; /&gt; &lt;/Stack.Navigator&gt; &lt;/NavigationContainer&gt; );&#125;;export default App; App.tsx의 설정은 공식 홈페이지의 docs를 참조하여 작성하였습니다. 처음 Navigation을 생성하게 되면 Header가 자동으로 생성됩니다. Header의 옵션을 추가하지 않으면 Stack.Screen의 name이 Header의 Title로 자동 설정됩니다.따라서 위와 같이 Header의 Title이 Home으로 설정된 것을 볼 수 있습니다. 하지만 메인 홈에서는 Header가 필요없는 경우도 있습니다. tsx123456789101112131415161718192021import * as React from 'react';import &#123;NavigationContainer&#125; from '@react-navigation/native';import &#123;createStackNavigator&#125; from '@react-navigation/stack';import Home from './src/views/Home';const Stack = createStackNavigator();const App = () =&gt; &#123; return ( &lt;NavigationContainer&gt; &lt;Stack.Navigator&gt; &lt;Stack.Screen name=\"Home\" component=&#123;Home&#125; options=&#123;&#123;headerShown: false&#125;&#125; /&gt; &lt;/Stack.Navigator&gt; &lt;/NavigationContainer&gt; );&#125;;export default App; Stack.Screen에서 options의 headerShown: false옵션을 추가하면 Header를 제거할 수 있습니다.headerShown: false옵션을 추가하면 위와 같이 Status bar아래에 Header가 없어진 것을 확인할 수 있습니다.","categories":[{"name":"frontend","slug":"frontend","permalink":"https://swtpumpkin.github.io/categories/frontend/"},{"name":"reactNative","slug":"frontend/reactNative","permalink":"https://swtpumpkin.github.io/categories/frontend/reactNative/"}],"tags":[{"name":"node","slug":"node","permalink":"https://swtpumpkin.github.io/tags/node/"},{"name":"reactNative","slug":"reactNative","permalink":"https://swtpumpkin.github.io/tags/reactNative/"},{"name":"navigation","slug":"navigation","permalink":"https://swtpumpkin.github.io/tags/navigation/"},{"name":"header","slug":"header","permalink":"https://swtpumpkin.github.io/tags/header/"},{"name":"hide","slug":"hide","permalink":"https://swtpumpkin.github.io/tags/hide/"}]},{"title":"React Native Android setting","slug":"frontend/reactNative/reactNativeAndroidSetting","date":"2020-02-10T01:00:00.000Z","updated":"2020-02-11T09:12:07.605Z","comments":true,"path":"frontend/reactNative/reactNativeAndroidSetting/","link":"","permalink":"https://swtpumpkin.github.io/frontend/reactNative/reactNativeAndroidSetting/","excerpt":"","text":"React Native Android 설정React Native의 React Native CLI Quickstart설정에 대한 정리입니다. 설치방법Java Development Kithomebrew를 이용하여 JDK를 설치합니다. 만약 JDK를 이미 설치 한 경우 JDK의 버전이 8이상인지 확인하시기 바랍니다. 12brew tap AdoptOpenJDK&#x2F;openjdkbrew cask install adoptopenjdk8 Android development environmentAndroid Studio는 Android Studio 홈페이지에서 설치 가능합니다.Android Studio를 처음 설치하게되면 설정 마법사 창이 뜨는데 설정을 Custom으로 선택합니다.SDK Components Setup에서 모두 선택하여 설치를 합니다.Android Studio를 처음 실행하면 이와 같은 창이 뜨는데 command + ,를 이용하여 환경설정을 열어줍니다.검색에서 SDK를 검색하면 왼쪽탭에서 Android SDK를 볼 수 있는데 SDK Platforms탭에서 Show Package Details를 선택하여 Intel x86 Atom_64 System Image와 Google APIs Intel x86 Atom System Image를 선택하여 설치해줍니다.설치가 완료되면 Android의 환경변수를 설정해야합니다. 12345export ANDROID_HOME&#x3D;$HOME&#x2F;Library&#x2F;Android&#x2F;sdkexport PATH&#x3D;$PATH:$ANDROID_HOME&#x2F;emulatorexport PATH&#x3D;$PATH:$ANDROID_HOME&#x2F;toolsexport PATH&#x3D;$PATH:$ANDROID_HOME&#x2F;tools&#x2F;binexport PATH&#x3D;$PATH:$ANDROID_HOME&#x2F;platform-tools open ~/.bash_profile 또는 open ~/.bashrc 또는 open ~/.zshrc 파일을 열어 위의 환경변수 값들을 추가 후 저장합니다. 아마 mac OS Catalina부터 zsh가 기본으로 설치되어있기 때문에 .zshrc파일에 환경변수를 추가하면 됩니다.","categories":[{"name":"frontend","slug":"frontend","permalink":"https://swtpumpkin.github.io/categories/frontend/"},{"name":"reactNative","slug":"frontend/reactNative","permalink":"https://swtpumpkin.github.io/categories/frontend/reactNative/"}],"tags":[{"name":"reactNative","slug":"reactNative","permalink":"https://swtpumpkin.github.io/tags/reactNative/"},{"name":"initialSetting","slug":"initialSetting","permalink":"https://swtpumpkin.github.io/tags/initialSetting/"},{"name":"android","slug":"android","permalink":"https://swtpumpkin.github.io/tags/android/"}]},{"title":"React Native iOS setting","slug":"frontend/reactNative/reactNativeIOSSetting","date":"2020-02-10T00:00:00.000Z","updated":"2020-02-11T08:35:25.533Z","comments":true,"path":"frontend/reactNative/reactNativeIOSSetting/","link":"","permalink":"https://swtpumpkin.github.io/frontend/reactNative/reactNativeIOSSetting/","excerpt":"","text":"React Native iOS 설정React Native의 React Native CLI Quickstart설정에 대한 정리입니다. 설치방법XcodeXcode는 macAppStore에서 설치 할 수 있습니다.Xcode가 설치완료되면 Xcode를 실행 후 command + ,를 이용하여 환경설정을 열어줍니다.Locations탭에서 Command Line Tools부분에서 사용하려는 해당 iOS 버전의 시뮬레이터를 선택합니다. CocoaPodsCocoaPods는 Ruby로 빌드되었으며 macOS에서 사용 가능한 기본 Ruby로 설치 가능합니다. sudo권한을 이용하여 CocoaPods을 설치합니다. 1sudo gem install cocoapods CocoaPods의 더 많은 정보는 여기의 공식문서를 보시기 바랍니다.","categories":[{"name":"frontend","slug":"frontend","permalink":"https://swtpumpkin.github.io/categories/frontend/"},{"name":"reactNative","slug":"frontend/reactNative","permalink":"https://swtpumpkin.github.io/categories/frontend/reactNative/"}],"tags":[{"name":"reactNative","slug":"reactNative","permalink":"https://swtpumpkin.github.io/tags/reactNative/"},{"name":"initialSetting","slug":"initialSetting","permalink":"https://swtpumpkin.github.io/tags/initialSetting/"},{"name":"iOS","slug":"iOS","permalink":"https://swtpumpkin.github.io/tags/iOS/"},{"name":"xcode","slug":"xcode","permalink":"https://swtpumpkin.github.io/tags/xcode/"},{"name":"CocoaPods","slug":"CocoaPods","permalink":"https://swtpumpkin.github.io/tags/CocoaPods/"}]},{"title":"React Native initial setting","slug":"frontend/reactNative/reactNativeInitialSetting","date":"2020-02-09T23:00:00.000Z","updated":"2020-02-11T09:14:07.835Z","comments":true,"path":"frontend/reactNative/reactNativeInitialSetting/","link":"","permalink":"https://swtpumpkin.github.io/frontend/reactNative/reactNativeInitialSetting/","excerpt":"","text":"React Native 초기 설정React Native의 React Native CLI Quickstart설정에 대한 정리입니다. 설치방법Node &amp; Watchmanbrew를 이용하여 node와 Watchman을 설치하겠습니다. 이미 node가 설치되어 있다면 Watchman만 설치하시면 됩니다. 하지만 node의 버전이 8.3이상인지 확인 바랍니다. Watchman은 Facebook에서 파일 시스템의 변경 사항을 보는 도구입니다. 더 나은 성능을 위해 설치하는 것이 좋습니다. 12brew install nodebrew install watchman iOS 설정 방법iOS의 설정방법은 여기를 참고 바랍니다. Android 설정 방법Android의 설정방법은 여기를 참고 바랍니다.","categories":[{"name":"frontend","slug":"frontend","permalink":"https://swtpumpkin.github.io/categories/frontend/"},{"name":"reactNative","slug":"frontend/reactNative","permalink":"https://swtpumpkin.github.io/categories/frontend/reactNative/"}],"tags":[{"name":"node","slug":"node","permalink":"https://swtpumpkin.github.io/tags/node/"},{"name":"reactNative","slug":"reactNative","permalink":"https://swtpumpkin.github.io/tags/reactNative/"},{"name":"initialSetting","slug":"initialSetting","permalink":"https://swtpumpkin.github.io/tags/initialSetting/"},{"name":"watchman","slug":"watchman","permalink":"https://swtpumpkin.github.io/tags/watchman/"}]},{"title":"Express error handling","slug":"backend/node/errorHandler","date":"2020-01-11T23:00:00.000Z","updated":"2020-01-13T05:44:43.116Z","comments":true,"path":"backend/node/errorHandler/","link":"","permalink":"https://swtpumpkin.github.io/backend/node/errorHandler/","excerpt":"","text":"Express에서 에러 핸들링하기Express에서 에러 처리는 일반적인 3개의 인수(req, res, next)가 아닌 4개의 인수(err, req, res, next)를 갖습니다. 에러 핸들링을 하려면 모든 라우트 호출의 정의가 끝나고 가장 마지막에 정의해야 합니다. 123456789import * as express from 'express';const app = express()app.use(bodyParser.json());app.use(cookieParser());app.use(middleware);app.use(router);app.use(errorHandler) 위와 같이 모든 미들웨어, 라우터가 정의 된 후에 errorHandler라는 에러핸들링 미들웨어를 추가해야 합니다. 에러핸들링 미들웨어는 여러가지를 추가 할 수 있습니다. Error handling12345678910111213141516171819202122232425262728293031323334353637import * as express from 'express';import &#123; Request, Response, NextFunction &#125; from 'express';interface Err extends Error &#123; name: string message: string status: number&#125;const app = express();const port = 4000;// 'Hello world' response to all GET requestsapp.get('*', (req: Request, res: Response, next: NextFunction) =&gt; &#123; res.send('Hello World!')&#125;);// All POST requests occur errorapp.post('*', (req: Request, res: Response, next: NextFunction) =&gt; &#123; const err = &#123; name: 'Bad Request', message: 'Invalid request.', status: 400 &#125;; next(err);&#125;);// Error Handling partapp.use((err: Err, req: Request, res: Response, next: NextFunction) =&gt; &#123; if (res.headersSent) return next(err); const &#123;name, message, status&#125; = err; res.status(status).json(&#123;name, message, status&#125;);&#125;);app.lisen(port, () =&gt; &#123; console.log(`🚀 App listening on the port $&#123;port&#125;`);&#125;); 위와 같이 모든 GET요청에는 &#39;Hello World!&#39;를 응답하고 모든 POST요청에는 에러를 발생하도록 하겠습니다. POST의 에러는 nextFunction으로 에러메세지를 넘기도록 하겠습니다. 라우터에서 next()를 사용하여 에러를 넘기게 되면 모든 에러는 에러미들웨어로 처리를 위임 할 수 있습니다.모든 GET요청에는 &#39;Hello World!&#39;를 잘 리턴합니다.모든 POST요청에는 400 Bad Request상태코드와 커스텀 에러메세지를 응답합니다.하지만 다른 PATCH와 같은 요청에는 위와 같이 응답값이 이쁘지 않습니다. 단지 404 Not Found상태코드와 에러를 발생합니다.API가 존재하지 않는 요청에 대해서도 미들웨어를 통해 에러핸들링을 할 수 있습니다. 에러핸들링 바로 위에 404 Not Found에 관한 코드를 추가하겠습니다. 123456789101112131415app.use((req: Request, res: Response, next: NextFunction) =&gt; &#123; const err = &#123; name: 'Not Found', message: 'The request was incorrect.', status: 404 &#125;; next(err);&#125;);// Error Handling partapp.use((err: Err, req: Request, res: Response, next: NextFunction) =&gt; &#123; if (res.headersSent) return next(err); const &#123;name, message, status&#125; = err; res.status(status).json(&#123;name, message, status&#125;);&#125;); 에러핸들링 부분 바로 위에 notFound 미들웨어를 추가하면 모든 요청에 대한 커스텀 메세지를 보여 줄 수 있습니다. 이를 응용하여 404 page도 보여줄 수 있습니다.에러핸들링은 순서가 매우 중요하므로 순서를 잘 생각하여 정의하셔야 합니다.이 블로그 포스팅과 관련된 코드는 여기를 참고 바랍니다.","categories":[{"name":"backend","slug":"backend","permalink":"https://swtpumpkin.github.io/categories/backend/"},{"name":"node","slug":"backend/node","permalink":"https://swtpumpkin.github.io/categories/backend/node/"}],"tags":[{"name":"node","slug":"node","permalink":"https://swtpumpkin.github.io/tags/node/"},{"name":"javascript","slug":"javascript","permalink":"https://swtpumpkin.github.io/tags/javascript/"},{"name":"error","slug":"error","permalink":"https://swtpumpkin.github.io/tags/error/"},{"name":"handling","slug":"handling","permalink":"https://swtpumpkin.github.io/tags/handling/"},{"name":"middleware","slug":"middleware","permalink":"https://swtpumpkin.github.io/tags/middleware/"}]},{"title":"Error: listen EADDRINUSE :::PORT","slug":"backend/node/nodePortError","date":"2020-01-07T23:00:00.000Z","updated":"2020-01-08T04:01:24.907Z","comments":true,"path":"backend/node/nodePortError/","link":"","permalink":"https://swtpumpkin.github.io/backend/node/nodePortError/","excerpt":"","text":"Error: listen EADDRINUSE :::PORT?사진과 같이 이미 사용 중인 포트에 새로운 노드를 실행하면 포트가 중복된다는 에러가 발생합니다. 여러 개 프로젝트를 켰을 때 에러가 발생하기도 하지만 예기치 않게 포트가 제거되지 않아 발생하기도 합니다. 따라서 예기치 않은 포트 중복으로 포트를 강제 삭제해주는 방법에 대해 설명드리도록 하겠습니다. 포트 삭제 방법1lsof -i:PORT 위와 같이 lsof -i:PORT를 입력하면 아래와 같이 PID를 알 수 있습니다. 1kill -9 PID kill -9 PID를 입력하여 해당 PID를 삭제합니다.","categories":[{"name":"backend","slug":"backend","permalink":"https://swtpumpkin.github.io/categories/backend/"},{"name":"node","slug":"backend/node","permalink":"https://swtpumpkin.github.io/categories/backend/node/"}],"tags":[{"name":"node","slug":"node","permalink":"https://swtpumpkin.github.io/tags/node/"},{"name":"javascript","slug":"javascript","permalink":"https://swtpumpkin.github.io/tags/javascript/"},{"name":"error","slug":"error","permalink":"https://swtpumpkin.github.io/tags/error/"},{"name":"port","slug":"port","permalink":"https://swtpumpkin.github.io/tags/port/"}]},{"title":"MySQL 삭제","slug":"backend/mysql/mysqlDelete","date":"2020-01-01T23:00:00.000Z","updated":"2020-01-08T04:06:19.003Z","comments":true,"path":"backend/mysql/mysqlDelete/","link":"","permalink":"https://swtpumpkin.github.io/backend/mysql/mysqlDelete/","excerpt":"","text":"MySQL 삭제brew로 MySQL이 설치되어있는 환경에서 삭제하는 방법에 대해 설명드리겠습니다.brew로 설치된 MySQL의 삭제하기에 앞서 MySQL 설치 방법은 여기를 참고하시기 바랍니다. 삭제방법123sudo rm -rf &#x2F;usr&#x2F;local&#x2F;var&#x2F;mysqlsudo rm -rf &#x2F;usr&#x2F;local&#x2F;bin&#x2F;mysql*sudo rm -rf &#x2F;usr&#x2F;local&#x2F;Cellar&#x2F;mysql 위와 같이 한 줄씩 최고권한으로 삭제해주면 됩니다. 1sudo rm -rf &#x2F;usr&#x2F;local&#x2F;var&#x2F;mysql &amp;&amp; sudo rm -rf &#x2F;usr&#x2F;local&#x2F;bin&#x2F;mysql* &amp;&amp; sudo rm -rf &#x2F;usr&#x2F;local&#x2F;Cellar&#x2F;mysql 한 번에 삭제를 원하시면 위 코드를 이용하여 삭제하시면 됩니다.","categories":[{"name":"backend","slug":"backend","permalink":"https://swtpumpkin.github.io/categories/backend/"},{"name":"mySQL","slug":"backend/mySQL","permalink":"https://swtpumpkin.github.io/categories/backend/mySQL/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"https://swtpumpkin.github.io/tags/mysql/"},{"name":"DB","slug":"DB","permalink":"https://swtpumpkin.github.io/tags/DB/"},{"name":"Database","slug":"Database","permalink":"https://swtpumpkin.github.io/tags/Database/"},{"name":"데이터베이스","slug":"데이터베이스","permalink":"https://swtpumpkin.github.io/tags/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4/"},{"name":"삭제","slug":"삭제","permalink":"https://swtpumpkin.github.io/tags/%EC%82%AD%EC%A0%9C/"}]},{"title":"React에서 Font Awesome 사용하기","slug":"frontend/react/reactFontAwesome","date":"2019-12-16T23:00:00.000Z","updated":"2020-01-08T04:06:19.008Z","comments":true,"path":"frontend/react/reactFontAwesome/","link":"","permalink":"https://swtpumpkin.github.io/frontend/react/reactFontAwesome/","excerpt":"","text":"Font Awesome 이란?Font Awesome은 웹페이지에서 소개된 바와 같이 인기있는 아이콘 세트 및 툴킷이라고 합니다. svg로 된 아이콘을 무료로 제공하여 사용 할 수 있습니다. react-fontawesome패키지를 이용하겠습니다. 설정방법1npm i --save @fortawesome/fontawesome-svg-core @fortawesome/free-solid-svg-icons @fortawesome/react-fontawesome Font Awesome을 사용하려면 3개의 패키지를 설치해야합니다. @fortawesome/fontawesome-svg-core @fortawesome/free-solid-svg-icons @fortawesome/react-fontawesome를 위 코드를 이용하여 한 번에 설치 합니다. src/경로에 FontAwesome.tsx파일을 생성합니다. jsx1234import &#123; library &#125; from '@fortawesome/fontawesome-svg-core';import &#123; faSmile &#125; from '@fortawesome/free-solid-svg-icons';library.add(faSmile); library에 사용할 icon을 추가합니다. @fortawesome/free-solid-svg-icons에서 사용 가능 한 아이콘을 선택해야합니다. smile 아이콘을 사용하려면 faSmile을 패키지에서 불러온 후 library에 추가합니다. jsx1import './FontAwesome'; index.tsx에서 FontAwesome파일을 추가합니다. jsx123import &#123; FontAwesomeIcon &#125; from '@fortawesome/react-fontawesome'&lt;FontAwesomeIcon icon=\"smile\" size=\"7x\"/&gt; 사용 할 파일에서 FontAwesomeIcon을 불러온 후 icon의 이름으로 smile을 사용하면 다음과 같이 svg icon을 사용 할 수 있습니다.","categories":[{"name":"frontend","slug":"frontend","permalink":"https://swtpumpkin.github.io/categories/frontend/"},{"name":"react","slug":"frontend/react","permalink":"https://swtpumpkin.github.io/categories/frontend/react/"}],"tags":[{"name":"react","slug":"react","permalink":"https://swtpumpkin.github.io/tags/react/"},{"name":"typescript","slug":"typescript","permalink":"https://swtpumpkin.github.io/tags/typescript/"},{"name":"fontawesome","slug":"fontawesome","permalink":"https://swtpumpkin.github.io/tags/fontawesome/"}]},{"title":"create-react-app에서 Typescript로 개발하기","slug":"frontend/react/createReactAppUsedTypescript","date":"2019-12-15T23:00:00.000Z","updated":"2020-01-08T04:06:19.008Z","comments":true,"path":"frontend/react/createReactAppUsedTypescript/","link":"","permalink":"https://swtpumpkin.github.io/frontend/react/createReactAppUsedTypescript/","excerpt":"","text":"create-react-app이란?React앱을 간편하게 만들 수 있도록 자동으로 빌드해주는 모듈입니다.이 패키지 모듈을 이용하면 Webpack이나 Babel을 설치하고 셋팅하는 복잡한 과정을 생략 할 수 있습니다.Typescript를 이용한 create-react-app 설정방법에 대해 설명드리도록 하겠습니다. Typescript란?설정 방법 이전에 Typescript가 무엇인지 간단하게 설명드리겠습니다.TypeScript는 마이크로소프트가 개발한 프로그래밍 언어입니다.자바스크립트의 타이핑된 상위 집합으로, 자체 컴파일러를 포함합니다.Typescript는 앱이 실행되기 전 컴파일 단계에서 오류와 버그를 잡을 수 있습니다. 전역설치1npm install -g create-react-app 일단 create-react-app 모듈을 전역에 설치해줍니다. create-react-app을 전역에 설치하면 설치된 내 컴퓨터 환경 어디서든 사용이 가능합니다. 사용방법1create-react-app ReactApp(설정 할 프로젝트 이름) --typescript create-react-app 다음에 설정 할 프로젝트의 이름을 작성하고 --typescript를 작성합니다. --typescript을 뒤에 붙여주게 되면 간단하게 Typescript로 된 React앱을 설정 할 수 있습니다.여기서 주의해야 할 점은 설정할 프로젝트에서 대문자가 포함되어있으면 프로젝트가 생성되지 않습니다. camelCase보다 kebab-case로 프로젝트를 생성하는 것을 추천합니다. 1npm start npm start로 프로젝트를 실행하면 ReactApp이 위와 같이 실행됩니다.","categories":[{"name":"frontend","slug":"frontend","permalink":"https://swtpumpkin.github.io/categories/frontend/"},{"name":"react","slug":"frontend/react","permalink":"https://swtpumpkin.github.io/categories/frontend/react/"}],"tags":[{"name":"create-react-app","slug":"create-react-app","permalink":"https://swtpumpkin.github.io/tags/create-react-app/"},{"name":"react","slug":"react","permalink":"https://swtpumpkin.github.io/tags/react/"},{"name":"typescript","slug":"typescript","permalink":"https://swtpumpkin.github.io/tags/typescript/"}]},{"title":"Docker Hub와 Github 연결하기","slug":"backend/docker/dockerGithub","date":"2019-12-11T23:00:00.000Z","updated":"2020-01-08T04:06:19.002Z","comments":true,"path":"backend/docker/dockerGithub/","link":"","permalink":"https://swtpumpkin.github.io/backend/docker/dockerGithub/","excerpt":"","text":"Docker Hub와 Githubdocker에는 docker Hub라는 저장소가 있습니다. Github처럼 원격저장소로 사용 할 수 있는 저장소입니다. Github로 코드를 푸쉬하게 되면 docker에서 컨테이너를 생성이 가능합니다. 컨테이너를 푸쉬와 동시에 생성을 하기 위해선 Github와의 연동이 필요합니다. 연동 방법Docker-Hub사이트에서 로그인 후 오른쪽의 지문 모양을 클릭 후 Account Setting을 클릭합니다.왼쪽 탭에서 Linked Accounts를 선택합니다. Github부분을 보면 현재 어떤 계정도 연동되어있지 않습니다. Github 오른쪽의 connect를 클릭합니다.Github OAuth로그인으로 이동하게 되는데 아이디와 패스워드를 입력하여 로그인합니다.Authorize docker를 클릭하여 OAuth계정 연동을 합니다.연동이 완료되면 Linked Accounts에서 Github가 연동 완료된 것을 볼 수 있습니다.","categories":[{"name":"backend","slug":"backend","permalink":"https://swtpumpkin.github.io/categories/backend/"},{"name":"docker","slug":"backend/docker","permalink":"https://swtpumpkin.github.io/categories/backend/docker/"}],"tags":[{"name":"dockerHub","slug":"dockerHub","permalink":"https://swtpumpkin.github.io/tags/dockerHub/"},{"name":"Github","slug":"Github","permalink":"https://swtpumpkin.github.io/tags/Github/"},{"name":"auth","slug":"auth","permalink":"https://swtpumpkin.github.io/tags/auth/"}]},{"title":"AWS Certificate Manager","slug":"backend/aws/awsACM","date":"2019-11-29T23:00:00.000Z","updated":"2020-01-08T04:06:19.000Z","comments":true,"path":"backend/aws/awsACM/","link":"","permalink":"https://swtpumpkin.github.io/backend/aws/awsACM/","excerpt":"","text":"AWS Certificate Manager를 이용하여 무료 인증서 발급기존에 저는 letsencrypt를 사용했는데 사용 할 때 가장 큰 문제점이 3개월마다 갱신을 해줘야 했습니다. 3개월 주기로 갱신을 해주면 상관없지만 갱신을 못 하게 되면 인증이 풀리는 경우가 생겼습니다. 인증서 만료가 되면 사이트 접속 시 빨간글씨로 이 사이트는 안전하지 않습니다.라는 경고가 뜨게 됩니다.ACM을 도입하게 된 가장 큰 이유는 유효기간이 13개월이고 자동갱신을 지원하여 인증서 문제로 인한 가동중지를 방지해 줍니다. 따라서 ACM을 발급받는 방법에 대해 설명드리겠습니다. ACM 발급 방법검색창에 ACM으로 검색하면 Certificate Manager가 리스트에 나오는데 Certificate Manager를 클릭하여 인증서 페이지로 이동합니다.인증서관리자 탭에서 인증서 요청을 클릭합니다.인증서 요청에서 공인 인증서 요청을 선택 후 인증서 요청을 클릭합니다.도메인 이름에 보유하고 있고 사용 할 도메인을 입력합니다.검증 방법엔 여러가지가 있지만 DNS 검증에 대해서만 설명드릴 것이기 때문에 DNS 검증을 선택하고 다음을 클릭합니다.태그는 선택사항이므로 건너뛰도록 하겠습니다.검토 및 요청 단계에서 도메인 이름이 인증받을 주소인지 확인 후 확인 및 요청을 클릭합니다.검증 단계에서 ▶버튼을 클릭하여 상세보기로 이동합니다.DNS 방식에서 Route53서비스의 도메인을 이용하고 있다면 Route53에서 레코드 생성을 클릭합니다.Route53에서 레코드 생성 팝업에서 생성만 눌러주게 되면 간단하게 CNAME으로 생성됩니다.Route53으로 이동하여 자동 생성된 CNAME을 확인 할 수 있습니다.생성이 성공되면 위와 같이 성공 메세지를 볼 수 있습니다. 성공 후 계속을 누르면 인증서 관리자 페이지로 이동되게 됩니다.인증서 관리자에서 생성한 인증서의 발급 여부를 상태를 통해 확인 가능합니다. 인증에 걸리는 시간이 몇 분정도 소요되니 기다리면 검증 보류 상태에서 발급 완료로 바뀌게 됩니다.모든 절차가 완료되면 위와같이 아마존에서 발급받은 인증서를 볼 수 있습니다.","categories":[{"name":"backend","slug":"backend","permalink":"https://swtpumpkin.github.io/categories/backend/"},{"name":"AWS","slug":"backend/AWS","permalink":"https://swtpumpkin.github.io/categories/backend/AWS/"}],"tags":[{"name":"aws","slug":"aws","permalink":"https://swtpumpkin.github.io/tags/aws/"},{"name":"ACM","slug":"ACM","permalink":"https://swtpumpkin.github.io/tags/ACM/"},{"name":"AWS Certificate Manager","slug":"AWS-Certificate-Manager","permalink":"https://swtpumpkin.github.io/tags/AWS-Certificate-Manager/"},{"name":"CNAME","slug":"CNAME","permalink":"https://swtpumpkin.github.io/tags/CNAME/"},{"name":"Route53","slug":"Route53","permalink":"https://swtpumpkin.github.io/tags/Route53/"}]},{"title":"javascript 빈 객체 체크 (check empty object)","slug":"javascript/checkEmptyObject","date":"2019-10-26T23:00:00.000Z","updated":"2020-02-12T07:43:25.730Z","comments":true,"path":"javascript/checkEmptyObject/","link":"","permalink":"https://swtpumpkin.github.io/javascript/checkEmptyObject/","excerpt":"","text":"javascript check empty object자바스크립트에서 빈 객체를 체크하려는 경우 null로 체크 할 수 없습니다. 따라서 별도의 함수를 생성하여 체크하는 방법을 설명드리겠습니다. 함수 생성 방법1234567const obj = &#123;&#125;;const arr = [];function isEmpty(param) &#123; return Object.keys(param).length === 0;&#125;console.log(isEmpty(obj)); // trueconsole.log(isEmpty(arr)); // true 여러 블로그를 보니 Object.keys를 이용하여 key값을 배열로 변환하여 배열의 길이가 0인지 체크하는 함수를 설명하였습니다. 하지만 이 함수는 배열 역시 true로 반환합니다. 배열도 object이기 때문입니다. 따라서 객체이면서 빈객체인지 체크하려면 추가로 체크를 해야 합니다. 1234567const obj = &#123;&#125;;const arr = [];function isEmptyObject(param) &#123; return Object.keys(param).length === 0 &amp;&amp; param.constructor === Object;&#125;console.log(isEmptyObject(obj)); // trueconsole.log(isEmptyObject(arr)); // false 위와 같이 parameter의 constructor까지 Object인지 체크해주면 확실한 객체가 빈 객체인지 체크 할 수 있습니다.","categories":[{"name":"javascript","slug":"javascript","permalink":"https://swtpumpkin.github.io/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://swtpumpkin.github.io/tags/javascript/"},{"name":"object","slug":"object","permalink":"https://swtpumpkin.github.io/tags/object/"},{"name":"empty object","slug":"empty-object","permalink":"https://swtpumpkin.github.io/tags/empty-object/"},{"name":"constructor","slug":"constructor","permalink":"https://swtpumpkin.github.io/tags/constructor/"}]},{"title":"Webstorm에 console.log shortcut 추가하기","slug":"develop/shortcutWebstorm","date":"2019-10-23T23:00:00.000Z","updated":"2020-01-08T04:06:19.006Z","comments":true,"path":"develop/shortcutWebstorm/","link":"","permalink":"https://swtpumpkin.github.io/develop/shortcutWebstorm/","excerpt":"","text":"javascript언어를 사용하는 개발자들은 console.log()를 매우 자주 사용 합니다. webstorm기본 단축어가 있긴 하지만 안타깝게도 console.log()는 없어서 추가하는 방법을 공유하겠습니다. 추가 방법webstorm실행 후 Preferences로 이동합니다. command + ,로 간단히 설정창을 열 수 있습니다.Editor &gt; Live Templates로 이동합니다.javascript선택 후 우 상단에 +버튼을 클릭하여 Live Template를 선택합니다.Abbreviation에 단축어로 사용 할 단어를 넣어줍니다. 저는 l을 이용하였습니다. Description에는 이 단축어의 설명을 넣었고 Template text에는 console.log($ITEM$);으로 작성하였습니다.Define을 클릭하면 사용 할 언어를 선택하는데 Javascript and Typescript만 선택하였습니다. 언어 선택 후 OK를 누르면 단축어가 생성됩니다.위와 같이 l과 tab만으로도 console.log()가 자동 완성되는 것을 볼 수 있습니다.","categories":[{"name":"develop","slug":"develop","permalink":"https://swtpumpkin.github.io/categories/develop/"}],"tags":[{"name":"develop","slug":"develop","permalink":"https://swtpumpkin.github.io/tags/develop/"},{"name":"webstorm","slug":"webstorm","permalink":"https://swtpumpkin.github.io/tags/webstorm/"},{"name":"jetbrains","slug":"jetbrains","permalink":"https://swtpumpkin.github.io/tags/jetbrains/"},{"name":"shortcut","slug":"shortcut","permalink":"https://swtpumpkin.github.io/tags/shortcut/"},{"name":"console.log","slug":"console-log","permalink":"https://swtpumpkin.github.io/tags/console-log/"},{"name":"live template","slug":"live-template","permalink":"https://swtpumpkin.github.io/tags/live-template/"}]},{"title":"Comparison Operator (비교 연산자)","slug":"javascript/comparisonOperator","date":"2019-10-18T23:00:00.000Z","updated":"2020-01-08T04:06:19.010Z","comments":true,"path":"javascript/comparisonOperator/","link":"","permalink":"https://swtpumpkin.github.io/javascript/comparisonOperator/","excerpt":"","text":"비교연산자란?비교연산자란 좌항과 우항의 값을 비교하여 Boolean값 즉, true, false를 반환합니다. javascript는 엄격한 비교(===)와 형변환 비교(==)와 같이 두가지의 비교 연산자를 갖고 있습니다. 동등 연산자 (==)동등 연산자는 좌항과 우항을 비교 할 때 서로 타입이 다르면 같은 타입을 일치시키고 같은 값인지 비교합니다. 따라서 좌항과 우항의 타입이 다르더라도 값만 비교하기 때문에 타입이 일치 된 후 값이 같을 수 있습니다. 123456789101 == 1 // true\"1\" == 1 // true1 == \"1\" // true1 == true // true0 == 0 // true0 == \"\" // true0 == \"0\" // true0 == false // truenull == undefined // truefalse == \"0\" // true 위와 같이 string과 number타입이 다르더라도 서로 같은 타입으로 변환 후 비교하기 때문에 숫자 1과 문자 1의 비교는 true를 반환합니다. 또한 빈 string과 숫자 0은 javascript에서 false를 의미합니다. 따라서 숫자 0과 빈 문자열 &quot;&quot;는 비교 시 true를 반환합니다. 123456false == \"false\" // falsefalse == undefined // falsefalse == null // false0 == undefined // false0 == null // falseNaN == NaN // false 하지만 false와 문자열 &quot;false&quot;의 비교는 false입니다. 문자열 &quot;false&quot;는 문자가 존재하기 때문에 빈 문자열을 false로 판단하는 것과 다르기 때문입니다. 또한 undefined와 null, NaN과 같이 예측하기 어려운 비교 결과를 볼 수 있습니다. 따라서 개발 시 비교 연산자를 사용하게 된다면 일치 연산자(===)를 사용하는 것이 좋습니다. 일치 연산자 (===)동등 연산자와는 다르게 일치 연산자는 좌항과 우항의 값과 타입이 모두 일치하는 경우에만 true를 반환합니다. 12340 === \"0\" // false0 === false // false1 === true // falsenull === undefined // false 위와 같이 동등 연산자에서 true를 반환 한 값들은 일치 연산자에서 타입까지 같지 않기 때문에 false를 반환합니다. 1NaN === NaN // false 하지만 NaN의 경우는 자신과 일치하지 않는 유일한 값입니다. 1isNaN(NaN) // true 따라서 NaN인지 확인하려면 isNaN이라는 빌트인 함수를 이용하여 NaN 값을 확인해야 합니다.","categories":[{"name":"javascript","slug":"javascript","permalink":"https://swtpumpkin.github.io/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://swtpumpkin.github.io/tags/javascript/"},{"name":"comparison operator","slug":"comparison-operator","permalink":"https://swtpumpkin.github.io/tags/comparison-operator/"},{"name":"비교 연산자","slug":"비교-연산자","permalink":"https://swtpumpkin.github.io/tags/%EB%B9%84%EA%B5%90-%EC%97%B0%EC%82%B0%EC%9E%90/"}]},{"title":"Error: Fatal: in unpopulated submodule .deploy_git","slug":"git/hexo/hexoDeploy_git","date":"2019-10-18T23:00:00.000Z","updated":"2020-01-08T04:06:19.009Z","comments":true,"path":"git/hexo/hexoDeploy_git/","link":"","permalink":"https://swtpumpkin.github.io/git/hexo/hexoDeploy_git/","excerpt":"","text":"Error: Fatal: in unpopulated submodule .deploy_git저는 블로그 소스파일을 깃 private 레포지토리에 올려놓습니다. 오랜만에 블로그 글을 게시하기 위해 레포지토리에서 내려받고 배포하려는데 에러가 발생하였습니다. 따라서 에러 해결방법에 대해 포스팅하겠습니다. 해결 방법1rm -rf .deploy_git 배포하려는 폴더의 루트에서 위 코드를 실행하여 .deploy_git 파일을 삭제합니다. 1hexo g -d 그 후 생성 배포를 진행하면 에러가 해결 된 것을 볼 수 있습니다.","categories":[{"name":"git","slug":"git","permalink":"https://swtpumpkin.github.io/categories/git/"},{"name":"hexo","slug":"git/hexo","permalink":"https://swtpumpkin.github.io/categories/git/hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://swtpumpkin.github.io/tags/hexo/"},{"name":".deploy_git","slug":"deploy-git","permalink":"https://swtpumpkin.github.io/tags/deploy-git/"}]},{"title":"hexo utterances 댓글 추가","slug":"git/hexo/hexoCommentUtterances","date":"2019-10-08T23:00:00.000Z","updated":"2020-01-08T04:06:19.009Z","comments":true,"path":"git/hexo/hexoCommentUtterances/","link":"","permalink":"https://swtpumpkin.github.io/git/hexo/hexoCommentUtterances/","excerpt":"","text":"utterances를 이용하여 댓글 기능 추가페이스북 댓글 기능을 사용하였는데 댓글이 달려도 알람이 오지 않아 답변을 남기기 힘들었습니다. 따라서 댓글 알림기능을 찾다가 utterances라는 오픈소스에 대해 알게되었고 이 기능을 추가하면서 추가하는 방법에 대해 설명해보려고 합니다. utterances는 깃 레포지토리에 이슈 생성하고 댓글로 보여주는 기능입니다. 추가 방법사용자의 깃에서 레포지토리를 생성하는데 저는 blog-comments라는 레포지토리를 생성하겠습니다. 이때 레포지토리는 꼭 public으로 설정해야 합니다.themes - 사용자 테마 - layout - comment폴더로 이동하여 utterances.ejs파일을 생성합니다.utterances 페이지로 이동합니다.아까 깃 레포 생성한 사용자/blog-comments를 입력합니다. 저는 swtpumpkin/blog-comments를 입력하였습니다.옵션은 가장 마지막 옵션인 Issue title contains specific term를 선택하였습니다.테마를 선택하면 아래 스크립트가 생성되는데 복사를 합니다.이전에 생성한 utterances.ejs파일에 스크립트를 붙여넣습니다.같은 comment폴더에 있는 index.ejs파일로 이동합니다. 12&lt;% &#125; else if (theme.comment.utterances.enable)&#123; %&gt; &lt;%- partial(&#39;comment&#x2F;utterances&#39;)%&gt; index.ejs에 위 코드를 추가합니다.themes - 사용자 테마 폴더에 _config.yml파일로 이동합니다. 12utterances: enable: true comment라인 아래에 위 코드를 추가합니다.위와 같이 포스팅 된 글 맨 아래에 댓글 달 수 있는 창이 생긴걸 확인 할 수 있습니다. 앞으로 댓글이 달리면 알림이 깃허브 알림이 와 댓글 답변을 달 수 있을 것 같네요!","categories":[{"name":"git","slug":"git","permalink":"https://swtpumpkin.github.io/categories/git/"},{"name":"hexo","slug":"git/hexo","permalink":"https://swtpumpkin.github.io/categories/git/hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://swtpumpkin.github.io/tags/hexo/"},{"name":"comments","slug":"comments","permalink":"https://swtpumpkin.github.io/tags/comments/"},{"name":"utterances","slug":"utterances","permalink":"https://swtpumpkin.github.io/tags/utterances/"}]},{"title":"s3와 lambda를 이용하여 이미지 리사이징 서버 만들기","slug":"backend/aws/lambdaResizing","date":"2019-06-22T09:00:00.000Z","updated":"2020-01-08T04:06:19.001Z","comments":true,"path":"backend/aws/lambdaResizing/","link":"","permalink":"https://swtpumpkin.github.io/backend/aws/lambdaResizing/","excerpt":"","text":"aws lambda를 이용하여 이미지 리사이징 서버 만들기aws에 Lambda라는 서버리스 기능을 이용하여 이미지 리사이징 서버를 만들어보겠습니다. S3에 이미지 원본과 썸네일을 한번에 저장하게 되면 저장소 용량을 많이 사용하게 됩니다. 따라서 원본만 S3에 저장하고 나머지 썸네일 이미지는 Lambda와 CloudFront, Lambda@Edge를 이용하여 이미지 리사이징 서버를 만들어 보곘습니다. 설정 방법IAMIAM 설정입니다.IAM에서 역할을 추가하겠습니다.IAM에서 역할을 선택 후 역할 만들기를 선택합니다.AWS 서비스에서 Lambda를 선택합니다.다음으로 이동하여 정책 필터에서 AWSLambdaExecute를 검색 후 체크하여 AWSLambdaExecute선택합니다.3번은 건너 뛴 후 역할이름을 사용자가 알아 볼 수 있도록 지정합니다. 정책 부분에 AWSLambdaExecute가 잘 추가 되었는지 확인합니다.역할을 생성 후 역할 리스트에 생성한 역할이 있는지 확인 후 생성한 역할을 선택합니다.신뢰관계를 추가해야해서 신뢰관계편집을 선택합니다.신뢰관계를 아래와 같이 동일하게 편집합니다. 123456789101112131415&#123; \"Version\": \"2012-10-17\", \"Statement\": [ &#123; \"Effect\": \"Allow\", \"Principal\": &#123; \"Service\": [ \"lambda.amazonaws.com\", \"edgelambda.amazonaws.com\" ] &#125;, \"Action\": \"sts:AssumeRole\" &#125; ]&#125; 편집 후 신뢰 정책 업데이트를 선택하여 신뢰관계를 업데이트합니다.신뢰할 수 있는 개체에 위와 같이 두개의 리스트가 나타나있어야합니다. S3S3 버킷을 만들어줍니다.위와 같이 S3 리전은 서울로 지정하겠습니다. CloudFrontCloudFront 설정입니다.CloudFront로 이동하겠습니다.Create Distribution을 선택합니다.콘텐츠 전송 방법은 Web을 선택합니다.Origin Domain Name에서 생성한 S3의 버킷을 선택합니다.Origin Domain Name에서 버킷 선택 후 Restrict Bucket Access 설정은 Yes로 설정합니다.Origin Access Identity 설정은 Create a New Identity로 설정합니다.Grant Read Permissions on Bucket 설정은 Yes, Update Bucket Policy로 설정합니다.Origin Access Identity 설정과 Grant Read Permissions on Bucket 설정은 S3에 CloudFront만 접근 가능하도록 하는 설정입니다.Query String Whitelist 설정에 d를 추가합니다.Compress Objects Automatically 설정은 Yes로 설정합니다.쿼리 스트링에 d를 키값으로 이미지 리사이징을 진행 할 예정이라 추가하였습니다. Compress Objects Automatically 설정을 Yes로 설정하면 컨텐츠를 압축하여 전송함으로 다운로드 속도가 빨라지게 됩니다. 따라서 설정을 활성화 하였습니다. LambdaLambda 설정을 시작해보겠습니다.Lambda의 리전은 꼭 미국 동부(버지니아 북부)로 선택합니다. Lambda의 Lambda@Edge와 CloudFront는 버지니아 북부 리전에서만 설정 할 수 있습니다. 하지만 리전을 걱정 안하셔도 되는게 람다함수는 모든 리전에 복사되어 가까운 리전에서 응답을 받을 수 있습니다. 따라서 버지니아 북부로 꼭 선택하고 함수만들기를 선택합니다.함수생성에서 함수 이름은 사용자가 알아서 입력을 합니다. Lambda 함수 리스트에서 알아 볼 수 있도록 이름을 설정합니다. 런타임은 Node.js 8.10으로 설정하겠습니다. 현제 Node.js 10버전을 사용 할 수 있긴 하지만 현재 쓰는 노드버전이 8버전이므로 8버전을 선택하였습니다. 권한설정에서 실행 역할을 기존 역할 사용으로 설정합니다. 여기서 권한은 위에서 IAM의 역할을 추가했던 그 역할을 사용 할 것입니다. 기존 역할에서 IAM에서 생성한 역할을 선택합니다. 설정 완료 후 함수 생성을 선택하여 함수를 생성합니다. 람다 설정에서 람다 함수 코드를 작성해보도록 하겠습니다.바탕화면에 swt-lambda라는 폴더를 생성해주었습니다.폴더로 이동하여 npm init -y를 실행하여 package.json파일을 생성합니다. 실행 후 npm install querystring sharp aws-sdk를 실행하여 3개의 패키지를 설치합니다.index.js파일을 생성합니다. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253const querystring = require('querystring');const Sharp = require('sharp');const AWS = require('aws-sdk');const S3 = new AWS.S3(&#123; region: 'ap-northeast-2' &#125;);const BUCKET = 'swt-lambda';exports.handler = async (event, context, callback) =&gt; &#123; const response = event.Records[0].cf.response; const request = event.Records[0].cf.request; const params = querystring.parse(request.querystring); // https://cloudfront.com/image.jpg?d=100x100와 일치하지 않은 주소 일 경우 원본 이미지를 반환합니다. if (!params.d) &#123; callback(null, response); return; &#125; const uri = request.uri; // d=100x100의 쿼리를 .split('x')를 이용하여 배열로 설정합니다. const imageSize = params.d.split('x'); // 배열의 0번째를 가로로 설정합니다. const width = parseInt(imageSize[0]); // 배열의 1번쨰를 세로로 설정합니다. const height = parseInt(imageSize[1]); const [, imageName, extension] = uri.match(/\\/(.*)\\.(.*)/); const requiredFormat = extension == 'jpg' ? 'jpeg' : extension; const originalKey = imageName + '.' + extension; try &#123; // aws-sdk를 이용하여 s3에서 이미지를 받아옵니다. const s3Object = await S3.getObject(&#123; Bucket: BUCKET, Key: originalKey, &#125;).promise(); // sharp를 이용하여 이미지를 리사이징 합니다. const resizedImage = await Sharp(s3Object.Body) .resize(width, height) .toFormat(requiredFormat) .toBuffer(); response.status = 200; response.body = resizedImage.toString('base64'); response.bodyEncoding = 'base64'; response.headers['content-type'] = [ &#123; key: 'Content-Type', value: 'image/' + requiredFormat &#125;, ]; return callback(null, response); &#125; catch (error) &#123; return callback(error); &#125;&#125;; index.js 파일과 node_modules폴더를 한번에 선택 후 압축합니다.Lambda로 이동하여 함수코드 부분에서 코드 입력 유형을 .zip 파일 업로드로 선택합니다.업로드를 선택하여 index.js 파일과 node_modules폴더를 압축 한 압축파일을 업로드합니다.파일이 업로드가 완료 된 후 저장합니다.기본설정을 위와 같이 설정합니다.트리거 추가 목록에서 CloudFront를 선택합니다.트리거 구성에서 Lambda@Edge로 배포를 선택합니다.CloudFront 이벤트를 오리진 응답으로 선택합니다. Lambda@Edge로 배포 확인에서 체크 후 배포를 선택하여 배포합니다.","categories":[{"name":"backend","slug":"backend","permalink":"https://swtpumpkin.github.io/categories/backend/"},{"name":"AWS","slug":"backend/AWS","permalink":"https://swtpumpkin.github.io/categories/backend/AWS/"}],"tags":[{"name":"aws","slug":"aws","permalink":"https://swtpumpkin.github.io/tags/aws/"},{"name":"s3","slug":"s3","permalink":"https://swtpumpkin.github.io/tags/s3/"},{"name":"lambda","slug":"lambda","permalink":"https://swtpumpkin.github.io/tags/lambda/"},{"name":"lambda@Edge","slug":"lambda-Edge","permalink":"https://swtpumpkin.github.io/tags/lambda-Edge/"},{"name":"cloudFront","slug":"cloudFront","permalink":"https://swtpumpkin.github.io/tags/cloudFront/"}]},{"title":"SSL Local Certificate","slug":"develop/SSL-certificate","date":"2019-02-08T00:00:00.000Z","updated":"2020-01-08T04:06:19.005Z","comments":true,"path":"develop/SSL-certificate/","link":"","permalink":"https://swtpumpkin.github.io/develop/SSL-certificate/","excerpt":"","text":"SSL Local Certificate개발을 하다보면 local 환경에서 SSL 인증서가 필요한 경우가 있습니다. facebook 같은 경우 OAuth 테스트를 하려고 하면 https를 사용해야만 callback을 받을 수 있도록 정책이 바뀌어 local 환경에서의 SSL 인증 발급이 더더욱 필요하게 되었습니다. 발급 방법1cd Desktop Desktop으로 이동합니다. 1mkdir cert cert라는 폴더를 생성합니다. 1cd cert cert 폴더로 이동합니다. openssl req -x509 -sha256 -nodes -newkey rsa:2048 -days 365 -keyout localhost.key -out localhost.crt 코드를 이용하여 localhost.key key 파일과 localhost.crt crt 파일을 생성하겠습니다. 1openssl req -x509 -sha256 -nodes -newkey rsa:2048 -days 365 -keyout localhost.key -out localhost.crt 위 코드를 실행하면 대화형으로 몇가지 기입할 내용이 있습니다. 1Country Name (2 letter code) []: 82 Country Name의 코드를 입력하라고 나오는데 한국의 코드는 82번 이므로 82를 입력하겠습니다. 1State or Province Name (full name) []: State or Province Name은 Seoul을 입력하겠습니다. 1Locality Name (eg, city) []: Locality Name은 Secho를 입력하겠습니다. 1Organization Name (eg, company) []: Organization Name은 swtpumpkin을 입력하겠습니다. 1Organizational Unit Name (eg, section) []: Organizational Unit Name은 develop을 입력하겠습니다. 1Common Name (eg, fully qualified host name) []: Common Name은 swtpumpkin을 입력하겠습니다. 1Email Address []: Email Address은 swtpumpkin90@gmail.com을 입력하겠습니다.모든 질문에 답변을 하게되면 인증서가 생성됩니다.질문에 답변은 각각의 사용자마다의 정보를 기입하면 됩니다.아래와 같이 순서대로 따라하면 ls로 파일 리스트를 볼 수 있는데 파일이 잘 생성된 걸 볼 수 있습니다.인증서 발급이 완료되면 https로 redirect되는 코드에서 에러가 발생하지 않습니다.","categories":[{"name":"develop","slug":"develop","permalink":"https://swtpumpkin.github.io/categories/develop/"}],"tags":[{"name":"develop","slug":"develop","permalink":"https://swtpumpkin.github.io/tags/develop/"},{"name":"localhost","slug":"localhost","permalink":"https://swtpumpkin.github.io/tags/localhost/"},{"name":"SSL","slug":"SSL","permalink":"https://swtpumpkin.github.io/tags/SSL/"},{"name":"certificate","slug":"certificate","permalink":"https://swtpumpkin.github.io/tags/certificate/"}]},{"title":"Cannot find declaration to go to (webstorm)","slug":"develop/Cannot_find_declaration_to_go_to(webstorm)","date":"2019-02-07T23:00:00.000Z","updated":"2020-01-08T04:06:19.005Z","comments":true,"path":"develop/Cannot_find_declaration_to_go_to(webstorm)/","link":"","permalink":"https://swtpumpkin.github.io/develop/Cannot_find_declaration_to_go_to(webstorm)/","excerpt":"","text":"Cannot find declaration to go to코딩을 하다보면 정적인 경로로 코드를 불러오는 경우가 있습니다. 이때 command를 사용하여 코드를 누르게 되면 이동 할 수 있는 기능이 webstrom에 있는데, 갑자기 위와 같이 Cannot find declaration to go to에러가 발생하는 경우가 있습니다. 이러한 경우 해결방법을 포스팅해보도록 하겠습니다. 해결방법위 사진과 같이 코드의 root 폴더에 우클릭 후 Mark Directory as에서 Resource Root로 선택하시면 폴더 내 모든 코드에서 정적으로 불러와도 코드 내 이동이 가능합니다.","categories":[{"name":"develop","slug":"develop","permalink":"https://swtpumpkin.github.io/categories/develop/"}],"tags":[{"name":"develop","slug":"develop","permalink":"https://swtpumpkin.github.io/tags/develop/"},{"name":"webstorm","slug":"webstorm","permalink":"https://swtpumpkin.github.io/tags/webstorm/"},{"name":"jetbrains","slug":"jetbrains","permalink":"https://swtpumpkin.github.io/tags/jetbrains/"}]},{"title":"Mojave OS 업데이트 후 git 에러 해결 방법","slug":"develop/mojave-update-git-error","date":"2018-09-25T23:00:00.000Z","updated":"2020-01-08T04:06:19.005Z","comments":true,"path":"develop/mojave-update-git-error/","link":"","permalink":"https://swtpumpkin.github.io/develop/mojave-update-git-error/","excerpt":"","text":"Mac OS 업데이트 이후 git 에러매번 OS를 업데이트 하면 개발툴들에서 에러가 발생합니다. Sierra에서 High Sierra로 업데이트 할 땐 workbench에서 에러가 발생하였는데 이번엔 git이네요! xcrun: error: invalid active developer path (/Library/Developer/CommandLineTools), missing xcrun at: /Library/Developer/CommandLineTools/usr/bin/xcrun 이러한 에러가 발생하는 분들을 위해 포스팅 하겠습니다. 위 에러는 Xcode Command Line Tools의 의존성 이슈가 발생하여 에러가 나는 것이였습니다. 해결방법12git --versionxcrun: error: invalid active developer path (&#x2F;Library&#x2F;Developer&#x2F;CommandLineTools), missing xcrun at: &#x2F;Library&#x2F;Developer&#x2F;CommandLineTools&#x2F;usr&#x2F;bin&#x2F;xcrun git의 버전을 검색하면 위와 같이 에러가 발생합니다. XCode를 재 설치하면 해결되는 간단한 에러입니다. 1xcode-select --install 위 코드를 터미널에서 실행하여 재설치 해줍니다. 12xcode-select -vxcode-select version 2354. 설치 후 Mojave OS에서의 xcode 버전은 2354로 확인됩니다. 12git --versiongit version 2.17.1 (Apple Git-112) XCode를 재설치 후 git의 버전을 확인해보면 버전이 확인됩니다. 이로써 git에러는 해결되었습니다.","categories":[{"name":"develop","slug":"develop","permalink":"https://swtpumpkin.github.io/categories/develop/"}],"tags":[{"name":"develop","slug":"develop","permalink":"https://swtpumpkin.github.io/tags/develop/"},{"name":"mac","slug":"mac","permalink":"https://swtpumpkin.github.io/tags/mac/"},{"name":"mojave","slug":"mojave","permalink":"https://swtpumpkin.github.io/tags/mojave/"},{"name":"git","slug":"git","permalink":"https://swtpumpkin.github.io/tags/git/"}]},{"title":"Caddy","slug":"backend/aws/caddy","date":"2018-08-20T23:00:00.000Z","updated":"2020-01-08T04:06:19.001Z","comments":true,"path":"backend/aws/caddy/","link":"","permalink":"https://swtpumpkin.github.io/backend/aws/caddy/","excerpt":"","text":"CaddyCaddy는 리버스 프록시 기능을 내장하고 있는 웹 서버로, 인증서 등록 및 설치를 자동으로 해주기 때문에 굉장히 편하게 HTTPS 웹 서버를 운영할 수 있습니다. 또한 Caddyfile이라는 간단한 문법의 설정 파일을 통해 웹 서버를 설정하도록 하고 있습니다. 외부에서 들어오는 요청을 80(http)번 포트 또는 443(https)번 포트로 들어오게 되는데 80번 포트로 들어온 요청은 443번 포트로 리다이렉트 해줍니다. 하나의 서버를 사용하는데 여러 노드서버가 있다면 내부 포트를 다르게 하여 Caddy를 실행해주면 서버비용을 줄일 수 있습니다. Caddy 설치 및 설정방법1curl https://getcaddy.com | bash -s personal 위 코드를 서버에서 실행하여 Caddy를 설치합니다. 개인 포트폴리오 용으로 설치하시는 분들은 꼭 뒤에 personal을 붙여야합니다.personal을 붙이지 않는다면 위 사진과 같이 라이센스를 설정하라는 에러가 뜨면서 설치가 되지 않습니다.위 사진과 같이 성공했다는 메세지가 나타나야 Caddy설치가 완료된 것입니다.Caddy는 Caddyfile이라는 파일을 통해 Caddy를 설정해줍니다. 설정시 transparent를 꼭 사용해야 합니다. 1234567891011121314151617# https://example.com URI로 들어온 요청을 http://localhost:3000 서버에 연결시킴# http://example.com 쪽으로 들어온 요청은 https로 리다이렉트example.com &#123; proxy / localhost:3000 &#123; # 리버스 프록시에 요청이 어떤 형태(IP, 프로토콜)로 왔는지를 # 뒤쪽 서버에 별도의 헤더를 통해 전달 transparent &#125;&#125;chat.example.com &#123; proxy / localhost:4000 &#123; transparent # 웹소켓 요청도 전달하기 websocket &#125;&#125; 위 파일과 같이 설정파일을 작성합니다. 1nohup caddy &amp; 위 코드를 실행하면 터미널을 나가도 웹주소는 실행이 됩니다.","categories":[{"name":"backend","slug":"backend","permalink":"https://swtpumpkin.github.io/categories/backend/"},{"name":"AWS","slug":"backend/AWS","permalink":"https://swtpumpkin.github.io/categories/backend/AWS/"}],"tags":[{"name":"aws","slug":"aws","permalink":"https://swtpumpkin.github.io/tags/aws/"},{"name":"ubuntu","slug":"ubuntu","permalink":"https://swtpumpkin.github.io/tags/ubuntu/"},{"name":"caddy","slug":"caddy","permalink":"https://swtpumpkin.github.io/tags/caddy/"}]},{"title":"caching_sha2_password 에러 해결 방법","slug":"backend/mysql/mysqlCachingSha2PasswordError","date":"2018-07-08T23:00:00.000Z","updated":"2020-01-08T04:06:19.002Z","comments":true,"path":"backend/mysql/mysqlCachingSha2PasswordError/","link":"","permalink":"https://swtpumpkin.github.io/backend/mysql/mysqlCachingSha2PasswordError/","excerpt":"","text":"caching_sha2_password 에러 해결 방법!워크벤치에서 mac root에 설치한 mysql을 연결하려고 하니 caching_sha2_password에러가 발생하였습니다. 에러 해결방법을 포스팅 하겠습니다. 해결방법1mysql -u root -p 위 코드를 터미널에서 실행합니다. 비밀번호를 입력하게 되면 mysql&gt;가 나타납니다. 1ALTER USER &#39;root&#39;@&#39;localhost&#39; IDENTIFIED WITH mysql_native_password BY &#39;your mySQL initial password&#39;; mySQL설정시 초기에 비밀번호 설정한 값을 your mySQL initial password부분에 대치하여 비밀번호를 입력합니다.위와 같이 쿼리 설정이 완료되면 워크벤치에서 다시 Test Connection을 시도합니다.위와 같이 로컬에서 에러가 발생하지 않고 잘 연결 됩니다.","categories":[{"name":"backend","slug":"backend","permalink":"https://swtpumpkin.github.io/categories/backend/"},{"name":"mySQL","slug":"backend/mySQL","permalink":"https://swtpumpkin.github.io/categories/backend/mySQL/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"https://swtpumpkin.github.io/tags/mysql/"},{"name":"caching_sha2_password","slug":"caching-sha2-password","permalink":"https://swtpumpkin.github.io/tags/caching-sha2-password/"}]},{"title":"ec2의 ubuntu에서 MySQL 설치하기","slug":"backend/aws/ec2UbuntuMySQL","date":"2018-07-05T03:00:00.000Z","updated":"2020-01-08T04:06:19.001Z","comments":true,"path":"backend/aws/ec2UbuntuMySQL/","link":"","permalink":"https://swtpumpkin.github.io/backend/aws/ec2UbuntuMySQL/","excerpt":"","text":"ec2의 ubuntu에서 MySQL 설치하기!MySQL 설치방법1sudo apt-get upgrade 위 코드를 실행하여 apt-get을 업데이트 합니다. 1sudo apt install mysql-server mysql-server-5.7 위 코드를 실행하여 mysql-server를 설치합니다. (설치하는 MySQL버전은 5.7 입니다.) 1Do you want to continue? [Y&#x2F;n] sudo apt install mysql-server mysql-server-5.7코드를 실행하게 되면 위와 같이 계속 진행할건지 여부를 묻습니다. Y를 누르고 엔터를 누르게 되면 아래와 같은 화면이 뜹니다.위와 같은 화면이 활성화 되면 비밀번호를 입력합니다.같은 비밀번호를 두 번 입력하게 되면 위와 같이 설치 상태가 나오고 100%가 되면 설치가 완료됩니다. 1mysql -uroot -p 위 코드를 입력하고 비밀번호를 입력하게 되면 아래와 같은 화면이 나타나게 됩니다.mysql&gt; 입력창이 나타나야 설치가 잘 된 것 입니다. mysql&gt;에서 나가려면 exit를 입력하면 됩니다.","categories":[{"name":"backend","slug":"backend","permalink":"https://swtpumpkin.github.io/categories/backend/"},{"name":"AWS","slug":"backend/AWS","permalink":"https://swtpumpkin.github.io/categories/backend/AWS/"}],"tags":[{"name":"aws","slug":"aws","permalink":"https://swtpumpkin.github.io/tags/aws/"},{"name":"ubuntu","slug":"ubuntu","permalink":"https://swtpumpkin.github.io/tags/ubuntu/"},{"name":"ec2","slug":"ec2","permalink":"https://swtpumpkin.github.io/tags/ec2/"},{"name":"mysql","slug":"mysql","permalink":"https://swtpumpkin.github.io/tags/mysql/"}]},{"title":"구글 웹마스터 도구 crawling error","slug":"develop/google/crawlingError","date":"2018-05-01T23:00:00.000Z","updated":"2020-01-08T04:06:19.005Z","comments":true,"path":"develop/google/crawlingError/","link":"","permalink":"https://swtpumpkin.github.io/develop/google/crawlingError/","excerpt":"","text":"구글 웹마스터 도구 크롤링 오류구글 웹마스터도구에 가면 크롤링 탭 안에 크롤링 오류 탭이 있습니다.위와 같이 크롤링 오류가 계속 증가하고 있습니다. 얼마 전 블로그파일을 백업하지 않고 모두 삭제했던적이 있습니다. 새로 블로그를 개편하면서 거의 모든 주소가 바뀌었습니다. 하지만 구글 크롤링 봇?은 기존 주소를 색인해두었기 때문에 이전 주소를 크롤링하면서 404에러를 발생하고 있었습니다. 주소가 없어져 404에러가 발생하는 주소를 삭제 요청해보겠습니다. 해결방법크롤링 탭 안에 크롤링 오류 탭에서 왼쪽 아래부분을 보면 다운로드버튼이 있습니다. 다운로드버튼을 클릭하면 아래와 같이 팝업이 생성됩니다.Google 문서를 선택하고 확인을 클릭합니다.구글 스프레드 시트로 내 홈페이지에서 에러가 발생하는 모든 링크를 다운받을 수 있습니다. 크롤링 에러가 나는 사이트는 현재는 모두 사용하지 않는 페이지이므로 삭제요청을 해야합니다.웹마스터 도구의 사이드바에서 Google 색인탭을 선택 후 URL 삭제탭을 선택합니다.일시적으로 숨기기버튼을 클릭합니다.숨기려는 사이트 URL을 입력합니다. 이전에 구글 스프레드 시트로 받았던 에러가 발생하는 URL을 복사 -&gt; 붙여넣기 합니다. 그리고 계속버튼을 클릭합니다.첫 번째 항목인 페이지를 검색결과에서 일시적으로 숨기고 캐시에서 삭제하기를 선택 후 요청 제출을 클릭합니다.제출을 완료하면 위와같이 제거 요청이 됩니다. 시간이 지나면 신청한 페이지는 크롤링 되지않고 검색에서도 삭제됩니다.크롤링 탭 안에 크롤링 오류에서 다운로드 버튼 아래부분 체크박스에 삭제 요청된 페이지를 선택하고 수정됨으로 표시버튼을 클릭하여 수정 요청을 하면 크롤링 오류 해결이 될 것 입니다.","categories":[{"name":"develop","slug":"develop","permalink":"https://swtpumpkin.github.io/categories/develop/"},{"name":"google","slug":"develop/google","permalink":"https://swtpumpkin.github.io/categories/develop/google/"}],"tags":[{"name":"error","slug":"error","permalink":"https://swtpumpkin.github.io/tags/error/"},{"name":"google","slug":"google","permalink":"https://swtpumpkin.github.io/tags/google/"},{"name":"webmaster","slug":"webmaster","permalink":"https://swtpumpkin.github.io/tags/webmaster/"},{"name":"crawling","slug":"crawling","permalink":"https://swtpumpkin.github.io/tags/crawling/"},{"name":"크롤링","slug":"크롤링","permalink":"https://swtpumpkin.github.io/tags/%ED%81%AC%EB%A1%A4%EB%A7%81/"},{"name":"크롤링 오류","slug":"크롤링-오류","permalink":"https://swtpumpkin.github.io/tags/%ED%81%AC%EB%A1%A4%EB%A7%81-%EC%98%A4%EB%A5%98/"}]},{"title":"구글 웹마스터 도구 Post Sitemap Error","slug":"develop/google/postSitemapError","date":"2018-04-21T23:00:00.000Z","updated":"2020-01-08T04:06:19.005Z","comments":true,"path":"develop/google/postSitemapError/","link":"","permalink":"https://swtpumpkin.github.io/develop/google/postSitemapError/","excerpt":"","text":"구글 웹마스터 도구(Search Console)에 sitemap error구글 웹마스터 도구에 sitemap을 추가하여 사용하고 있는데 블로그를 전체 정리하며 파일명을 바꾸게 되었습니다. 파일명을 변경하고 나서 sitemap을 다시 등록하니 위와같이 에러가 발생하였습니다. 에러 해결 방법.에러가 발생하면 메일로 위와 같은 메일이 오게 됩니다. 또는 에러메세지를 Search Console에서 확인 가능합니다. Search Console을 사용하여 색인 생성 범위 문제 해결하기를 클릭하여 문제를 확인합니다.문제해결하기 탭으로 이동하게 되면 어디에서 문제가 발생하였는지 알려줍니다. 위 사진에서 171번행이 문제가 있다고 나타납니다. public - post-sitemap.xml파일을 실행하여 171번행을 확인합니다.저의 경우 위와 같이 주소에 &amp;가 들어가면 안되는데 주소문법에 맞지 않는 sitemap이 생성되어 있었습니다.md파일을 확인해 보니 파일명에 &amp;가 들어있어 주소변환하는데 &amp;가 들어갔습니다. 따라서 &amp;를 and로 변환하고 hexo g -d를 실행하여 재배포로 해결되었습니다.","categories":[{"name":"develop","slug":"develop","permalink":"https://swtpumpkin.github.io/categories/develop/"},{"name":"google","slug":"develop/google","permalink":"https://swtpumpkin.github.io/categories/develop/google/"}],"tags":[{"name":"error","slug":"error","permalink":"https://swtpumpkin.github.io/tags/error/"},{"name":"google","slug":"google","permalink":"https://swtpumpkin.github.io/tags/google/"},{"name":"webmaster","slug":"webmaster","permalink":"https://swtpumpkin.github.io/tags/webmaster/"},{"name":"postsitemap","slug":"postsitemap","permalink":"https://swtpumpkin.github.io/tags/postsitemap/"}]},{"title":"mac backquote 설정하기 ( ₩ => ` )","slug":"develop/mac-backquote","date":"2018-04-03T23:00:00.000Z","updated":"2020-01-08T04:06:19.005Z","comments":true,"path":"develop/mac-backquote/","link":"","permalink":"https://swtpumpkin.github.io/develop/mac-backquote/","excerpt":"","text":"backquote?mac OS 중 Sierra 업데이트 이후 한글 상태에서 백쿼트( ` )키를 누르게 되면 원화(₩)가 입력되는 현상이 나타났습니다. 마크다운을 사용하는 개발자 또는 마크다운으로 문서작성하는 사람들에게는 매우 불편합니다. 설정방법1cd ~&#x2F;Library&#x2F; Library폴더로 이동합니다. 1mkdir KeyBindings KeyBindings폴더를 생성합니다. 1cd KeyBindings KeyBindings폴더로 이동합니다. 1vi DefaultkeyBinding.dict vi에디터를 이용하여 DefaultkeyBinding.dict파일을 생성 후 에디터를 실행합니다. 123&#123; &quot;₩&quot; &#x3D; (&quot;insertText:&quot;, &quot;&#96;&quot;);&#125; 위 코드를 작성 후 :wq를 이용하여 저장 후 에디터를 닫습니다.저장 후 맥을 재시작 하면 설정이 완료됩니다.","categories":[{"name":"develop","slug":"develop","permalink":"https://swtpumpkin.github.io/categories/develop/"}],"tags":[{"name":"develop","slug":"develop","permalink":"https://swtpumpkin.github.io/tags/develop/"},{"name":"mac","slug":"mac","permalink":"https://swtpumpkin.github.io/tags/mac/"},{"name":"백쿼트","slug":"백쿼트","permalink":"https://swtpumpkin.github.io/tags/%EB%B0%B1%EC%BF%BC%ED%8A%B8/"},{"name":"backquote","slug":"backquote","permalink":"https://swtpumpkin.github.io/tags/backquote/"},{"name":"원화표시","slug":"원화표시","permalink":"https://swtpumpkin.github.io/tags/%EC%9B%90%ED%99%94%ED%91%9C%EC%8B%9C/"},{"name":"₩","slug":"₩","permalink":"https://swtpumpkin.github.io/tags/%E2%82%A9/"}]},{"title":"ec2에 Redis 설치하기","slug":"backend/aws/ec2UbuntuRedis","date":"2018-03-24T23:00:00.000Z","updated":"2020-01-08T04:06:19.001Z","comments":true,"path":"backend/aws/ec2UbuntuRedis/","link":"","permalink":"https://swtpumpkin.github.io/backend/aws/ec2UbuntuRedis/","excerpt":"","text":"Redis설치 방법ubuntu 16.04버전에 설치하는 방법을 설명드리겠습니다. 1sudo apt-get install redis-server apt-get로 한번에 Redis 서버를 설치 할 수 있습니다. 1redis-server 위 코드를 통해 서버를 실행하면 아래와 같이 서버가 실행됩니다.","categories":[{"name":"backend","slug":"backend","permalink":"https://swtpumpkin.github.io/categories/backend/"},{"name":"AWS","slug":"backend/AWS","permalink":"https://swtpumpkin.github.io/categories/backend/AWS/"}],"tags":[{"name":"redis","slug":"redis","permalink":"https://swtpumpkin.github.io/tags/redis/"},{"name":"aws","slug":"aws","permalink":"https://swtpumpkin.github.io/tags/aws/"},{"name":"ec2","slug":"ec2","permalink":"https://swtpumpkin.github.io/tags/ec2/"},{"name":"ubuntu 16.04","slug":"ubuntu-16-04","permalink":"https://swtpumpkin.github.io/tags/ubuntu-16-04/"}]},{"title":"mongoDB 설치","slug":"backend/mongoDB/mongoDBInstall","date":"2018-03-23T23:00:00.000Z","updated":"2020-01-08T04:06:19.002Z","comments":true,"path":"backend/mongoDB/mongoDBInstall/","link":"","permalink":"https://swtpumpkin.github.io/backend/mongoDB/mongoDBInstall/","excerpt":"","text":"mongoDB?NoSQL 데이터베이스로 분류되는 도큐먼트 지향(문서 지향) 데이터베이스 시스템입니다. 설치 방법우선적으로 brew가 설치되어야 합니다. brew의 설치방법은 여기를 참조하시기 바랍니다. 1brew tap mongodb&#x2F;brew 패키지 저장소에 mongodb/brew를 추가합니다. 1brew install mongodb-community@4.2 brew를 이용하여 MongoDB Community Edition 4.2를 설치합니다. 1brew services start mongodb-community@4.2brew를 이용하여 mongoDB 4.2를 실행합니다. 1mongod --config &#x2F;usr&#x2F;local&#x2F;etc&#x2F;mongod.conf --fork background에서 자동 실행 할 수 있게 설정을 등록합니다.","categories":[{"name":"backend","slug":"backend","permalink":"https://swtpumpkin.github.io/categories/backend/"},{"name":"mongoDB","slug":"backend/mongoDB","permalink":"https://swtpumpkin.github.io/categories/backend/mongoDB/"}],"tags":[{"name":"develop","slug":"develop","permalink":"https://swtpumpkin.github.io/tags/develop/"},{"name":"brew","slug":"brew","permalink":"https://swtpumpkin.github.io/tags/brew/"},{"name":"mac","slug":"mac","permalink":"https://swtpumpkin.github.io/tags/mac/"},{"name":"install","slug":"install","permalink":"https://swtpumpkin.github.io/tags/install/"},{"name":"mongodb","slug":"mongodb","permalink":"https://swtpumpkin.github.io/tags/mongodb/"}]},{"title":"zsh-autosuggestions","slug":"develop/zsh-autosuggestions","date":"2018-03-17T23:00:00.000Z","updated":"2020-01-08T04:06:19.006Z","comments":true,"path":"develop/zsh-autosuggestions/","link":"","permalink":"https://swtpumpkin.github.io/develop/zsh-autosuggestions/","excerpt":"","text":"zsh-autosuggestionszsh-autosuggestions를 설치하게 되면 터미널에서 과거에 실행하였던 명령어를 자동완성 할 수 있습니다. 설치방법1git clone https:&#x2F;&#x2F;github.com&#x2F;zsh-users&#x2F;zsh-autosuggestions ~&#x2F;.zsh&#x2F;zsh-autosuggestions 터미널에서 zsh-autosuggestions을 설치합니다. ~/.zsh/zsh-autosuggestions를 추가하게 되면 .zsh파일 안에 zsh-autosuggestions폴더로 설치되게 됩니다. 1open ~&#x2F;.zshrc 위 코드를 실행하여 텍스트에디터로 .zshrc을 실행합니다. 12# zsh-autosuggestionssource ~&#x2F;.zsh&#x2F;zsh-autosuggestions&#x2F;zsh-autosuggestions.zsh 위 코드를 텍스트에디터를 통해 실행한 .zshrc파일 아래쪽 아무곳에나 추가를 합니다.위와 같이 open만 터미널에 작성해도 과거에 작성하였던 open ~/.zshrc이 나타나게 되고 오른쪽 방향키를 누르게 되면 자동 완성 됩니다.","categories":[{"name":"develop","slug":"develop","permalink":"https://swtpumpkin.github.io/categories/develop/"}],"tags":[{"name":"develop","slug":"develop","permalink":"https://swtpumpkin.github.io/tags/develop/"},{"name":"mac","slug":"mac","permalink":"https://swtpumpkin.github.io/tags/mac/"},{"name":"개발환경설정","slug":"개발환경설정","permalink":"https://swtpumpkin.github.io/tags/%EA%B0%9C%EB%B0%9C%ED%99%98%EA%B2%BD%EC%84%A4%EC%A0%95/"},{"name":"iterm2","slug":"iterm2","permalink":"https://swtpumpkin.github.io/tags/iterm2/"}]},{"title":"terminal node 버전 표시","slug":"develop/terminal-mark-node","date":"2018-03-10T23:00:00.000Z","updated":"2020-01-08T04:06:19.006Z","comments":true,"path":"develop/terminal-mark-node/","link":"","permalink":"https://swtpumpkin.github.io/develop/terminal-mark-node/","excerpt":"","text":"노드 버전 표시처음 테마를 설치하게 되면 노드 버전은 보이지 않습니다. 따라서 설정을 추가해야 터미널에 현재 node버전을 터미널에서 확인 할 수 있습니다. 설정 방법1open ~&#x2F;.zshrc 위 코드를 실행하여 텍스트에디터로 .zshrc을 실행합니다. 123# nvm confexport NVM_DIR&#x3D;&quot;$HOME&#x2F;.nvm&quot;[ -s &quot;$NVM_DIR&#x2F;nvm.sh&quot; ] &amp;&amp; . &quot;$NVM_DIR&#x2F;nvm.sh&quot; # This loads nvm 파일 아래 부분에 위 코드를 추가합니다. 저장 후 터미널을 재시작하게 되면 아래와 같이 node 버전이 표시 됩니다.현재 설치된 노드 버전이 v10.0.0으로 설치되어 위와 같이 v10.0.0으로 표시됐습니다.","categories":[{"name":"develop","slug":"develop","permalink":"https://swtpumpkin.github.io/categories/develop/"}],"tags":[{"name":"develop","slug":"develop","permalink":"https://swtpumpkin.github.io/tags/develop/"},{"name":"mac","slug":"mac","permalink":"https://swtpumpkin.github.io/tags/mac/"},{"name":"개발환경설정","slug":"개발환경설정","permalink":"https://swtpumpkin.github.io/tags/%EA%B0%9C%EB%B0%9C%ED%99%98%EA%B2%BD%EC%84%A4%EC%A0%95/"},{"name":"iterm2","slug":"iterm2","permalink":"https://swtpumpkin.github.io/tags/iterm2/"},{"name":"terminal","slug":"terminal","permalink":"https://swtpumpkin.github.io/tags/terminal/"},{"name":"node","slug":"node","permalink":"https://swtpumpkin.github.io/tags/node/"},{"name":"version","slug":"version","permalink":"https://swtpumpkin.github.io/tags/version/"}]},{"title":"터미널 name space 설정","slug":"develop/name-space","date":"2018-03-03T23:00:00.000Z","updated":"2020-01-08T04:06:19.006Z","comments":true,"path":"develop/name-space/","link":"","permalink":"https://swtpumpkin.github.io/develop/name-space/","excerpt":"","text":"name space터미널을 실행하면 이름 영역이 너무 길어 불편한 경우가 있습니다. 따라서 이름 영역을 이름만 보일 수 있도록 설정해보도록 하겠습니다. 설정 방법1open ~&#x2F;.zshrc 위 코드를 실행하여 텍스트에디터로 .zshrc을 실행합니다. 123456# Remove display nameprompt_context() &#123; if [[ &quot;$USER&quot; !&#x3D; &quot;$DEFAULT_USER&quot; || -n &quot;$SSH_CLIENT&quot; ]]; then prompt_segment black default &quot;%(!.%&#123;%F&#123;yellow&#125;%&#125;.)$USER&quot; fi&#125; 에디터 아랫쪽 아무곳에 위 코드를 추가합니다. # 뒤에 문자열은 주석 처리 되므로 아래코드가 무엇을 의미하는지 구분짓는 코드를 추가합니다. 텍스트 에디터를 저장하고 터미널을 재실행해줍니다.재실행해주면 위와 같이 내 이름만 나오게 됩니다.위와 같이 아무 이름을 표시하길 원하지 않는다면 아래와 같이 중괄호 내용을 모두 삭제 후 재실행해주시면 됩니다. 1prompt_context() &#123;&#125;","categories":[{"name":"develop","slug":"develop","permalink":"https://swtpumpkin.github.io/categories/develop/"}],"tags":[{"name":"develop","slug":"develop","permalink":"https://swtpumpkin.github.io/tags/develop/"},{"name":"mac","slug":"mac","permalink":"https://swtpumpkin.github.io/tags/mac/"},{"name":"개발환경설정","slug":"개발환경설정","permalink":"https://swtpumpkin.github.io/tags/%EA%B0%9C%EB%B0%9C%ED%99%98%EA%B2%BD%EC%84%A4%EC%A0%95/"},{"name":"iterm2","slug":"iterm2","permalink":"https://swtpumpkin.github.io/tags/iterm2/"}]},{"title":"bullet-train 테마","slug":"develop/bullet-train-theme","date":"2018-03-02T23:00:00.000Z","updated":"2020-01-08T04:06:19.005Z","comments":true,"path":"develop/bullet-train-theme/","link":"","permalink":"https://swtpumpkin.github.io/develop/bullet-train-theme/","excerpt":"","text":"bullet-train 테마bullet-train테마를 사용하면 노드 버전과 깃 상태를 알 수 있어 노드 개발자라면 bullet-train 사용을 추천합니다. 설치방법1cd ~&#x2F;.oh-my-zsh&#x2F;themes 터미널에서 위 코드를 실행하여 .oh-my-zsh폴더 안 themes폴더로 이동합니다.여기로 이동하여 파일 내용 전체를 복사합니다. bullet-train.zsh-theme파일 내용이 있는 github 페이지입니다. 1vi bullet-train.zsh-theme 위 코드를 vi에디터를 이용하여 실행합니다. 위와 같이 실행하면 bullet-train.zsh-theme파일이 생성됩니다. 위 github페이지에서 복사한 파일을 실행된 에디터에 붙여넣기 합니다. 1open ~&#x2F;.zshrc 위 코드를 실행하여 .zshrc파일을 텍스트에디터로 실행합니다. 1ZSH_THEME&#x3D;&quot;bullet-train&quot; ZSH_THEME=&quot;&quot;안의 내용을 bullet-train로 변경합니다.터미널을 재시작하면 위와 같이 설치가 됩니다. 위와 같이 보이게 되면 설치가 완료 된 것 입니다. ?모양으로 텍스트가 깨지게 되는데 기본 텍스트가 지원하지 않는 폰트이기 때문에 hack이라는 폰트를 설치해야합니다.hack font페이지로 이동하여 font를 다운받습니다.hack font를 압축 해제 후 실행합니다.hack font를 서체 설치를 눌러 설치합니다.iterm2를 실행합니다. 실행 후 설정으로 이동합니다. command + ,를 누르게 되면 기본 설정으로 이동합니다. profile의 text로 이동 후 Change Font를 누릅니다.검색영역을 클릭하여 hack font를 찾습니다.hack font설정이 완료되면 아래와 같이 터미널이 깨지지 않습니다.","categories":[{"name":"develop","slug":"develop","permalink":"https://swtpumpkin.github.io/categories/develop/"}],"tags":[{"name":"develop","slug":"develop","permalink":"https://swtpumpkin.github.io/tags/develop/"},{"name":"개발환경설정","slug":"개발환경설정","permalink":"https://swtpumpkin.github.io/tags/%EA%B0%9C%EB%B0%9C%ED%99%98%EA%B2%BD%EC%84%A4%EC%A0%95/"},{"name":"oh-my-zsh","slug":"oh-my-zsh","permalink":"https://swtpumpkin.github.io/tags/oh-my-zsh/"},{"name":"theme","slug":"theme","permalink":"https://swtpumpkin.github.io/tags/theme/"},{"name":"bullet-train","slug":"bullet-train","permalink":"https://swtpumpkin.github.io/tags/bullet-train/"}]},{"title":"zsh-syntax-highlighting","slug":"develop/zsh-syntax-highlighting","date":"2018-02-28T23:00:00.000Z","updated":"2020-01-08T04:06:19.006Z","comments":true,"path":"develop/zsh-syntax-highlighting/","link":"","permalink":"https://swtpumpkin.github.io/develop/zsh-syntax-highlighting/","excerpt":"","text":"zsh-syntax-highlightingzsh-syntax-highlighting를 설치하게 되면 path에 등록된 명령어를 자동으로 highlight해주게 됩니다.위 사진은 적용 전 입니다.zsh-syntax-highlighting를 설치하게 되면 위 사진과 같이 명령어에 highlight됩니다. 설치방법1brew install zsh-syntax-highlighting brew를 통해 zsh-syntax-highlighting를 설치합니다. 1open ~&#x2F;.zshrc 위 명령어를 통해 .zshrc파일을 텍스트에디터로 실행합니다. 12# zsh-syntax-highlighting pathsource &#x2F;usr&#x2F;local&#x2F;share&#x2F;zsh-syntax-highlighting&#x2F;zsh-syntax-highlighting.zsh 위 두 줄을 에디터 아랫쪽 아무곳에나 추가합니다. zsh-syntax-highlighting path를 주석으로 추가하는 이유는 여러 파일 설치 시 어떤 이유로 코드를 추가하였는지 구분하기 위해 추가하였습니다. source /usr/local/share/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh줄만 추가해도 사용에는 문제가 없습니다.","categories":[{"name":"develop","slug":"develop","permalink":"https://swtpumpkin.github.io/categories/develop/"}],"tags":[{"name":"develop","slug":"develop","permalink":"https://swtpumpkin.github.io/tags/develop/"},{"name":"개발환경설정","slug":"개발환경설정","permalink":"https://swtpumpkin.github.io/tags/%EA%B0%9C%EB%B0%9C%ED%99%98%EA%B2%BD%EC%84%A4%EC%A0%95/"},{"name":"oh-my-zsh","slug":"oh-my-zsh","permalink":"https://swtpumpkin.github.io/tags/oh-my-zsh/"},{"name":"syntax","slug":"syntax","permalink":"https://swtpumpkin.github.io/tags/syntax/"},{"name":"highlight","slug":"highlight","permalink":"https://swtpumpkin.github.io/tags/highlight/"},{"name":"zsh","slug":"zsh","permalink":"https://swtpumpkin.github.io/tags/zsh/"}]},{"title":"oh-my-zsh","slug":"develop/oh-my-zsh","date":"2018-02-23T23:00:00.000Z","updated":"2020-01-08T04:06:19.006Z","comments":true,"path":"develop/oh-my-zsh/","link":"","permalink":"https://swtpumpkin.github.io/develop/oh-my-zsh/","excerpt":"","text":"oh-my-zsh?oh-my-zsh은 zsh의 설정을 관리하는 프레임워크입니다. oh-my-zsh을 통해 테마를 설정 할 수 있습니다. 설치방법1curl -L https:&#x2F;&#x2F;github.com&#x2F;robbyrussell&#x2F;oh-my-zsh&#x2F;raw&#x2F;master&#x2F;tools&#x2F;install.sh | sh curl을 이용하여 oh-my-zsh를 설치합니다. 1Changing shell for (username) 위와 같이 뜨고 비밀번호를 요구하는데 컴퓨터의 비밀번호를 입력해주시면 설치가 완료됩니다.위와 같이 아스키코드로 oh-my-zsh이라고 뜨면 설치가 완료 된 것 입니다.","categories":[{"name":"develop","slug":"develop","permalink":"https://swtpumpkin.github.io/categories/develop/"}],"tags":[{"name":"develop","slug":"develop","permalink":"https://swtpumpkin.github.io/tags/develop/"},{"name":"개발환경설정","slug":"개발환경설정","permalink":"https://swtpumpkin.github.io/tags/%EA%B0%9C%EB%B0%9C%ED%99%98%EA%B2%BD%EC%84%A4%EC%A0%95/"},{"name":"oh-my-zsh","slug":"oh-my-zsh","permalink":"https://swtpumpkin.github.io/tags/oh-my-zsh/"}]},{"title":"zsh","slug":"develop/zsh","date":"2018-02-17T23:00:00.000Z","updated":"2020-01-08T04:06:19.006Z","comments":true,"path":"develop/zsh/","link":"","permalink":"https://swtpumpkin.github.io/develop/zsh/","excerpt":"","text":"zsh?다양한 정보를 기반으로 tab을 이용하여 자동완성 기능을 사용 할 수 있습니다. 소문자 대문자를 잘 못 사용해도 자동완성을 해주기때문에 개발자라면 zsh을 사용하면 개발하는데 매우 편합니다. 설치방법1brew install zsh 우선 brew를 이용하여 zsh를 설치합니다. 1which zsh zsh가 어디에 설치되어있는지 위치를 파악합니다. 1&#x2F;usr&#x2F;local&#x2F;bin&#x2F;zsh 위와 같이 경로를 파악 후 아래코드를 실행합니다. 1vi &#x2F;etc&#x2F;shells vi에디터를 이용하여 shells파일에 시스템이 zsh를 인식할 수 있도록 합니다. 1chsh -s path&#x2F;zsh 위 명령어를 통해 새로운 zsh을 사용 할 수 있습니다. 터미널을 재시작해주면 zsh이 적용됩니다.","categories":[{"name":"develop","slug":"develop","permalink":"https://swtpumpkin.github.io/categories/develop/"}],"tags":[{"name":"develop","slug":"develop","permalink":"https://swtpumpkin.github.io/tags/develop/"},{"name":"개발환경설정","slug":"개발환경설정","permalink":"https://swtpumpkin.github.io/tags/%EA%B0%9C%EB%B0%9C%ED%99%98%EA%B2%BD%EC%84%A4%EC%A0%95/"},{"name":"zsh","slug":"zsh","permalink":"https://swtpumpkin.github.io/tags/zsh/"}]},{"title":"NumberFormat","slug":"backend/node/NumberFormat","date":"2018-02-16T23:00:00.000Z","updated":"2020-01-08T04:06:19.003Z","comments":true,"path":"backend/node/NumberFormat/","link":"","permalink":"https://swtpumpkin.github.io/backend/node/NumberFormat/","excerpt":"","text":"1,000 단위 구분하기화폐 단위처럼 숫자 3개마다 콤마(,)가 들어가게 되면 가독성이 좋아질 것입니다. 정규식을 사용하여 숫자 3개 사이마다 콤마를 추가하는 방법도 있지만 NumberFormat을 통해 쉽게 변환 할 수 있습니다. 사용 방법new Intl.NumberFormat().format()을 이용하면 간단하게 1000단위 콤마를 추가 할 수 있습니다. 12const a = 1000;new Intl.NumberFormat().format(a); new Intl.NumberFormat().format()함수의 format()안에 변환 할 숫자를 넣으면 1000단위 사이마다 콤마가 추가되어 출력됩니다.위 사진과 같이 node REPL에서 확인 가능합니다.","categories":[{"name":"backend","slug":"backend","permalink":"https://swtpumpkin.github.io/categories/backend/"},{"name":"node","slug":"backend/node","permalink":"https://swtpumpkin.github.io/categories/backend/node/"}],"tags":[{"name":"node","slug":"node","permalink":"https://swtpumpkin.github.io/tags/node/"},{"name":"javascript","slug":"javascript","permalink":"https://swtpumpkin.github.io/tags/javascript/"},{"name":"1000 단위","slug":"1000-단위","permalink":"https://swtpumpkin.github.io/tags/1000-%EB%8B%A8%EC%9C%84/"},{"name":"콤마","slug":"콤마","permalink":"https://swtpumpkin.github.io/tags/%EC%BD%A4%EB%A7%88/"},{"name":"NumberFormat","slug":"NumberFormat","permalink":"https://swtpumpkin.github.io/tags/NumberFormat/"}]},{"title":"ngrok","slug":"develop/ngrok","date":"2018-02-11T23:00:00.000Z","updated":"2020-01-08T04:06:19.006Z","comments":true,"path":"develop/ngrok/","link":"","permalink":"https://swtpumpkin.github.io/develop/ngrok/","excerpt":"","text":"ngrok?웹 개발을 하다보면 로컬에서 개발을 하다 모바일환경에서 보고싶을 때가 있습니다. 내 로컬네트워크 환경을 외부네트워크에서 접속하는 툴을 찾다보니 ngrok을 찾게 되었습니다. ngrok은 로컬호스트(http://localhost:3000)와 로컬네트워크(http://127.0.0.1:3000/)같은 로컬환경을 다른 외부환경에서 접속이 가능합니다. 설치방법ngrok의 홈페이지에 접속하여 운영체제에 맞는 파일을 다운로드합니다.다운로드 받은 압축파일을 압축해제합니다.바탕화면에 ngrok 파일을 옮깁니다. 1cd Desktop 터미널을 실행하여 바탕화면으로 이동합니다. 1mv ngrok &#x2F;usr&#x2F;local&#x2F;bin ngrok파일을 /usr/local/bin위치로 옮깁니다. 사용방법1ngrok http 5500 만약 로컬호스트 5500번 포트를 ngrok을 이용하여 외부접속을 하고싶다면 위 코드를 터미널에서 실행하면 됩니다.Forwarding 옆 주소를 통해 로컬과 동일한 환경을 외부에서 접속 할 수 있습니다.위 사진의 빨간 네모와 같이 옆 주소로 외부에서 접근하면 됩니다.하지만 ngork 무료로 사용하게 되면 동일한 웹 주소를 사용 할 수 없습니다.그래서 Session Expires에 보이는 것과 같이 8시간정도 사용 할 수 있습니다.만약 ngork에 띄운 외부 접근 주소를 종료하고 싶다면 Ctrl+C로 터미널을 종료 하면 됩니다.ngork을 종료하면 외부 접근 주소도 자동 삭제되게 됩니다.","categories":[{"name":"develop","slug":"develop","permalink":"https://swtpumpkin.github.io/categories/develop/"}],"tags":[{"name":"develop","slug":"develop","permalink":"https://swtpumpkin.github.io/tags/develop/"},{"name":"localhost","slug":"localhost","permalink":"https://swtpumpkin.github.io/tags/localhost/"},{"name":"mac","slug":"mac","permalink":"https://swtpumpkin.github.io/tags/mac/"},{"name":"개발환경설정","slug":"개발환경설정","permalink":"https://swtpumpkin.github.io/tags/%EA%B0%9C%EB%B0%9C%ED%99%98%EA%B2%BD%EC%84%A4%EC%A0%95/"},{"name":"ngrok","slug":"ngrok","permalink":"https://swtpumpkin.github.io/tags/ngrok/"}]},{"title":"forever","slug":"backend/node/forever","date":"2018-02-10T23:00:00.000Z","updated":"2020-01-08T04:06:19.003Z","comments":true,"path":"backend/node/forever/","link":"","permalink":"https://swtpumpkin.github.io/backend/node/forever/","excerpt":"","text":"forever?앱을 aws의 ec2에 올렸을 때 터미널을 종료하게 되면 실행중인 앱이 종료됩니다. 실행 중인 터미널을 종료하더라도 실행하려면 forever라는 모듈을 사용하여 터미널을 종료하더라도 앱을 계속 실행 할 수 있습니다. forever 사용 방법1npm install forever -g 위 코드를 터미널에서 실행하여 전역으로 forever모듈을 설치해줍니다. 1forever start src&#x2F;index.js 위 코드와 같이 forever start 다음에 실행 할 앱 경로를 설정합니다. 1forever list forever list를 실행하게 되면 아래처럼 실행됩니다. 1234forever listinfo: Forever processes runningdata: uid command script forever pid id \\logfile uptimedata: [0] v8MJ &#x2F;node src&#x2F;index.js 6636 6642 &#x2F;v8MJ.log 3:1:49:48.828 실행 중인 앱의 리스트를 확인 할 수 있습니다. 1forever restart 실행중인 앱을 재시작하려면 restart를 해주면 됩니다. 1forever stop forever로 실행하는 모든 앱을 종료하려면 stop하면 됩니다.","categories":[{"name":"backend","slug":"backend","permalink":"https://swtpumpkin.github.io/categories/backend/"},{"name":"node","slug":"backend/node","permalink":"https://swtpumpkin.github.io/categories/backend/node/"}],"tags":[{"name":"node","slug":"node","permalink":"https://swtpumpkin.github.io/tags/node/"},{"name":"javascript","slug":"javascript","permalink":"https://swtpumpkin.github.io/tags/javascript/"},{"name":"npm","slug":"npm","permalink":"https://swtpumpkin.github.io/tags/npm/"},{"name":"forever","slug":"forever","permalink":"https://swtpumpkin.github.io/tags/forever/"}]},{"title":"ec2 mongoDB와 robomongo 연결하기","slug":"backend/aws/ec2RoboMongo","date":"2018-02-07T23:00:00.000Z","updated":"2020-01-08T04:06:19.001Z","comments":true,"path":"backend/aws/ec2RoboMongo/","link":"","permalink":"https://swtpumpkin.github.io/backend/aws/ec2RoboMongo/","excerpt":"","text":"robomongorobomongo를 이용하여 aws의 ec2에서 생성한 mongoDB를 연결 할 수 있습니다. robomongo 설정 방법robomongo를 실행 후 두 개의 컴퓨터 모양 버튼을 누릅니다.create를 선택하여 새로운 연결설정을 생성합니다.New Connection의 칸에 robomongo에 표시 될 이름을 설정합니다.Use SSH tunnel을 체크합니다.SSH Address에는 aws ec2에서 IPv4 퍼블릭 IP의 주소를 입력합니다.SSH User Name에는 ubuntu를 입력합니다. (ubuntu 운영체제의 ec2입니다.)Private key에는 ec2의 .pem파일을 선택합니다.위에 값을 모두 입력하였으면 test버튼을 눌러 테스트를 진행합니다.위와 같이 모두 초록색 체크가 표시되면 값을 잘 입력한 것입니다. Save버튼을 눌러 저장합니다.","categories":[{"name":"backend","slug":"backend","permalink":"https://swtpumpkin.github.io/categories/backend/"},{"name":"AWS","slug":"backend/AWS","permalink":"https://swtpumpkin.github.io/categories/backend/AWS/"}],"tags":[{"name":"aws","slug":"aws","permalink":"https://swtpumpkin.github.io/tags/aws/"},{"name":"ec2","slug":"ec2","permalink":"https://swtpumpkin.github.io/tags/ec2/"},{"name":"mongo","slug":"mongo","permalink":"https://swtpumpkin.github.io/tags/mongo/"},{"name":"robomongo","slug":"robomongo","permalink":"https://swtpumpkin.github.io/tags/robomongo/"}]},{"title":"CRUD","slug":"CS/CRUD","date":"2018-01-29T04:00:00.000Z","updated":"2020-05-06T07:34:44.380Z","comments":true,"path":"CS/CRUD/","link":"","permalink":"https://swtpumpkin.github.io/CS/CRUD/","excerpt":"","text":"CRUD란?CRUD란 대부분의 컴퓨터 소프트웨어가 가지는 기본적인 데이터 처리 기능인 CREATE(생성), READ(읽기), UPDATE(갱신), DELETE(삭제)를 묶어서 일컫는 말입니다. 이 4가지 기능을 하지 못하는 소프트웨어는 완전하다고 할 수 없다는 말이 있을 정도로 기본적인 기능입니다. 주로 MySQL과 같은 DB에서 사용합니다. CRUD와 SQLCRUD와 SQL 문을 다음과 같이 비교 할 수 있습니다. 기능 이름 SQL 문 CREATE 생성 INSERT READ 읽기 SELECT UPDATE 갱신 UPDATE DELETE 삭제 DELETE CRUD 사용 예시연락처를 예시로 들어보도록 하겠습니다. 사용자는 새로운 연락처를 생성 할 수 있습니다. 사용자는 기존의 연락처들을 검색 할 수 있습니다. 사용자는 기존의 연락처 정보를 수정 할 수 있습니다. 사용자는 기존의 연락처를 삭제 할 수 있습니다. 위와 같이 생성, 읽기, 갱신, 삭제 네가지 기능이 모두 있다면 완전한 소프트웨어와 가깝다고 생각합니다. 하지만 이들 기능은 매우 기본적이기 때문에 따지고보면 완전하다고는 볼 수 없습니다.","categories":[{"name":"CS","slug":"CS","permalink":"https://swtpumpkin.github.io/categories/CS/"}],"tags":[{"name":"create","slug":"create","permalink":"https://swtpumpkin.github.io/tags/create/"},{"name":"read","slug":"read","permalink":"https://swtpumpkin.github.io/tags/read/"},{"name":"update","slug":"update","permalink":"https://swtpumpkin.github.io/tags/update/"},{"name":"delete","slug":"delete","permalink":"https://swtpumpkin.github.io/tags/delete/"}]},{"title":"Thread","slug":"CS/thread","date":"2018-01-29T03:00:00.000Z","updated":"2020-05-06T07:34:44.381Z","comments":true,"path":"CS/thread/","link":"","permalink":"https://swtpumpkin.github.io/CS/thread/","excerpt":"","text":"Threadthread은 실을 의미하는 단어입니다. 하지만 컴퓨터공학에서의 thread는 실과는 전혀 관련이 없습니다. thread의 사전적 의미는 다음과 같습니다. 어떠한 프로그램 내에서, 특히 프로세스 내에서 실행되는 흐름의 단위 이와같이 thread는 실과는 관련이 없지만 뭔가 흐름과 전혀 연관이 없진 않아 컴퓨터공학에서 thread라는 단어를 사용한 것 같습니다. Thread란?thread란 하나의 프로그램 내에서 여러 개의 실행 흐름을 두기 위한 모델입니다. thread는 컴퓨터 내부에서 존재하는 실행 코드로 프로세스는 단순한 껍데기이고 실제 작업은 thread가 담당합니다. 프로세스 생성 시 하나의 주thread가 생성되고 주thread가 종료되면 프로세스도 종료하게 됩니다. 프로세스는 CPU에 대한 사용권을 운영체제로부터 확보하고 CPU에게 처리사항을 요청하는데 이때 프로세스가 멀티 thread화 되어 있다면 요구사항을 분할하여 CPU에게 요청하고 다중 코어를 사용하는 CPU에게 분산하여 일을 처리할 수 있습니다.보통 CPU는 하나의 코어에서 한가지 작업을 처리 할 수 있습니다. 하지만 요즘 멀티코어의 CPU들을 많이 사용하기 때문에 여러 작업을 한번에 수행 할 수 있습니다. 인텔의 일부 CPU들은 하이퍼스레팅(HT)기술을 통해 1개의 코어당 2개의 thread를 갖습니다. 이를 통해 다중 작업을 효율적으로 사용 할 수 있습니다.현재 제 컴퓨터는 쿼드코어로 4개의 코어로 이루어져있지만 하이퍼스레팅(HT)기술로 8개의 thread를 볼 수 있습니다. 하지만 저전력 설계로 다중작업을 하지 않는다면 4개의 thread를 사용하는 것을 볼 수 있습니다.","categories":[{"name":"CS","slug":"CS","permalink":"https://swtpumpkin.github.io/categories/CS/"}],"tags":[{"name":"thread","slug":"thread","permalink":"https://swtpumpkin.github.io/tags/thread/"},{"name":"쓰레드","slug":"쓰레드","permalink":"https://swtpumpkin.github.io/tags/%EC%93%B0%EB%A0%88%EB%93%9C/"}]},{"title":"Process","slug":"CS/process","date":"2018-01-29T02:00:00.000Z","updated":"2020-05-06T07:34:44.381Z","comments":true,"path":"CS/process/","link":"","permalink":"https://swtpumpkin.github.io/CS/process/","excerpt":"","text":"Processprocess의 사전적 의미는 다음과 같습니다. 컴퓨터에서 연속적으로 실행되고 있는 컴퓨터 프로그램 프로세스를 얘기하는데 프로그램이라는 단어가 나옵니다. 여기서 프로세스와 프로그램은 다릅니다. 프로그램은 하드디스크에 저장된 코드를 의미하고 프로그램은 생명이 없습니다. 하지만 이러한 프로그램들이 명령어와 함께 메모리에 올라가게 되면 생명이 있는 프로세스가 됩니다. Process란?스케줄링의 대상이 되는 작업(task)이라는 용어와 같은 의미로 사용됩니다. 여러개의 프로세서를 사용하는 것을 멀티 프로세싱이라고 하며 같은 시간동안 여러개의 프로그램을 띄우는 시분할 방식을 멀티태스킹(multitasking)이라고 합니다.컴퓨터에서 여러개의 프로그램이 구동되는 것은 매우 어려운 일입니다. 유튜브로 노래를 켜고 카카오톡으로 대화를 하며 vscode로 코드를 작성하고 git으로 코드를 올리는 일을 한다는 것은 컴퓨터를 사용 할 때 프로세스가 어떻게 작동하는지는 모르지만 우리가 보는 환경은 평온하기만 합니다. 마치 오리가 물 위에 떠 있을 때 오리의 발은 쉴 새 없이 빠르게 움직이지만 오리는 평온하기만 한 것과 같습니다.여러개의 프로그램이 구동 될 때 커널 내에는 준비 큐, 대기 큐, 실행 큐 등의 자료구조들이 있으며 이것들을 이용하여 프로세스의 상태를 관리합니다. 여기서 큐는 이곳을 참고하시기 바랍니다.","categories":[{"name":"CS","slug":"CS","permalink":"https://swtpumpkin.github.io/categories/CS/"}],"tags":[{"name":"process","slug":"process","permalink":"https://swtpumpkin.github.io/tags/process/"},{"name":"프로세스","slug":"프로세스","permalink":"https://swtpumpkin.github.io/tags/%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4/"}]},{"title":"const","slug":"javascript/const","date":"2018-01-13T23:00:00.000Z","updated":"2020-06-22T04:09:02.005Z","comments":true,"path":"javascript/const/","link":"","permalink":"https://swtpumpkin.github.io/javascript/const/","excerpt":"","text":"const?const는 상수를 위해 사용합니다. 상수란 변하지 않는 값을 의미합니다. 사용법선언const는 선언 후 할당과 동시에 재할당 할 수 없습니다. 1const foo = 123; foo를 123으로 할당합니다. 1foo = 456; 이미 할당 된 foo에 456을 재할당하면 TypeError: Assignment to constant variable.에러가 발생합니다. 1const foo 이미 선언된 foo를 재선언하게되면 SyntaxError: Missing initializer in const declaration에러가 발생합니다.따라서 const는 한번 할당되면 재할당 할 수 없고, 다시 선언도 불가합니다. 한 번 값이 지정되고 변하지 않는 변수가 있다면 const를 사용하는 것이 좋습니다. 상수상수는 가독성과 유지보수를 위해 적극적으로 사용해야합니다. 123for(var a = 1; a &lt;= 10; a++)&#123; console.log(a);&#125; 위와 같이 1부터 10까지 출력하는 코드가 있다고 생각해봅니다. a라는 변수를 왜 사용했는지 10이라는 숫자는 무엇을 의미하는지 다른사람이 봤을 때 모르는 코드는 좋지 않은 코드입니다. 123456const maxNum = 10;const startNum = 1;let printNum = startNum;for(printNum; printNum &lt;= maxNum; printNum++)&#123; console.log(printNum);&#125; 위와 같이 상수가 무엇을 의미하는지 변수가 무엇을 의미하는지 네이밍을 잘 작성하게되면 가독성과 유지보수성을 대폭 향상 시킬 수 있습니다. 객체const는 객체에서도 사용 할 수 있습니다. 객체는 Property name과 property value로 이루어져 있습니다. const에서 객체를 사용할 때 Property name은 변경 할 수 없지만 property value는 변경 할 수 있습니다. 123456789const user = &#123; lastname: 'kim', firstname: 'jeongwon', birthday: &#123; year: 1990, month: 02, day: 09 &#125;&#125;; 위와 같이 user라는 상수를 선언합니다. 1user = &#123;&#125; 위와 같이 user를 {}객체로 초기화하게 되면 TypeError: Assignment to constant variable.에러가 발생합니다. 1user.lastname = 'jin'; 하지만 변수의 property value를 위와 같이 변경하게 되면 user의 property value는 변경됩니다.결론적으로 객체타입의 변수에는 const를 사용하는 것이 좋습니다. 객체의 Property name은 변경될 필요가 없습니다. 하지만 객체의 property value는 변경 될 수 있습니다. const를 사용하더라도 property value를 변경 할 수 있으므로 객체를 사용 할 때에는 const를 사용을 추천합니다.","categories":[{"name":"javascript","slug":"javascript","permalink":"https://swtpumpkin.github.io/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://swtpumpkin.github.io/tags/javascript/"},{"name":"const","slug":"const","permalink":"https://swtpumpkin.github.io/tags/const/"},{"name":"자바스크립트","slug":"자바스크립트","permalink":"https://swtpumpkin.github.io/tags/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/"},{"name":"상수","slug":"상수","permalink":"https://swtpumpkin.github.io/tags/%EC%83%81%EC%88%98/"}]},{"title":"create-react-app","slug":"frontend/react/createReactApp","date":"2018-01-13T23:00:00.000Z","updated":"2020-01-08T04:06:19.008Z","comments":true,"path":"frontend/react/createReactApp/","link":"","permalink":"https://swtpumpkin.github.io/frontend/react/createReactApp/","excerpt":"","text":"create-react-app이란?React앱을 간편하게 만들 수 있도록 자동으로 빌드해주는 모듈입니다. 이 패키지 모듈을 이용하면 Webpack이나 Babel을 설치하고 셋팅하는 복잡한 과정을 생략 할 수 있습니다. 설치방법1npm install -g create-react-app 위 코드를 터미널에서 실행하여 create-react-app모듈을 전역에 설치해줍니다. create-react-app을 전역에 설치하면 설치된 내 컴퓨터 환경 어디서든 사용이 가능합니다. 사용방법1create-react-app ReactApp(설치 할 프로젝트 이름) 위 코드를 터미널에서 실행합니다. create-react-app이 코드 뒤에 생성할 프로젝트 이름을 선택하면 프로젝트 이름으로 된 폴더가 생성되고 ReactApp이 생성됩니다. 프로젝트 생성 후 프로젝트 폴더로 이동합니다.1npm install 위 코드를 터미널에서 실행합니다. 위 코드를 실행하게 되면 package.json에 있는 모듈이 설치됩니다. create-react-app으로 ReactApp을 설치하게 되면 자동으로 노드모듈까지 설치되긴 합니다. 하지만 npm start시 오류가 난다면 node_modules폴더를 삭제 후 npm install하시기 바랍니다.1npm start 위 코드를 터미널에서 실행하여 ReactApp을 실행합니다. ReactApp을 실행하게되면 위와 같이 초기 ReactApp이 실행됩니다. 초기 포트는 3000번으로 이 포트도 변경 할 수 있습니다.","categories":[{"name":"frontend","slug":"frontend","permalink":"https://swtpumpkin.github.io/categories/frontend/"},{"name":"react","slug":"frontend/react","permalink":"https://swtpumpkin.github.io/categories/frontend/react/"}],"tags":[{"name":"create-react-app","slug":"create-react-app","permalink":"https://swtpumpkin.github.io/tags/create-react-app/"},{"name":"package","slug":"package","permalink":"https://swtpumpkin.github.io/tags/package/"},{"name":"react","slug":"react","permalink":"https://swtpumpkin.github.io/tags/react/"}]},{"title":"redis","slug":"develop/redis","date":"2018-01-01T23:00:00.000Z","updated":"2020-01-08T04:06:19.006Z","comments":true,"path":"develop/redis/","link":"","permalink":"https://swtpumpkin.github.io/develop/redis/","excerpt":"","text":"redis설치방법1brew install redis homebrew를 이용해서 redis를 설치합니다. 1redis-server redis-server를 실행하면 redis가 실행됩니다.실행이 되면 위와 같이 터미널에서 실행됩니다.","categories":[{"name":"develop","slug":"develop","permalink":"https://swtpumpkin.github.io/categories/develop/"}],"tags":[{"name":"develop","slug":"develop","permalink":"https://swtpumpkin.github.io/tags/develop/"},{"name":"mac","slug":"mac","permalink":"https://swtpumpkin.github.io/tags/mac/"},{"name":"개발환경설정","slug":"개발환경설정","permalink":"https://swtpumpkin.github.io/tags/%EA%B0%9C%EB%B0%9C%ED%99%98%EA%B2%BD%EC%84%A4%EC%A0%95/"},{"name":"redis","slug":"redis","permalink":"https://swtpumpkin.github.io/tags/redis/"}]},{"title":"aws를 이용하여 정적인 페이지 배포","slug":"backend/aws/awsStaticPage","date":"2017-12-26T23:00:00.000Z","updated":"2020-01-08T04:06:19.000Z","comments":true,"path":"backend/aws/awsStaticPage/","link":"","permalink":"https://swtpumpkin.github.io/backend/aws/awsStaticPage/","excerpt":"","text":"s3와 route53을 이용하여 정적인 페이지 배포aws에 s3(Simple Storage Service)라는 클라우드 저장 공간을 이용하여 페이지를 배포 할 수 있습니다. route53이라는 Domain관리소와 s3를 연결하여 s3에 파일을 올리게 되면 자동적으로 배포하는 방법을 포스팅하겠습니다. 설정 방법route53에서 배포할 도메인을 선택합니다.Create Record Set을 선택하여 서브도메인을 생성합니다.Alias를 Yes로 선택하고 s3로 이동합니다.s3에서 버킷 만들기를 선택합니다.버킷 이름은 서브도메인의 주소와 동일하게 작성합니다.생성한 버킷을 선택합니다.속성 탭에서 정적 웹 사이트 호스팅을 선택합니다.인덱스 문서와 오류 문서를 index.html로 작성합니다.권한 탭에서 버킷 정책을 위와 같이 작성합니다. 1234567891011&#123; \"Version\": \"2012-10-17\", \"Statement\": [ &#123; \"Effect\": \"Allow\", \"Principal\": \"*\", \"Action\": \"s3:GetObject\", \"Resource\": \"arn:aws:s3:::test.swtpumpkin.com/*\" &#125; ]&#125; 위 코드에서 arn:aws:s3:::test.swtpumpkin.com/부분을 s3의 버킷이름 또는 서브도메인 주소와 동일하게 작성합니다.s3의 대쉬보드를 보게 되면 서브도메인의 버킷에 엑세스 부분이 퍼블릭으로 변환되었습니다.서브도메인 버킷의 속성에 정적 웹 사이트 호스팅 엔드포인트를 복사합니다. 전체 주소가 아닌 s3부터 주소를 복사해야합니다.route53에서 서브도메인 생성 할 때 활성화 해놓았던 곳으로 이동하여 Alias Target에 복사한 주소를 붙여넣게되면 Alias Hosted Zone ID가 자동으로 생성됩니다. ID가 자동으로 생성되지 않는다면 엔드포인트를 잘 못 입력한 것입니다.이제 셋팅은 완료 되었습니다. index.html이 있는 파일을 s3의 서브도메인 이름과 동일한 버킷에 업로드 하게 되면 자동으로 배포 됩니다.","categories":[{"name":"backend","slug":"backend","permalink":"https://swtpumpkin.github.io/categories/backend/"},{"name":"AWS","slug":"backend/AWS","permalink":"https://swtpumpkin.github.io/categories/backend/AWS/"}],"tags":[{"name":"aws","slug":"aws","permalink":"https://swtpumpkin.github.io/tags/aws/"},{"name":"s3","slug":"s3","permalink":"https://swtpumpkin.github.io/tags/s3/"},{"name":"정적사이트","slug":"정적사이트","permalink":"https://swtpumpkin.github.io/tags/%EC%A0%95%EC%A0%81%EC%82%AC%EC%9D%B4%ED%8A%B8/"},{"name":"배포","slug":"배포","permalink":"https://swtpumpkin.github.io/tags/%EB%B0%B0%ED%8F%AC/"},{"name":"route53","slug":"route53","permalink":"https://swtpumpkin.github.io/tags/route53/"}]},{"title":"ec2와 rds 연결하기","slug":"backend/aws/ec2ConnectRds","date":"2017-12-25T23:00:00.000Z","updated":"2020-01-08T04:06:19.001Z","comments":true,"path":"backend/aws/ec2ConnectRds/","link":"","permalink":"https://swtpumpkin.github.io/backend/aws/ec2ConnectRds/","excerpt":"","text":"ec2와 RDSec2를 사용하면서 백엔드 RDS의 MySQL서버와 연결하지 않아 아래와 같은 에러가 발생하였었습니다.Error: connect ETIMEDOUT이란 에러로 원인을 찾는데 오래 걸렸습니다. 맥 환경에서는 통신이 잘 되지만 ec2에 올린 백엔드 환경의 설정이 같음에도 에러가 발생하였는데 해결방법은 간단했습니다. 연결 방법RDS 대시보드에서 ec2와 연결할 서버를 선택 후 보안그룹을 확인합니다.ec2 대시보드에서 RDS에서의 보안그룹과 같은 보안그룹을 선택합니다. ec2와 RDS의 보안그룹이 같지 않아 에러가 발생 하는 것으로 보안그룹을 동일하게 만들어주면 해결됩니다.","categories":[{"name":"backend","slug":"backend","permalink":"https://swtpumpkin.github.io/categories/backend/"},{"name":"AWS","slug":"backend/AWS","permalink":"https://swtpumpkin.github.io/categories/backend/AWS/"}],"tags":[{"name":"yarn","slug":"yarn","permalink":"https://swtpumpkin.github.io/tags/yarn/"},{"name":"aws","slug":"aws","permalink":"https://swtpumpkin.github.io/tags/aws/"}]},{"title":"ec2의 ubuntu에서 nvm 설치하기","slug":"backend/aws/ec2UbuntuNVM","date":"2017-12-23T03:00:00.000Z","updated":"2020-01-08T04:06:19.001Z","comments":true,"path":"backend/aws/ec2UbuntuNVM/","link":"","permalink":"https://swtpumpkin.github.io/backend/aws/ec2UbuntuNVM/","excerpt":"","text":"ec2의 ubuntu에서 nvm 설치하기!nvm 설치방법1nvm 위 사진과 같이 nvm을 실행하였을때 nvm: command not found가 나타났다면 nvm이 설치되있지 않았다는 것입니다. 1curl https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;creationix&#x2F;nvm&#x2F;v0.23.3&#x2F;install.sh | bash 위 코드를 ubuntu 터미널에서 실행합니다.nvm이 위 사진과 같이 설치가 되었더라도 nvm --version을 실행하면 아래와 같이 nvm: command not found이 발생됩니다.nvm설정을 추가하지 않았기때문에 나타나는 에러입니다. 1source ~&#x2F;.bashrc 위 코드를 실행하여 .nvm 설정을 추가합니다..nvm 설정후 nvm --version을 실행하면 위와 같이 nvm의 버전을 확인 할 수 있습니다. nvm설치가 완료되면 node를 설치 할 수 있습니다. 1nvm i v9 위 코드를 터미널에서 실행하면 node의 9버전 중 최신버전의 node가 설치됩니다.위 사진과 같이 현재 작성한 날짜의 node버전은 9.3.0이므로 9.3.0이 설치되었습니다.","categories":[{"name":"backend","slug":"backend","permalink":"https://swtpumpkin.github.io/categories/backend/"},{"name":"AWS","slug":"backend/AWS","permalink":"https://swtpumpkin.github.io/categories/backend/AWS/"}],"tags":[{"name":"nvm","slug":"nvm","permalink":"https://swtpumpkin.github.io/tags/nvm/"},{"name":"aws","slug":"aws","permalink":"https://swtpumpkin.github.io/tags/aws/"},{"name":"ubuntu","slug":"ubuntu","permalink":"https://swtpumpkin.github.io/tags/ubuntu/"},{"name":"ec2","slug":"ec2","permalink":"https://swtpumpkin.github.io/tags/ec2/"}]},{"title":"ec2에서 ssh key 생성하는 방법","slug":"backend/aws/ec2SshKey","date":"2017-12-23T02:00:00.000Z","updated":"2024-02-27T03:02:16.171Z","comments":true,"path":"backend/aws/ec2SshKey/","link":"","permalink":"https://swtpumpkin.github.io/backend/aws/ec2SshKey/","excerpt":"","text":"ec2에서 ssh키 생성하기!생성방법1ssh-keygen -t rsa 터미널을 이용하여 ec2에 접속후 위 코드를 터미널에서 실행합니다. 비밀번호 설정을 하지 않고 ssh를 생성하려면 enter를 계속누르면 됩니다.위와 같이 image생성과 함께 ssh key가 생성됩니다. 1cat ~&#x2F;.ssh&#x2F;id_rsa.pub | pbcopy 위와 같이 빨간박스 안에 있는 글들이 ssh key입니다. 복사하여 ssh key입력하는 곳에 입력하여 사용하면 됩니다.","categories":[{"name":"backend","slug":"backend","permalink":"https://swtpumpkin.github.io/categories/backend/"},{"name":"AWS","slug":"backend/AWS","permalink":"https://swtpumpkin.github.io/categories/backend/AWS/"}],"tags":[{"name":"aws","slug":"aws","permalink":"https://swtpumpkin.github.io/tags/aws/"},{"name":"ec2","slug":"ec2","permalink":"https://swtpumpkin.github.io/tags/ec2/"},{"name":"ssh key","slug":"ssh-key","permalink":"https://swtpumpkin.github.io/tags/ssh-key/"}]},{"title":"workbench와 aws rds 연결하기","slug":"backend/aws/workbenchRds","date":"2017-12-23T01:00:00.000Z","updated":"2020-01-08T04:06:19.002Z","comments":true,"path":"backend/aws/workbenchRds/","link":"","permalink":"https://swtpumpkin.github.io/backend/aws/workbenchRds/","excerpt":"","text":"workbenchworkbench를 이용하여 aws rds에서 생성한 MySQL DB를 연결 할 수 있습니다. workbench 설정 방법MySQL Connections옆 +버튼을 누릅니다.new를 선택하여 새로운 연결설정을 생성합니다. Connection Name에는 workbench에 표시 될 이름을 설정합니다.Hostname에는 RDS의 연결 할 인스턴스에서 엔드포인트를 복사하여 붙여넣기 합니다. Username은 RDS인스턴스 설치 시 생성하였던 username을 넣습니다.Test Connection을 누릅니다.RDS인스턴스 설치 시 생성하였던 user의 비밀번호를 입력합니다. 비밀번호 입력 후 Save password in keychain을 선택해놓으면 비밀번호를 기억하여 다음 접속 시 비밀번호를 다시 입력하는 번거로움이 없어집니다.위와 같이 성공하였다는 창이 나오면 연결이 정상적으로 된 것입니다.","categories":[{"name":"backend","slug":"backend","permalink":"https://swtpumpkin.github.io/categories/backend/"},{"name":"AWS","slug":"backend/AWS","permalink":"https://swtpumpkin.github.io/categories/backend/AWS/"}],"tags":[{"name":"aws","slug":"aws","permalink":"https://swtpumpkin.github.io/tags/aws/"},{"name":"rds","slug":"rds","permalink":"https://swtpumpkin.github.io/tags/rds/"},{"name":"workbench","slug":"workbench","permalink":"https://swtpumpkin.github.io/tags/workbench/"}]},{"title":"cyberduck과 ec2 연결하기","slug":"backend/aws/cyberduckEc2","date":"2017-12-23T00:00:00.000Z","updated":"2020-01-08T04:06:19.001Z","comments":true,"path":"backend/aws/cyberduckEc2/","link":"","permalink":"https://swtpumpkin.github.io/backend/aws/cyberduckEc2/","excerpt":"","text":"Cyberduck이란?Cyberduck은 SSH를 통해 파일을 전송할 수 있는 프로토콜인 SFTP을 지원하는 파일 브라우저입니다. SFTP 외에도 많은 프로토콜 및 서비스를 지원합니다. ec2와 연결 할 때에는 SFTP를 이용하여 연결하겠습니다. 사용 방법aws에서 ec2로 이동합니다.실행 중인 인스턴스로 이동합니다.연결할 인스턴스를 선택 후 퍼블릭 DNS의 주소를 복사합니다.cyberduck을 실행 후 새 연결 위 지구본모양을 클릭합니다.SFTP를 선택하고 퍼블릭 DNS의 주소를 서버란에 입력합니다. 사용자 이름은 제 ec2가 ubuntu운영체제로 되어있어 ubuntu로 사용하였습니다. 다 작성하면 SSH Private Key를 선택합니다. 123456Amazon Linux AMI의 경우 사용자 이름은 ec2-user입니다.RHEL AMI의 경우 사용자 이름은 ec2-user 또는 root입니다.Ubuntu AMI의 경우 사용자 이름은 ubuntu 또는 root입니다.Centos AMI의 경우 사용자 이름은 centos입니다.Fedora AMI의 경우 사용자 이름은 ec2-user입니다.SUSE의 경우 사용자 이름은 ec2-user 또는 root입니다. 선택...을 선택합니다.해당 ec2의 .pem파일을 선택합니다.모두 설정이 완료되었다면 연결을 선택합니다.","categories":[{"name":"backend","slug":"backend","permalink":"https://swtpumpkin.github.io/categories/backend/"},{"name":"AWS","slug":"backend/AWS","permalink":"https://swtpumpkin.github.io/categories/backend/AWS/"}],"tags":[{"name":"aws","slug":"aws","permalink":"https://swtpumpkin.github.io/tags/aws/"},{"name":"ec2","slug":"ec2","permalink":"https://swtpumpkin.github.io/tags/ec2/"},{"name":"cyberduck","slug":"cyberduck","permalink":"https://swtpumpkin.github.io/tags/cyberduck/"}]},{"title":"hexo블로그 구글 웹마스터 도구에 sitemap 추가","slug":"git/hexo/hexoSitemap","date":"2017-12-20T23:00:00.000Z","updated":"2020-01-08T04:06:19.010Z","comments":true,"path":"git/hexo/hexoSitemap/","link":"","permalink":"https://swtpumpkin.github.io/git/hexo/hexoSitemap/","excerpt":"","text":"구글 웹마스터 도구(Search Console)에 sitemap 추가sitemap을 추가해야하는 이유!구글 웹마스터 도구에서 사이트를 등록 후 아래와 같이 에러가 점점 증가하였습니다.에러의 발생 원인을 찾던 중 얼마전 블로깅 폴더 정리를 하면서 대부분의 페이지 주소가 변경되어 크롤링 에러가 발생하였던 것입니다. 구글에 문의를 하니 sitemap을 제출하면 에러가 해결된다고 하여 sitemap을 추가하는 방법을 포스팅하게 되었습니다. 플러그인 설치Hexo에서 자동으로 sitemap을 생성해주는 플러그인을 설치합니다. 이 플러그인을 설치하면 hexo generate를 실행하게 되면 자동으로 sitemap을 생성해줍니다. hexo blog 루트 폴더로 이동합니다. 1npm install hexo-generator-seo-friendly-sitemap --save 루트폴더에서 터미널로 위 코드를 실행하여 플러그인을 설치합니다.루트 위치에 있는 _config.yml파일을 실행합니다.url부분에 자신의 블로그 페이지 url의 root주소를 위와 같이 추가해야합니다.위와 같이 환경설정이 잘 되었는지 확인합니다. sitemap 추가 방법웹마스터도구로 이동하여 블로깅 한 사이트를 선택합니다.오른쪽 아래 부분에 sitemap을 선택합니다.SITEMAP 추가테스트를 선택합니다.sitemap.xml을 위 빈칸에 작성 후 제출합니다.","categories":[{"name":"git","slug":"git","permalink":"https://swtpumpkin.github.io/categories/git/"},{"name":"hexo","slug":"git/hexo","permalink":"https://swtpumpkin.github.io/categories/git/hexo/"}],"tags":[{"name":"google","slug":"google","permalink":"https://swtpumpkin.github.io/tags/google/"},{"name":"hexo","slug":"hexo","permalink":"https://swtpumpkin.github.io/tags/hexo/"},{"name":"sitemap","slug":"sitemap","permalink":"https://swtpumpkin.github.io/tags/sitemap/"},{"name":"사이트맵","slug":"사이트맵","permalink":"https://swtpumpkin.github.io/tags/%EC%82%AC%EC%9D%B4%ED%8A%B8%EB%A7%B5/"}]},{"title":"expo","slug":"develop/expo","date":"2017-12-18T23:00:00.000Z","updated":"2020-01-08T04:06:19.005Z","comments":true,"path":"develop/expo/","link":"","permalink":"https://swtpumpkin.github.io/develop/expo/","excerpt":"","text":"expo?Expo는 React Native를 기반으로 제작 된 툴입니다. JavaScript 및 React를 사용하여 기본 iOS 및 Android 앱을 생성 할 수 있습니다. 설치방법여기를 클릭하여 운영체제에 맞는 Expo Desktop Development Tool을 다운로드합니다.위와 같이 응용프로그램에 Expo를 추가합니다. 1npm install -g exp &amp;&amp; exp path npm을 이용해 전역에 exp를 설치합니다. 실행방법Expo아이콘을 클릭하여 Expo를 실행합니다.Create new project...를 클릭하여 새 프로젝트를 생성합니다.생성할 프로젝트 이름을 작성 후 Create로 생성합니다.위 사진에서 아래 빨간 칸에 아무런 이슈사항이 없다면 Expo를 시작하기에 적절한 환경입니다.","categories":[{"name":"develop","slug":"develop","permalink":"https://swtpumpkin.github.io/categories/develop/"}],"tags":[{"name":"develop","slug":"develop","permalink":"https://swtpumpkin.github.io/tags/develop/"},{"name":"mac","slug":"mac","permalink":"https://swtpumpkin.github.io/tags/mac/"},{"name":"개발환경설정","slug":"개발환경설정","permalink":"https://swtpumpkin.github.io/tags/%EA%B0%9C%EB%B0%9C%ED%99%98%EA%B2%BD%EC%84%A4%EC%A0%95/"},{"name":"expo","slug":"expo","permalink":"https://swtpumpkin.github.io/tags/expo/"}]},{"title":"SVG Path","slug":"frontend/svg/svgPath","date":"2017-12-18T01:00:00.000Z","updated":"2020-01-08T04:06:19.009Z","comments":true,"path":"frontend/svg/svgPath/","link":"","permalink":"https://swtpumpkin.github.io/frontend/svg/svgPath/","excerpt":"","text":"&lt;path&gt;&lt;path&gt;요소는 모양을 정의하는 일반적인 요소입니다. d속성 안에 M(m)과 L(l)은 좌표이고 대문자는 절대좌표 소문자는 상대좌표입니다. 속성 이름 값 형태 개요 d path data path 데이터 M(m) &lt;coordinate&gt; x좌표,y좌표 한 쌍 빈공백 또는 줄바꿈으로 좌표 구분 L(l) &lt;coordinate&gt; x좌표,y좌표 한 쌍 빈공백 또는 줄바꿈으로 좌표 구분 z 선의 끝점과 시작점을 연결 pathLength (number) path 길이","categories":[{"name":"frontend","slug":"frontend","permalink":"https://swtpumpkin.github.io/categories/frontend/"},{"name":"svg","slug":"frontend/svg","permalink":"https://swtpumpkin.github.io/categories/frontend/svg/"}],"tags":[{"name":"web","slug":"web","permalink":"https://swtpumpkin.github.io/tags/web/"},{"name":"html","slug":"html","permalink":"https://swtpumpkin.github.io/tags/html/"},{"name":"svg","slug":"svg","permalink":"https://swtpumpkin.github.io/tags/svg/"},{"name":"path tag","slug":"path-tag","permalink":"https://swtpumpkin.github.io/tags/path-tag/"}]},{"title":"SVG title, desc","slug":"frontend/svg/svgTitleDesc","date":"2017-12-18T01:00:00.000Z","updated":"2020-01-08T04:06:19.009Z","comments":true,"path":"frontend/svg/svgTitleDesc/","link":"","permalink":"https://swtpumpkin.github.io/frontend/svg/svgTitleDesc/","excerpt":"","text":"&lt;title&gt;&lt;title&gt;요소는 웹접근성에 의해 그래픽 요소로 렌더링 되지 않습니다. &lt;title&gt;요소를 툴팁으로 표시 할 수 있습니다. 스크린리더, 검색엔진에 반영됩니다. &lt;title&gt;요소는 웹접근성을 향상시킵니다. &lt;title&gt;요소를 사용하게 되면 해당 도형에 마우스를 올려두면 아래와 같이 title의 내용이 나오게 됩니다.&lt;desc&gt;&lt;title&gt;요소와 함께 &lt;desc&gt;를 사용하기도 합니다. 이 또한 그래픽 요소로 렌더링 되지 않습니다. 하지만 스크린 리더가 웹 페이지를 읽으면서 도형의 설명을 명시할 수 있습니다. 위 예제처럼 &lt;desc&gt;요소를 사용 할 수 있습니다.","categories":[{"name":"frontend","slug":"frontend","permalink":"https://swtpumpkin.github.io/categories/frontend/"},{"name":"svg","slug":"frontend/svg","permalink":"https://swtpumpkin.github.io/categories/frontend/svg/"}],"tags":[{"name":"web","slug":"web","permalink":"https://swtpumpkin.github.io/tags/web/"},{"name":"html","slug":"html","permalink":"https://swtpumpkin.github.io/tags/html/"},{"name":"svg","slug":"svg","permalink":"https://swtpumpkin.github.io/tags/svg/"},{"name":"title tag","slug":"title-tag","permalink":"https://swtpumpkin.github.io/tags/title-tag/"},{"name":"설명","slug":"설명","permalink":"https://swtpumpkin.github.io/tags/%EC%84%A4%EB%AA%85/"},{"name":"제목","slug":"제목","permalink":"https://swtpumpkin.github.io/tags/%EC%A0%9C%EB%AA%A9/"},{"name":"desc tag","slug":"desc-tag","permalink":"https://swtpumpkin.github.io/tags/desc-tag/"}]},{"title":"SVG symbol","slug":"frontend/svg/svgSymbol","date":"2017-12-18T00:00:00.000Z","updated":"2020-01-08T04:06:19.009Z","comments":true,"path":"frontend/svg/svgSymbol/","link":"","permalink":"https://swtpumpkin.github.io/frontend/svg/svgSymbol/","excerpt":"","text":"&lt;symbol&gt;&lt;symbol&gt;요소는 템플릿 객체를 정의하는데 사용됩니다. 다수의 &lt;symbol&gt;을 &lt;use&gt;요소로 인스턴스화 할 수 있습니다. &lt;symbol&gt;은 너비와 높이를 바꿀 수 없습니다. viewbox를 작성하면 속성을 변경 할 수 있습니다. 위 코드와 같이 &lt;symbol&gt;태그안에 있는 요소들은 랜더링 되지 않았고 &lt;use&gt;태그를 통해 참조하여 1개의 도형만 작성되었습니다. &lt;use&gt;태그에서 width와 height를 지정하게 되면 참조된 &lt;symbol&gt;태그의 크기는 변하지 않고 크기를 유지하게 됩니다. 따라서 &lt;symbol&gt;태그에서 선언한 도형보다 작게 되면 위 예제와 같이 짤리게 됩니다. 위 코드와 같이 &lt;symbol&gt;태그에서 viewbox를 지정하게 되면 &lt;use&gt;태그에서 지정한 width와 height의 비율만큼 맞춰지게 됩니다.","categories":[{"name":"frontend","slug":"frontend","permalink":"https://swtpumpkin.github.io/categories/frontend/"},{"name":"svg","slug":"frontend/svg","permalink":"https://swtpumpkin.github.io/categories/frontend/svg/"}],"tags":[{"name":"web","slug":"web","permalink":"https://swtpumpkin.github.io/tags/web/"},{"name":"html","slug":"html","permalink":"https://swtpumpkin.github.io/tags/html/"},{"name":"svg","slug":"svg","permalink":"https://swtpumpkin.github.io/tags/svg/"},{"name":"symbol tag","slug":"symbol-tag","permalink":"https://swtpumpkin.github.io/tags/symbol-tag/"},{"name":"탬플릿 객체","slug":"탬플릿-객체","permalink":"https://swtpumpkin.github.io/tags/%ED%83%AC%ED%94%8C%EB%A6%BF-%EA%B0%9D%EC%B2%B4/"}]},{"title":"yarn","slug":"develop/yarn","date":"2017-12-16T23:00:00.000Z","updated":"2020-01-08T04:06:19.006Z","comments":true,"path":"develop/yarn/","link":"","permalink":"https://swtpumpkin.github.io/develop/yarn/","excerpt":"","text":"yarn?yarn이란 페이스북에서 만든 자바스크립트 패키지 매니저입니다. 저는 react에 대해 공부하기 위해 yarn을 설치했습니다. yarn의 장점은 설치 속도가 빠르고 매우 안전하다고 합니다. yarn의 공식 홈페이지에서 더 많은 정보를 확인해보세요. 설치방법1brew install yarn --without-node nvm또는 유사한 것을 사용하는 경우 Node.js설치를 제외하고 yarn을 설치해야 합니다. 1yarn --version yarn이 설치가 잘 되었는지 버전 확인을 통해 확인합니다.설치가 잘 되었다면 위 사진처럼 저와 같이 버전이 나와야 합니다. 버전은 항상 업데이트 되기때문에 위 사진과 버전은 다를 수 있습니다. 1yarn self-update 만약 yarn의 버전을 업그레이드 하고싶다면 위 명령어를 사용하면 됩니다. 환경변수 설정위에서 설치한대로 설치하게 되면 설치만 되었지 사용은 할 수 없습니다. 환경변수 설정이 되어있지 않았기 때문입니다. 환경변수를 설치해보도록 하겠습니다. 저는 zsh를 사용하기때문에 zsh에서 환경변수를 설정해보도록 하겠습니다. 1yarn config get prefix 위 명령어를 입력합니다.명령어를 입력했을때 아무런 설정이 되어있지 않기때문에 위와 같이 undefined를 반환합니다. 1yarn config set prefix ~&#x2F;.yarn-global 위 명령어를 실행하여 설정을 셋팅합니다. 1yarn config get prefix 다시 이 명령어를 실행하면 .yarn-global의 위치가 아래와 같이 나타나게 됩니다..zshrc의 설정을 변경해보도록 하겠습니다. 1vi ~&#x2F;.zshrc 위 명령어를 터미널에 입력하면 vi에디터를 통해 .zshrc 설정파일이 열립니다. 다른 에디터를 사용해도 됩니다. 1export PATH&#x3D;&quot;$PATH:&#96;yarn global bin&#96;&quot; 위 한 줄을 .zshrc파일 아무곳에나 추가합니다. yarn의 path설정입니다.저는 위와 같은 곳에 추가 하였습니다.","categories":[{"name":"develop","slug":"develop","permalink":"https://swtpumpkin.github.io/categories/develop/"}],"tags":[{"name":"develop","slug":"develop","permalink":"https://swtpumpkin.github.io/tags/develop/"},{"name":"mac","slug":"mac","permalink":"https://swtpumpkin.github.io/tags/mac/"},{"name":"개발환경설정","slug":"개발환경설정","permalink":"https://swtpumpkin.github.io/tags/%EA%B0%9C%EB%B0%9C%ED%99%98%EA%B2%BD%EC%84%A4%EC%A0%95/"},{"name":"yarn","slug":"yarn","permalink":"https://swtpumpkin.github.io/tags/yarn/"}]},{"title":"Warning: Each child in an array or iterator should have a unique \"key\" prop.","slug":"frontend/react/reactError1","date":"2017-12-16T23:00:00.000Z","updated":"2020-01-08T04:06:19.008Z","comments":true,"path":"frontend/react/reactError1/","link":"","permalink":"https://swtpumpkin.github.io/frontend/react/reactError1/","excerpt":"","text":"에러의 이유?리엑트는 element가 많을 경우 key값을 주어야합니다. key값은 고유해야합니다.key값이 고유하지 않을 경우 위와 같이 에러가 발생합니다. 해결방법123&#123;movies.map(movie =&gt; &#123; return &lt;Movie title=&#123;movie.title&#125; poster=&#123;movie.poster&#125;/&gt;&#125;)&#125; 현재 movie object에는 고유한 key값이 없습니다.따라서 위와 같이 브라우저에서 에러가 발생하고 있습니다. 123&#123;movies.map((movie, index) =&gt; &#123; return &lt;Movie title=&#123;movie.title&#125; poster=&#123;movie.poster&#125; key=&#123;index&#125; /&gt;&#125;)&#125; 위와 같이 map의 parameter인 index를 사용하여 key값을 할당합니다. index는 0부터 시작합니다.각 자식요소에 고유한 key값을 갖고 있게 되어 console에는 에러가 발생하지 않습니다.","categories":[{"name":"frontend","slug":"frontend","permalink":"https://swtpumpkin.github.io/categories/frontend/"},{"name":"react","slug":"frontend/react","permalink":"https://swtpumpkin.github.io/categories/frontend/react/"}],"tags":[{"name":"array","slug":"array","permalink":"https://swtpumpkin.github.io/tags/array/"},{"name":"error","slug":"error","permalink":"https://swtpumpkin.github.io/tags/error/"},{"name":"react","slug":"react","permalink":"https://swtpumpkin.github.io/tags/react/"},{"name":"child","slug":"child","permalink":"https://swtpumpkin.github.io/tags/child/"},{"name":"key","slug":"key","permalink":"https://swtpumpkin.github.io/tags/key/"},{"name":"unique","slug":"unique","permalink":"https://swtpumpkin.github.io/tags/unique/"},{"name":"warnning","slug":"warnning","permalink":"https://swtpumpkin.github.io/tags/warnning/"}]},{"title":"SVG use","slug":"frontend/svg/svgUse","date":"2017-12-16T04:00:00.000Z","updated":"2020-01-08T04:06:19.009Z","comments":true,"path":"frontend/svg/svgUse/","link":"","permalink":"https://swtpumpkin.github.io/frontend/svg/svgUse/","excerpt":"","text":"&lt;use&gt;&lt;use&gt;태그는 다른 엘리먼트를 참조 할 때 사용합니다. 엘리먼트 내 요소들이 설정되었더라도 참조되는 설정이 바뀌게 되면 바뀐 설정이 적용됩니다. 참조는 xlink:href=&quot;#id_name&quot;를 사용하여 링크를 연결합니다.","categories":[{"name":"frontend","slug":"frontend","permalink":"https://swtpumpkin.github.io/categories/frontend/"},{"name":"svg","slug":"frontend/svg","permalink":"https://swtpumpkin.github.io/categories/frontend/svg/"}],"tags":[{"name":"web","slug":"web","permalink":"https://swtpumpkin.github.io/tags/web/"},{"name":"html","slug":"html","permalink":"https://swtpumpkin.github.io/tags/html/"},{"name":"svg","slug":"svg","permalink":"https://swtpumpkin.github.io/tags/svg/"},{"name":"use tag","slug":"use-tag","permalink":"https://swtpumpkin.github.io/tags/use-tag/"}]},{"title":"SVG defs","slug":"frontend/svg/svgDefs","date":"2017-12-16T03:00:00.000Z","updated":"2020-01-08T04:06:19.008Z","comments":true,"path":"frontend/svg/svgDefs/","link":"","permalink":"https://swtpumpkin.github.io/frontend/svg/svgDefs/","excerpt":"","text":"&lt;defs&gt;&lt;defs&gt;요소 내부에서 생성된 객체는 즉시 렌더링되지 않습니다. 랜더링에 영향이 없고 메모리에 저장되어 속도가 빠릅니다. 절대좌표 또는 상대좌표를 사용 할 수 있습니다. 참조하는 곳에 0,0을 작성하고 절대좌표로 작성하면 원하는 곳에 좌표처리가 편합니다. 위 코드와 같이 &lt;g&gt;태그안에 있는 요소들은 랜더링 되지 않았지만 &lt;use&gt;태그를 통해 참조하여 1개의 도형만 작성되었습니다.","categories":[{"name":"frontend","slug":"frontend","permalink":"https://swtpumpkin.github.io/categories/frontend/"},{"name":"svg","slug":"frontend/svg","permalink":"https://swtpumpkin.github.io/categories/frontend/svg/"}],"tags":[{"name":"web","slug":"web","permalink":"https://swtpumpkin.github.io/tags/web/"},{"name":"html","slug":"html","permalink":"https://swtpumpkin.github.io/tags/html/"},{"name":"svg","slug":"svg","permalink":"https://swtpumpkin.github.io/tags/svg/"},{"name":"참조","slug":"참조","permalink":"https://swtpumpkin.github.io/tags/%EC%B0%B8%EC%A1%B0/"},{"name":"defs tag","slug":"defs-tag","permalink":"https://swtpumpkin.github.io/tags/defs-tag/"}]},{"title":"SVG g","slug":"frontend/svg/svgG","date":"2017-12-16T02:00:00.000Z","updated":"2020-01-08T04:06:19.008Z","comments":true,"path":"frontend/svg/svgG/","link":"","permalink":"https://swtpumpkin.github.io/frontend/svg/svgG/","excerpt":"","text":"&lt;g&gt;div element와 같은 기능을 한다고 생각하면 됩니다. g에 속한 엘리먼트의 공통 속성을 작성 할 수 있습니다. 각 엘리먼트에 이벤트를 설정하지 않고 &lt;g&gt;에 작성하면 한번에 이벤트 설정이 가능합니다. 시멘틱적으로 하나의 그룹을 만들어 시멘틱을 부여할 때 사용합니다. 위 코드와 같이 &lt;g&gt;안에 모든 stroke는 &lt;g&gt;에서 지정해준 blue로 적용됩니다. 위 코드와 같이 &lt;g&gt;에서 stroke를 지정해주었더라도 circle에서 stroke속성을 다시 지정하게 되면 red로 지정됩니다. 이는 div속성과 유사하다고 생각하시면 됩니다.","categories":[{"name":"frontend","slug":"frontend","permalink":"https://swtpumpkin.github.io/categories/frontend/"},{"name":"svg","slug":"frontend/svg","permalink":"https://swtpumpkin.github.io/categories/frontend/svg/"}],"tags":[{"name":"web","slug":"web","permalink":"https://swtpumpkin.github.io/tags/web/"},{"name":"html","slug":"html","permalink":"https://swtpumpkin.github.io/tags/html/"},{"name":"svg","slug":"svg","permalink":"https://swtpumpkin.github.io/tags/svg/"},{"name":"g","slug":"g","permalink":"https://swtpumpkin.github.io/tags/g/"},{"name":"grouping","slug":"grouping","permalink":"https://swtpumpkin.github.io/tags/grouping/"},{"name":"그룹","slug":"그룹","permalink":"https://swtpumpkin.github.io/tags/%EA%B7%B8%EB%A3%B9/"}]},{"title":"SVG Polyline","slug":"frontend/svg/svgPolyline","date":"2017-12-16T00:00:00.000Z","updated":"2020-01-08T04:06:19.009Z","comments":true,"path":"frontend/svg/svgPolyline/","link":"","permalink":"https://swtpumpkin.github.io/frontend/svg/svgPolyline/","excerpt":"","text":"PolylineSVG를 이용하여 꺾은선을 나타낼 수 있습니다. 홈페이지 주식 차트 등 여러 그래프 차트에 사용이 가능합니다. 꺾은선은 선이지만 선 아래쪽을 면으로 인식하여 fill요소를 사용할 수 있습니다. 도형 내부를 체우지 않으려면 fill=none을 사용해야합니다. 속성 이름 값 형태 개요 points &lt;list-of-points&gt; x좌표,y좌표 한 쌍 빈공백 또는 줄바꿈으로 좌표 구분","categories":[{"name":"frontend","slug":"frontend","permalink":"https://swtpumpkin.github.io/categories/frontend/"},{"name":"svg","slug":"frontend/svg","permalink":"https://swtpumpkin.github.io/categories/frontend/svg/"}],"tags":[{"name":"web","slug":"web","permalink":"https://swtpumpkin.github.io/tags/web/"},{"name":"html","slug":"html","permalink":"https://swtpumpkin.github.io/tags/html/"},{"name":"svg","slug":"svg","permalink":"https://swtpumpkin.github.io/tags/svg/"},{"name":"polyline","slug":"polyline","permalink":"https://swtpumpkin.github.io/tags/polyline/"},{"name":"꺾은선","slug":"꺾은선","permalink":"https://swtpumpkin.github.io/tags/%EA%BA%BE%EC%9D%80%EC%84%A0/"}]},{"title":"SVG Polygon","slug":"frontend/svg/svgPolygon","date":"2017-12-15T23:00:00.000Z","updated":"2020-01-08T04:06:19.009Z","comments":true,"path":"frontend/svg/svgPolygon/","link":"","permalink":"https://swtpumpkin.github.io/frontend/svg/svgPolygon/","excerpt":"","text":"PolygonSVG를 이용하여 다각형을 나타낼 수 있습니다. 속성 이름 값 형태 개요 points &lt;list-of-points&gt; x좌표,y좌표 한 쌍 빈공백 또는 줄바꿈으로 좌표 구분","categories":[{"name":"frontend","slug":"frontend","permalink":"https://swtpumpkin.github.io/categories/frontend/"},{"name":"svg","slug":"frontend/svg","permalink":"https://swtpumpkin.github.io/categories/frontend/svg/"}],"tags":[{"name":"web","slug":"web","permalink":"https://swtpumpkin.github.io/tags/web/"},{"name":"html","slug":"html","permalink":"https://swtpumpkin.github.io/tags/html/"},{"name":"svg","slug":"svg","permalink":"https://swtpumpkin.github.io/tags/svg/"},{"name":"polygon","slug":"polygon","permalink":"https://swtpumpkin.github.io/tags/polygon/"},{"name":"다각형","slug":"다각형","permalink":"https://swtpumpkin.github.io/tags/%EB%8B%A4%EA%B0%81%ED%98%95/"}]},{"title":"SVG Ellipse","slug":"frontend/svg/svgEllipse","date":"2017-12-15T03:00:00.000Z","updated":"2020-01-08T04:06:19.008Z","comments":true,"path":"frontend/svg/svgEllipse/","link":"","permalink":"https://swtpumpkin.github.io/frontend/svg/svgEllipse/","excerpt":"","text":"EllipseSVG를 이용하여 타원형을 그릴 수 있습니다. 속성 이름 값 형태 개요 cx &lt;coordinate&gt; x축 원 중심 좌표 cy &lt;coordinate&gt; y축 원 중심 좌표 rx &lt;length&gt; 반지름 너비 ry &lt;length&gt; 반지름 높이","categories":[{"name":"frontend","slug":"frontend","permalink":"https://swtpumpkin.github.io/categories/frontend/"},{"name":"svg","slug":"frontend/svg","permalink":"https://swtpumpkin.github.io/categories/frontend/svg/"}],"tags":[{"name":"web","slug":"web","permalink":"https://swtpumpkin.github.io/tags/web/"},{"name":"html","slug":"html","permalink":"https://swtpumpkin.github.io/tags/html/"},{"name":"svg","slug":"svg","permalink":"https://swtpumpkin.github.io/tags/svg/"},{"name":"타원형","slug":"타원형","permalink":"https://swtpumpkin.github.io/tags/%ED%83%80%EC%9B%90%ED%98%95/"},{"name":"ellipse","slug":"ellipse","permalink":"https://swtpumpkin.github.io/tags/ellipse/"}]},{"title":"SVG Circle","slug":"frontend/svg/svgCircle","date":"2017-12-15T02:00:00.000Z","updated":"2020-01-08T04:06:19.008Z","comments":true,"path":"frontend/svg/svgCircle/","link":"","permalink":"https://swtpumpkin.github.io/frontend/svg/svgCircle/","excerpt":"","text":"CircleSVG를 이용하여 원을 그릴 수 있습니다. 다른 모형에선 좌상단이 좌표의 기준이 되지만 원은 원의 중심이 좌표의 기준이 됩니다. 속성 이름 값 형태 개요 cx &lt;coordinate&gt; x축 원 중심 좌표 cy &lt;coordinate&gt; y축 원 중심 좌표 r &lt;length&gt; 반지름","categories":[{"name":"frontend","slug":"frontend","permalink":"https://swtpumpkin.github.io/categories/frontend/"},{"name":"svg","slug":"frontend/svg","permalink":"https://swtpumpkin.github.io/categories/frontend/svg/"}],"tags":[{"name":"web","slug":"web","permalink":"https://swtpumpkin.github.io/tags/web/"},{"name":"html","slug":"html","permalink":"https://swtpumpkin.github.io/tags/html/"},{"name":"svg","slug":"svg","permalink":"https://swtpumpkin.github.io/tags/svg/"},{"name":"circle","slug":"circle","permalink":"https://swtpumpkin.github.io/tags/circle/"},{"name":"원","slug":"원","permalink":"https://swtpumpkin.github.io/tags/%EC%9B%90/"}]},{"title":"SVG Rect","slug":"frontend/svg/svgRect","date":"2017-12-15T01:00:00.000Z","updated":"2020-01-08T04:06:19.009Z","comments":true,"path":"frontend/svg/svgRect/","link":"","permalink":"https://swtpumpkin.github.io/frontend/svg/svgRect/","excerpt":"","text":"RectSVG를 이용하여 사각형을 그릴 수 있습니다. 속성 이름 값 형태 개요 x &lt;coordinate&gt; 좌표 y 좌표 width &lt;length&gt; 폭 heignt 높이 rx 가로 코너 반경 ry 수직 코너 반경 SVG는 만든 순서대로 쌓입니다. 따라서 가장 먼저 SVG를 생성하였다면 가장 아래쪽에 위치하고 가장 마지막에 작성한다면 가장 윗쪽에 위치합니다. 위 도형을 보면 pink, green, blue순 으로 코드를 작성하였고 blue가 가장 위에 위치하여 있습니다.","categories":[{"name":"frontend","slug":"frontend","permalink":"https://swtpumpkin.github.io/categories/frontend/"},{"name":"svg","slug":"frontend/svg","permalink":"https://swtpumpkin.github.io/categories/frontend/svg/"}],"tags":[{"name":"web","slug":"web","permalink":"https://swtpumpkin.github.io/tags/web/"},{"name":"html","slug":"html","permalink":"https://swtpumpkin.github.io/tags/html/"},{"name":"svg","slug":"svg","permalink":"https://swtpumpkin.github.io/tags/svg/"},{"name":"rect","slug":"rect","permalink":"https://swtpumpkin.github.io/tags/rect/"},{"name":"사각형","slug":"사각형","permalink":"https://swtpumpkin.github.io/tags/%EC%82%AC%EA%B0%81%ED%98%95/"}]},{"title":"SVG Line","slug":"frontend/svg/svgLine","date":"2017-12-15T00:00:00.000Z","updated":"2020-01-08T04:06:19.009Z","comments":true,"path":"frontend/svg/svgLine/","link":"","permalink":"https://swtpumpkin.github.io/frontend/svg/svgLine/","excerpt":"","text":"LineSVG를 이용하여 선을 그릴 수 있습니다. 속성 이름 개요 x1 x축 시작 좌표 값 y1 y축 시작 좌표 값 x2 x축 끝 좌표 값 y2 y축 끝 좌표 값 stroke(line color)stroke를 사용하여 선의 색상 선의 종류 두께 등 선의 스타일을 지정 할 수 있습니다. stroke를 작성하지 않으면 선이 보이지 않습니다. stroke이외 속성은 디폴트 값이 있습니다. stroke(선 색)stroke는 선의 색을 지정 할 수 있습니다. 12&lt;line x1=20 y1=20 x2=40 y2=40 stroke=\"black\"&gt;&lt;line x1=30 y1=30 x2=50 y2=50 stroke=\"#000000\"&gt; 위와 같이 선 색을 CSS처럼 색상 이름 또는 색상 코드로 작성 할 수 있습니다. stroke-width(선 너비)stroke-width는 선의 너비를 지정 할 수 있습니다. 위 코드는 stroke-width를 다르게 하였지만 모양은 같습니다. 선이 수평일 경우 width가 height가 될 수도 있기때문에 너비개념으로 이해하는 것이 좋습니다. 선은 가운데가 좌표입니다. 따라서 선의 폭을 설정하면 위 아래로 반반씩 두께를 적용하게 됩니다. stroke-dasharray(점선)stroke-dasharray는 점선을 지정 할 수 있습니다. 선과 띄어지는 지점의 길이를 작성합니다. 복수형태로 지정해야하고 홀수번째는 선의 길이 짝수번째는 띄어지는 길이를 지정 할 수 있습니다. stroke-linecap(선 끝 모양)stroke-linecap은 선끝의 모양을 지정 할 수 있습니다. 기본 값은 butt이고 다른 속성을 지정하게 되면 선끝에서 반지름만큼 길이가 조금 길어지게 됩니다. 따라서 옵션을 지정 할 때 조금 길어지는 길이를 감안하여 지정해야합니다. 속성 이름 값 형태 개요 stroke-linecap butt 선 끝까지만 표현. default round 선 끝에서 둥글게 표현. 선 끝에서 반지름만큼 밖으로 나감 square 선 끝에서 사각형 표현. 선 끝에서 반지름만큼 밖으로 나감 stroke-opacity(불투명도)stroke-opacity는 선의 불투명도를 지정 할 수 있습니다. 불투명도는 1에서 0으로 갈수록 투명하게 표현되고 기본값은 1입니다. 속성 이름 값 형태 개요 stroke-opacity &lt;opacity-value&gt; 불투명도. 0에서 1사이의 소수값으로 작성 stroke-linejoin(모퉁이 형태)stroke-linejoin은 선의 모퉁이 형태를 지정 할 수 있습니다. 기본값은 miter입니다. 속성 이름 값 형태 개요 stroke-linejoin miter 모퉁이 각 형태. 너비만큼 밖으로 표시. default round 둥근 형태 bevel 모퉁이를 깎은 형태 stroke 사용가능 단위사용가능 단위 cm, em, ex, in, mm, pc, pt, px.(기본 값 px) stroke-width=”1px” stroke-width=”1pt”; 1.25px stroke-width=”1mm”; 2.543307px stroke-width=”1ex” stroke-width=”1pc”; 15px stroke-width=”1em” stroke-width=”1cm”; 35.43307px stroke-width=”1in”; 90px","categories":[{"name":"frontend","slug":"frontend","permalink":"https://swtpumpkin.github.io/categories/frontend/"},{"name":"svg","slug":"frontend/svg","permalink":"https://swtpumpkin.github.io/categories/frontend/svg/"}],"tags":[{"name":"web","slug":"web","permalink":"https://swtpumpkin.github.io/tags/web/"},{"name":"html","slug":"html","permalink":"https://swtpumpkin.github.io/tags/html/"},{"name":"svg","slug":"svg","permalink":"https://swtpumpkin.github.io/tags/svg/"},{"name":"line","slug":"line","permalink":"https://swtpumpkin.github.io/tags/line/"},{"name":"stroke","slug":"stroke","permalink":"https://swtpumpkin.github.io/tags/stroke/"},{"name":"선","slug":"선","permalink":"https://swtpumpkin.github.io/tags/%EC%84%A0/"}]},{"title":"SVG","slug":"frontend/svg/svg","date":"2017-12-14T23:00:00.000Z","updated":"2020-01-08T04:06:19.008Z","comments":true,"path":"frontend/svg/svg/","link":"","permalink":"https://swtpumpkin.github.io/frontend/svg/svg/","excerpt":"","text":"SVG란?Scalable Vector Graphics의 약어로써 직역하면 확장 가능한 벡터 그래픽이란 뜻입니다. SVG를 이용하여 벡터형식의 2차원 그래픽을 표현 할 수 있습니다. SVG는 자동으로 확대, 축소를 대응합니다. HTML5부터 SVG엘리먼트로 구현되었습니다. 향후 데이터 시각화를 통해 데이터의 그래프 표현과 iot, 빅데이터로 인한 필요성 증가 될 것입니다. 또한 모바일에 적용되어 아이콘 또는 메뉴버튼에 사용하여 확대, 축소에 대응 하게 될 것입니다. SVG 작성 형태SVG는 html의 요소로 사용 할 수 있습니다. 앞서 설명드린 것과 같이 HTML5부터 지원합니다. 1234&lt;body&gt; &lt;svg&gt; &lt;/svg&gt;&lt;/body&gt; SVG에 width와 height를 지정하지 않는다면 기본 값은 width=&quot;300&quot; height=&quot;150&quot;으로 지정됩니다. SVG 주요 용어글리프 글자 하나의 모양 단위 도형 기호(괄호, 공백 등) 포함 SVG 캔버스 SVG 콘텐츠 표현 공간 좌우 상하의 무한 공간과 유효한 공간으로 구분 뷰포트 SVG 캔버스에서 콘텐츠를 표현하는 유효 공간으로 사용자가 이 영역을 눈으로 볼 수 있음 사용자가 볼 수 있는 영역","categories":[{"name":"frontend","slug":"frontend","permalink":"https://swtpumpkin.github.io/categories/frontend/"},{"name":"svg","slug":"frontend/svg","permalink":"https://swtpumpkin.github.io/categories/frontend/svg/"}],"tags":[{"name":"web","slug":"web","permalink":"https://swtpumpkin.github.io/tags/web/"},{"name":"html","slug":"html","permalink":"https://swtpumpkin.github.io/tags/html/"},{"name":"id","slug":"id","permalink":"https://swtpumpkin.github.io/tags/id/"},{"name":"class","slug":"class","permalink":"https://swtpumpkin.github.io/tags/class/"},{"name":"svg","slug":"svg","permalink":"https://swtpumpkin.github.io/tags/svg/"}]},{"title":"hexo theme color","slug":"git/hexo/hexoThemaColor","date":"2017-12-11T23:00:00.000Z","updated":"2020-01-08T04:06:19.010Z","comments":true,"path":"git/hexo/hexoThemaColor/","link":"","permalink":"https://swtpumpkin.github.io/git/hexo/hexoThemaColor/","excerpt":"","text":"헥소 테마 색상 변경헥소를 이용하여 github blog를 사용하다보면 기본 테마의 색을 변경하고 싶을 때가 있습니다. hueman의 테마 색상을 변경하도록 하겠습니다. sidebar color빨간 위치의 색상을 변경해보도록 하겠습니다.위 사진과 같은 경로의 sidebar.styl파일을 찾아 열겠습니다.13번째 줄의 background 색상을 원하는 색상 코드로 변경합니다. header color위 사진에서 보이는 곳과 같이 헤더의 색상을 변경하도록 하겠습니다.위 경로의 _variables.styl 파일을 찾아 열겠습니다.12번째 줄의 color-header-background 색상을 원하는 색상 코드로 변경합니다. navigationbar color위 사진에서 보이는 곳과 같이 네비게이션 바의 색상을 변경하도록 하겠습니다.위 경로의 _variables.styl 파일을 찾아 열겠습니다.19번째 줄의 color-nav-background 색상을 원하는 색상 코드로 변경합니다. footer color위 사진에서 보이는 곳과 같이 footer의 색상을 변경하도록 하겠습니다.위 경로의 _variables.styl 파일을 찾아 열겠습니다.24번째 줄의 color-footer-background 색상을 원하는 색상 코드로 변경합니다.","categories":[{"name":"git","slug":"git","permalink":"https://swtpumpkin.github.io/categories/git/"},{"name":"hexo","slug":"git/hexo","permalink":"https://swtpumpkin.github.io/categories/git/hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://swtpumpkin.github.io/tags/hexo/"},{"name":"color","slug":"color","permalink":"https://swtpumpkin.github.io/tags/color/"},{"name":"hueman thema","slug":"hueman-thema","permalink":"https://swtpumpkin.github.io/tags/hueman-thema/"},{"name":"배경색","slug":"배경색","permalink":"https://swtpumpkin.github.io/tags/%EB%B0%B0%EA%B2%BD%EC%83%89/"}]},{"title":"gh-pages","slug":"git/ghPages","date":"2017-12-09T23:00:00.000Z","updated":"2020-05-06T07:34:44.382Z","comments":true,"path":"git/ghPages/","link":"","permalink":"https://swtpumpkin.github.io/git/ghPages/","excerpt":"","text":"gh-pages?gh-pages는 git repositories의 한 공간을 사용하여 페이지를 배포 할 수 있는 기능입니다. 사용방법repositories에서 새로운 repositories를 생성합니다.repositories명을 작성하고 생성합니다.생성한 repositories에 index.html이 있는 파일을 업로드 합니다.Branch버튼을 누르고 gh-pages라는 Branch를 생성합니다.gh-pages라는 Branch를 생성하게 되면 Setting에 GitHub Pages부분을 보면 퍼블리싱 되었다고 보여집니다. 1https:&#x2F;&#x2F;github_nickname.github.io&#x2F;repository_name&#x2F; 위와 같은 경로로 들어가면 repositories에 업로드 하였던 페이지를 볼 수 있습니다.블로깅에 사용하였던 gh-pages입니다.","categories":[{"name":"git","slug":"git","permalink":"https://swtpumpkin.github.io/categories/git/"}],"tags":[{"name":"git","slug":"git","permalink":"https://swtpumpkin.github.io/tags/git/"},{"name":"gh-pages","slug":"gh-pages","permalink":"https://swtpumpkin.github.io/tags/gh-pages/"},{"name":"git page","slug":"git-page","permalink":"https://swtpumpkin.github.io/tags/git-page/"}]},{"title":"hexo jsfiddle","slug":"git/hexo/hexoJsfiddle","date":"2017-12-09T23:00:00.000Z","updated":"2020-01-08T04:06:19.010Z","comments":true,"path":"git/hexo/hexoJsfiddle/","link":"","permalink":"https://swtpumpkin.github.io/git/hexo/hexoJsfiddle/","excerpt":"","text":"jsfiddle?웹의 프론트 기술인 html, css, javascript를 이용하여 코드를 작성하고 바로 테스트 할 수 있는 코드 공유 서비스입니다. 사용방법jsfiddle사이트로 이동하여 코드를 작성합니다.작성 후 Run버튼을 누르면 result에 실행 결과값이 나오게 됩니다.result부분에 결과 값이 잘 실행되었습니다.원하는 결과 값이 나오면 Save버튼을 누릅니다.저장버튼을 누르게 되면 위 사진과 같이 주소가 변하게 됩니다. 1&#123;% jsfiddle g64atfz2 html,css,result %&#125; jsfiddle을 사용하기 위한 옵션들이 여러가지 있습니다. 1&#123;% jsfiddle shorttag [tabs] [skin] [width] [height] %&#125; 대괄호([])안에 있는 것들은 옵션으로 사용하지 않아도 상관 없습니다. tabs은 html, css, js, result가 있고 모두 붙여씁니다. html, css, js, result와 같이 사용합니다. 순서를 바꾸면 먼저 표시되게 됩니다. skin은 light와 dark가 있습니다. size는 width와 height순으로 되어있고 px단위 입니다.","categories":[{"name":"git","slug":"git","permalink":"https://swtpumpkin.github.io/categories/git/"},{"name":"hexo","slug":"git/hexo","permalink":"https://swtpumpkin.github.io/categories/git/hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://swtpumpkin.github.io/tags/hexo/"},{"name":"jsfiddle","slug":"jsfiddle","permalink":"https://swtpumpkin.github.io/tags/jsfiddle/"}]},{"title":"WARNING: UNPROTECTED PRIVATE KEY FILE!","slug":"backend/aws/ec2PemKey","date":"2017-12-07T23:00:00.000Z","updated":"2020-01-08T04:06:19.001Z","comments":true,"path":"backend/aws/ec2PemKey/","link":"","permalink":"https://swtpumpkin.github.io/backend/aws/ec2PemKey/","excerpt":"","text":"WARNING: UNPROTECTED PRIVATE KEY FILE!위 경고는 pem 파일의 권한이 너무 많이 열려있어 에러가 발생하는 것입니다. 터미널에서 아래와 같이 경고가 발생 할 것입니다. 해결방법1chmod 600 (pemkey 파일 이름).pem pemkey 파일 이름 부분에 해당하는 파일의 이름을 넣고 터미널에서 실행하면 권한이 바뀌게 되고 위 에러는 해결 할 수 있습니다.","categories":[{"name":"backend","slug":"backend","permalink":"https://swtpumpkin.github.io/categories/backend/"},{"name":"AWS","slug":"backend/AWS","permalink":"https://swtpumpkin.github.io/categories/backend/AWS/"}],"tags":[{"name":"aws","slug":"aws","permalink":"https://swtpumpkin.github.io/tags/aws/"},{"name":"error","slug":"error","permalink":"https://swtpumpkin.github.io/tags/error/"},{"name":"pemkey","slug":"pemkey","permalink":"https://swtpumpkin.github.io/tags/pemkey/"},{"name":"warning","slug":"warning","permalink":"https://swtpumpkin.github.io/tags/warning/"}]},{"title":"transition","slug":"frontend/css/transition","date":"2017-12-06T00:00:00.000Z","updated":"2020-01-08T04:06:19.007Z","comments":true,"path":"frontend/css/transition/","link":"","permalink":"https://swtpumpkin.github.io/frontend/css/transition/","excerpt":"","text":"transitionCSS로 효과를 주게되면 변화는 즉시 실행됩니다. 하지만 transition효과를 사용하게 되면 지정한 시간동안 변하도록 효과를 줄 수 있습니다. transition-propertytransition-property는 변화의 대상이 되는 CSS의 프로퍼티를 지정해 줄 때 사용합니다. 지정하지 않는 경우 모든 property가 지정됩니다. 기본 값은 all입니다. 123.box&#123; transition-property: background-color;&#125; transition-duration변화가 일어나는 지속시간을 지정 할 수 있습니다. 값을 지정하지 않는다면 기본값은 0s입니다. transition효과를 적용하려면 꼭 시간을 지정해주어야합니다. 123.box&#123; transition-duration: 5s;&#125; transition-timing-function변화의 속도를 지정 할 수 있습니다. 변화속도를 지정하지 않는다면 기본 값은 easy입니다. 123.box&#123; transition-timing-function: ease;&#125; 프로퍼티 값 기능 그림 easy 기본값 linear 처음부터 끝까지 일정한 속도 easy-in 느리게 시작해서 일정한 속도로 변함 easy-out 일정한 속도로 시작해서 느리게 변함 easy-in-out 기본값과 비슷하지만 중간에 일정하게 되는 구간 있음 transition-delay변화가 일어나기 전 대기하는 시간을 지정 할 수 있습니다. 초 단위로 지정하고 지정한 시간만큼 대기 후 변화가 실행됩니다. 123.box&#123; transition-delay: 5s;&#125; transitiontransition에도 shortand가 존재합니다. transition의 초기값은 아래와 같습니다. 여기를 클릭하시면 css transition에 대한 자세한 설명을 볼 수 있습니다. 1234transition-property: alltransition-duration: 0stransition-timing-function: easetransition-delay: 0s","categories":[{"name":"frontend","slug":"frontend","permalink":"https://swtpumpkin.github.io/categories/frontend/"},{"name":"css","slug":"frontend/css","permalink":"https://swtpumpkin.github.io/categories/frontend/css/"}],"tags":[{"name":"web","slug":"web","permalink":"https://swtpumpkin.github.io/tags/web/"},{"name":"css","slug":"css","permalink":"https://swtpumpkin.github.io/tags/css/"},{"name":"transition","slug":"transition","permalink":"https://swtpumpkin.github.io/tags/transition/"}]},{"title":"element states","slug":"frontend/css/elementStates","date":"2017-12-05T23:00:00.000Z","updated":"2020-01-08T04:06:19.007Z","comments":true,"path":"frontend/css/elementStates/","link":"","permalink":"https://swtpumpkin.github.io/frontend/css/elementStates/","excerpt":"","text":"hover?hover란 해당 객체 위에 마우스를 올려두면 스타일이 다르게 변하도록 효과를 줄 수 있습니다. 1234567891011121314&lt;head&gt; &lt;style&gt; .box&#123; background-color: skyblue; font-size: 40px; &#125; .box:hover&#123; background-color: pink; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;span class=\"box\"&gt;hover&lt;/span&gt;&lt;/body&gt; 위와 같이 코드를 작성하면 아래와 같이 마우스를 올리지 않았을 땐 배경색이 하늘색입니다.하지만 마우스를 hover란 글자 위에 올리게 되면 아래와 같이 핑크색으로 변하게 됩니다. active?active란 해당 객체를 마우스로 클릭했을 때 스타일을 변하도록 만들 수 있습니다. active는 마우스를 클릭하는 동안에만 작동하게 됩니다. 따라서 클릭이 끝나게 되면 원상태로 돌아옵니다. 1234567891011121314&lt;head&gt; &lt;style&gt; .box&#123; background-color: skyblue; font-size: 40px; &#125; .box:active&#123; background-color: green; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;span class=\"box\"&gt;active&lt;/span&gt;&lt;/body&gt; 위와 같이 코드를 작성하면 아래와 같이 마우스를 클릭하지 않았을 땐 배경색이 하늘색입니다.하지만 마우스를 active란 글자 위에서 마우스로 클릭하게되면 아래와 같이 초록색으로 변하게 됩니다. 하지만 클릭이 끝나게 되면 바로 원래 하늘색으로 돌아옵니다. focus?focus란 input태그와 같은 입력 태그가 선택 될 때 focus를 얻을 시 효과를 줄 수 있습니다. 1234567891011121314151617&lt;head&gt; &lt;style&gt; .box&#123; background-color: skyblue; font-size: 40px; &#125; .box:hover&#123; background-color: pink; &#125; .box:focus&#123; background-color: orange; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;textarea class=\"box\"&gt;focus&lt;/textarea&gt;&lt;/body&gt; 위와 같이 focus라는 textarea를 만들게 되면 아래와 같이 기본상태는 하늘색입니다.마우스를 textarea에 올리게 되면 아래와 같이 핑크로 변하게 됩니다.하지만 focus가 들어오게 되면 마우스가 올려지더라도 focus효과가 우선 적용되기 때문에 아래와 같이 오렌지색으로 변하게 됩니다. focus가 되어있는지는 테두리에 하늘색으로 둘러져 있는 표시를 보고 알 수 있습니다.","categories":[{"name":"frontend","slug":"frontend","permalink":"https://swtpumpkin.github.io/categories/frontend/"},{"name":"css","slug":"frontend/css","permalink":"https://swtpumpkin.github.io/categories/frontend/css/"}],"tags":[{"name":"web","slug":"web","permalink":"https://swtpumpkin.github.io/tags/web/"},{"name":"css","slug":"css","permalink":"https://swtpumpkin.github.io/tags/css/"},{"name":"element states","slug":"element-states","permalink":"https://swtpumpkin.github.io/tags/element-states/"},{"name":"focus","slug":"focus","permalink":"https://swtpumpkin.github.io/tags/focus/"},{"name":"hover","slug":"hover","permalink":"https://swtpumpkin.github.io/tags/hover/"}]},{"title":"position","slug":"frontend/css/position","date":"2017-12-05T07:00:00.000Z","updated":"2020-01-08T04:06:19.007Z","comments":true,"path":"frontend/css/position/","link":"","permalink":"https://swtpumpkin.github.io/frontend/css/position/","excerpt":"","text":"positionposition프로퍼티는 요소의 위치를 지정합니다. position의 종류는 4가지가 있습니다. staticstatic은 position의 기본값으로 기본적인 요소의 배치 순서에 따라 위에서 아래로, 좌에서 우로 배치됩니다. 123456789101112131415161718192021222324&lt;head&gt; &lt;style&gt; #boxOne&#123; height: 300px; width: 300px; background-color: yellow; position: static; &#125; #boxTwo&#123; height: 300px; width: 300px; background-color: green; position: static; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"boxOne\"&gt; &lt;div class=\"box-child\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;div id=\"boxTwo\"&gt; &lt;div class=\"box-child\"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt; 위 코드로 작성하면 아래와 같이 두개의 박스가 생성되고 position이 static이므로 기본상태로 배치됩니다. fixedfixed는 부모의 요소와 관계없이 브라우저의 화면에 고정되어 스크롤로 이동하더라도 화면에서 사라지지 않고 항상 같은곳에 고정됩니다. 123456789101112131415161718192021222324&lt;head&gt; &lt;style&gt; #boxOne&#123; height: 300px; width: 300px; background-color: yellow; position: static; &#125; #boxTwo&#123; height: 300px; width: 300px; background-color: green; position: fixed; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"boxOne\"&gt; &lt;div class=\"box-child\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;div id=\"boxTwo\"&gt; &lt;div class=\"box-child\"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt; 위 코드로 작성하게 되면 boxOne은 기본값이므로 왼쪽위에 고정되어 스크롤 하게 되어도 페이지를 따라 올라가게 됩니다. 하지만 boxTwo는 fixed값을 주었기때문에 브라우저에 고정되고 스크롤로 이동하더라도 고정된 위치에 있게 됩니다. absolute부모 요소 또는 조상 요소를 기준으로 위치가 결정됩니다. 하지만 부모 또는 조상요소에 position: relative;가 선언되지 않았다면 브라우저 화면을 기준으로 좌표값에 맞게 위치하게 됩니다. 따라서 조상요소에 position: relative;를 선언해주어야 원하는 위치에 놓을 수 있습니다. 12345678910111213141516171819202122232425&lt;head&gt; &lt;style&gt; body&#123; height: 400; background-color: red; &#125; .abs-box&#123; width: 400px; height: 400px; background: yellow; &#125; .abs-child&#123; width: 100px; height: 100px; background-color: green; position: absolute; right: 0; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"abs-box\"&gt; &lt;div class=\"abs-child\"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt; 위 코드대로 작성하게 되면 abs-box의 자식요소로 abs-child가 있지만 abs-child는 아래와 같이 부모요소를 벗어나 브라우저 화면의 오른쪽에 붙게 됩니다. relativeabsolute를 사용하기 위해 부모 요소에 relative를 사용합니다.위와 같이 부모요소를 벗어난 자식요소를 부모요소 안에 넣기 위해서는 부모요소에 relative를 선언해주어야합니다. 1234567891011121314151617181920212223242526&lt;head&gt; &lt;style&gt; body&#123; height: 400; background-color: red; &#125; .abs-box&#123; width: 400px; height: 400px; background: yellow; position: relative; &#125; .abs-child&#123; width: 100px; height: 100px; background-color: green; position: absolute; right: 0; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"abs-box\"&gt; &lt;div class=\"abs-child\"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt; 위 코드와 같이 부모요소에 position: relative;를 선언하게 되면 아래와 같이 부모요소 안으로 자식요소가 들어오게 됩니다.","categories":[{"name":"frontend","slug":"frontend","permalink":"https://swtpumpkin.github.io/categories/frontend/"},{"name":"css","slug":"frontend/css","permalink":"https://swtpumpkin.github.io/categories/frontend/css/"}],"tags":[{"name":"web","slug":"web","permalink":"https://swtpumpkin.github.io/tags/web/"},{"name":"css","slug":"css","permalink":"https://swtpumpkin.github.io/tags/css/"},{"name":"absolute","slug":"absolute","permalink":"https://swtpumpkin.github.io/tags/absolute/"},{"name":"fixed","slug":"fixed","permalink":"https://swtpumpkin.github.io/tags/fixed/"},{"name":"position","slug":"position","permalink":"https://swtpumpkin.github.io/tags/position/"},{"name":"relative","slug":"relative","permalink":"https://swtpumpkin.github.io/tags/relative/"},{"name":"static","slug":"static","permalink":"https://swtpumpkin.github.io/tags/static/"}]},{"title":"display","slug":"frontend/css/display","date":"2017-12-05T06:00:00.000Z","updated":"2020-01-08T04:06:19.007Z","comments":true,"path":"frontend/css/display/","link":"","permalink":"https://swtpumpkin.github.io/frontend/css/display/","excerpt":"","text":"displaydisplay는 layout에서 자주 사용하는 property입니다. 이름 설명 inline inline특성을 갖는 요소로 지정합니다. inline-block block의 형태를 유지하는 inline특성을 갖는 요소로 지정합니다. block block특성을 갖는 요소로 지정합니다. inlineinline특성은 contents의 크기만큼 폭과 높이를 갖게 됩니다. 줄을 바꾸지 않고 다른요소와 한 행에 위치하게 됩니다. 12345678910111213&lt;head&gt; .box&#123; background-color: red; width: 200px; height: 200px; border: 2px solid black; &#125;&lt;/head&gt;&lt;body&gt; &lt;div class=\"box\"&gt;&lt;/div&gt; &lt;div class=\"box\"&gt;&lt;/div&gt; &lt;div class=\"box\"&gt;&lt;/div&gt;&lt;/body&gt; 위 코드와 같이 지정하게되면 아래와 같이 3개의 박스가 만들어지게 되고 1박스당 전체 폭을 갖습니다. div는 기본적으로 block의 특성을 갖기 때문에 전체 폭을 갖게 되는 것입니다. 1234567891011121314&lt;head&gt; .box&#123; background-color: red; width: 200px; height: 200px; border: 2px solid black; display: inline; &#125;&lt;/head&gt;&lt;body&gt; &lt;div class=\"box\"&gt;&lt;/div&gt; &lt;div class=\"box\"&gt;&lt;/div&gt; &lt;div class=\"box\"&gt;&lt;/div&gt;&lt;/body&gt; display:inline;으로 지정하게되면 아래와 같이 box의 모든 property값을 지우게 됩니다. 1234567891011121314&lt;head&gt; .box&#123; background-color: red; width: 200px; height: 200px; border: 2px solid black; display: inline; &#125;&lt;/head&gt;&lt;body&gt; &lt;div class=\"box\"&gt;1&lt;/div&gt; &lt;div class=\"box\"&gt;2&lt;/div&gt; &lt;div class=\"box\"&gt;3&lt;/div&gt;&lt;/body&gt; 따라서 box에 값을 지정하게 되면 contents의 폭과 높이를 갖게 됩니다. inline-blockinline-block은 inline요소의 특징과 block요소의 특징을 모두 갖게 됩니다. 따라서 inline요소와 같이 한 행에 표현되고 block요소와 같이 width와 height를 갖게 됩니다.display에 아무 속성을 지정하지 않는다면 위와 같이 block요소의 특징처럼 1box당 전체의 폭을 갖게 됩니다. 1234567891011121314&lt;head&gt; .box&#123; background-color: red; width: 200px; height: 200px; border: 2px solid black; display: inline-block; &#125;&lt;/head&gt;&lt;body&gt; &lt;div class=\"box\"&gt;&lt;/div&gt; &lt;div class=\"box\"&gt;&lt;/div&gt; &lt;div class=\"box\"&gt;&lt;/div&gt;&lt;/body&gt; 위와 같이 display의 값을 inline-block으로 지정하게 되면 아래와 같이 같은 행에 box들이 나열되게 됩니다. blockblock요소는 inline요소와는 다르게 한 행당 하나의 block만 위치 할 수 있습니다. block요소의 특징은 화면 크기 전체의 가로폭을 갖고 항상 새로운 라인에서 시작합니다. 12345678910111213&lt;head&gt; .box&#123; background-color: red; width: 200px; height: 200px; border: 2px solid black; &#125;&lt;/head&gt;&lt;body&gt; &lt;div class=\"box\"&gt;&lt;/div&gt; &lt;div class=\"box\"&gt;&lt;/div&gt; &lt;div class=\"box\"&gt;&lt;/div&gt;&lt;/body&gt; 위와 같이 div요소는 블록레벨요소로써 항상 block의 특징을 갖기 때문에 display: block;값이 기본입니다. 따라서 display값을 사용하지 않더라도 아래와 같이 block의 특징을 갖게 됩니다.","categories":[{"name":"frontend","slug":"frontend","permalink":"https://swtpumpkin.github.io/categories/frontend/"},{"name":"css","slug":"frontend/css","permalink":"https://swtpumpkin.github.io/categories/frontend/css/"}],"tags":[{"name":"web","slug":"web","permalink":"https://swtpumpkin.github.io/tags/web/"},{"name":"css","slug":"css","permalink":"https://swtpumpkin.github.io/tags/css/"},{"name":"display","slug":"display","permalink":"https://swtpumpkin.github.io/tags/display/"},{"name":"inline","slug":"inline","permalink":"https://swtpumpkin.github.io/tags/inline/"},{"name":"inline-block","slug":"inline-block","permalink":"https://swtpumpkin.github.io/tags/inline-block/"}]},{"title":"box model","slug":"frontend/css/boxModel","date":"2017-12-05T05:00:00.000Z","updated":"2020-01-08T04:06:19.007Z","comments":true,"path":"frontend/css/boxModel/","link":"","permalink":"https://swtpumpkin.github.io/frontend/css/boxModel/","excerpt":"","text":"box modelBox model은 콘텐츠(Contents), 패딩(Padding), 보더(Border), 마진(Margin)으로 구성되어 있습니다. 이름 설명 contents 텍스트나 이미지가 위치합니다. padding 보더(border)안에 위치한 영역으로 기본적으로 투명입니다. border 테두리라고 생각하면 됩니다. margin 테두리 밖 영역으로 기본적으로 투명이지만 색상을 지정 할 수 없습니다. padding / margin propertypadding과 margin은 상,하,좌,우 네방향에 대해 프로퍼티를 각 각 지정 할 수 있습니다. 12345678910div &#123; padding-top: 10px; padding-bottom: 10px; padding-left: 10px; padding-right: 10px; margin-top: 10px; margin-bottom: 10px; margin-left: 10px; margin-right: 10px;&#125; 위 css와 같이 상,하,좌,우에 대해 각각 프로퍼티를 지정 할 수 있는데 위와 같이 4방향의 값이 동일하다면 -top, -bottom, -left, -right를 사용하지 않고 한번에 지정 할 수 있습니다. 개수 설명 4개 padding 또는 margin뒤에 4개의 값을 지정해주면 상,우,하,좌와 같이 시계방향으로 값이 지정됩니다. 3개 padding 또는 margin뒤에 3개의 값을 지정해주면 상,좌 and 우, 하 순으로 값이 지정됩니다. 2개 padding 또는 margin뒤에 2개의 값을 지정해주면 상 and 하, 좌 and 우 순으로 값이 지정됩니다. 1개 padding 또는 margin뒤에 1개의 값을 지정해주면 상,하,좌,우 모두 같은 값으로 지정됩니다. 123div&#123; padding: 10px, 8px, 6px, 4px;&#125; border propertyborder의 프로퍼티는 width, style, color, radius로 구성되어 있습니다. border styleborder-style은 테두리의 스타일을 지정하는 property입니다. border-style은 여러가지가 있고 mdn문서를 참고하시기 바랍니다. 123div&#123; border-style: dotted;&#125; 위와 같이 border-style을 dotted로 지정해주면 아래와 같이 점선으로 표시됩니다.dotted이외에도 여러가지 style을 적용 할 수 있습니다. border widthborder-width는 테두리의 두께를 지정하는 property입니다. border-width 또한 여러가지가 있고 mdn문서를 참고하시기 바랍니다. 1234div&#123; border-style: solid; border-width: 10px;&#125; 위와 같이 border-width를 10px로 지정해주면 아래와 같이 테두리의 두께가 10px로 지정할 수 있습니다.border-width는 네 방향 각각 값을 지정 할 수 있고 위 padding / margin과 같이 동일한 shorthand가 있습니다. border colorborder-color는 테두리의 색상을 지정하는 property입니다. border-color색상을 지정하지 않으면 기본값은 검정색입니다. border-color 또한 여러가지가 있고 mdn문서를 참고하시기 바랍니다. 12345div&#123; border-style: solid; border-width: 10px; border-color: red;&#125; 위와 같이 border-color를 red로 지정해주면 아래와 같이 테두리의 색상을 red로 지정할 수 있습니다. border radiusborder-radius는 테두리의 모서리를 둥굴게 지정하는 property입니다. border-radius 또한 여러가지가 있고 mdn문서를 참고하시기 바랍니다. 프로퍼티 값은 길이를 나타내는 단위(px, em 등)와 %를 사용합니다. 12345678div&#123; width: 50px; height: 50px; border-style: solid; border-width: 10px; border-color: red; border-radius: 50px;&#125; 위와 같이 div의 width height길이와 border-radius길이를 같게 해주면 동그라미로 나타낼 수 있습니다.동그라미 이외에도 타원형과 같이 모양을 만들 수 있고 모서리마다 다르게 굴곡을 지정 할 수 있습니다.","categories":[{"name":"frontend","slug":"frontend","permalink":"https://swtpumpkin.github.io/categories/frontend/"},{"name":"css","slug":"frontend/css","permalink":"https://swtpumpkin.github.io/categories/frontend/css/"}],"tags":[{"name":"web","slug":"web","permalink":"https://swtpumpkin.github.io/tags/web/"},{"name":"css","slug":"css","permalink":"https://swtpumpkin.github.io/tags/css/"},{"name":"border","slug":"border","permalink":"https://swtpumpkin.github.io/tags/border/"},{"name":"box model","slug":"box-model","permalink":"https://swtpumpkin.github.io/tags/box-model/"},{"name":"content","slug":"content","permalink":"https://swtpumpkin.github.io/tags/content/"},{"name":"margin","slug":"margin","permalink":"https://swtpumpkin.github.io/tags/margin/"},{"name":"padding","slug":"padding","permalink":"https://swtpumpkin.github.io/tags/padding/"}]},{"title":"Mixing CSS with HTML","slug":"frontend/css/mixCssHtml","date":"2017-12-05T04:00:00.000Z","updated":"2020-01-08T04:06:19.007Z","comments":true,"path":"frontend/css/mixCssHtml/","link":"","permalink":"https://swtpumpkin.github.io/frontend/css/mixCssHtml/","excerpt":"","text":"CSS와 HTML의 연결 방법CSS와 HTML의 연결 방법에는 inline방법과 external방법 2가지가 있습니다. inlineinline으로 CSS를 사용하는 방법은 HTML내에서 CSS를 직접 사용하는 방식입니다. 1234567&lt;head&gt; &lt;style&gt; body&#123; background-color: red; &#125; &lt;/style&gt;&lt;/head&gt; 위 HTML문서와 같이 head 태그 안에 style 태그를 사용하여 직접 CSS를 적용 할 수 있는데 이렇게 사용하게 되면 모든 HTML문서의 body요소의 background-color가 같은 경우 모든 HTML페이지마다 똑같이 사용해주어야 합니다. 따라서 시간적으로 비효율 적이므로 CSS파일을 따로 만들어 연결해주는 external방식이 효율적입니다. externalexternal방식은 외부에 CSS파일을 만들어 HTML의 head태그에 링크로 연결하는 방식입니다. 123&lt;head&gt; &lt;link rel=\"stylesheet\" href=\"style.css\"&gt;&lt;/head&gt; 위 HTML문서와 같이 style.css라는 파일을 link로 연결해주게 되면 연결되어있는 모든 HTML 파일은 style.css에서 한번만 변경해주게 되면 한번에 적용됩니다. 따라서 1개가 변경되었을 때 inline으로 사용하게 되면 HTML문서마다 수정해줘야하는 불편을 없앨 수 있습니다.","categories":[{"name":"frontend","slug":"frontend","permalink":"https://swtpumpkin.github.io/categories/frontend/"},{"name":"css","slug":"frontend/css","permalink":"https://swtpumpkin.github.io/categories/frontend/css/"}],"tags":[{"name":"web","slug":"web","permalink":"https://swtpumpkin.github.io/tags/web/"},{"name":"html","slug":"html","permalink":"https://swtpumpkin.github.io/tags/html/"},{"name":"css","slug":"css","permalink":"https://swtpumpkin.github.io/tags/css/"},{"name":"inline","slug":"inline","permalink":"https://swtpumpkin.github.io/tags/inline/"},{"name":"external","slug":"external","permalink":"https://swtpumpkin.github.io/tags/external/"}]},{"title":"property","slug":"frontend/css/property","date":"2017-12-05T03:00:00.000Z","updated":"2020-01-08T04:06:19.007Z","comments":true,"path":"frontend/css/property/","link":"","permalink":"https://swtpumpkin.github.io/frontend/css/property/","excerpt":"","text":"proportyselector로 HTML의 요소를 선택하고 중괄호({})안에 property와 property-value를 지정 할 수 있습니다. property는 이미 정해져있으므로 표준스펙을 참고하시기 바랍니다. 1property:property-value; 위 CSS에서처럼 property와 property-value는 colon(:)으로 구분되어 있고, 마지막에는 semicolon(;)으로 끝납니다. property는 모두 소문자로 구성되어있고 space가 없습니다. property-value값의 선언이 끝나게 되면 semicolon(;)으로 꼭 닫아주시기 바랍니다. 12345selector &#123; property:property-value; property:property-value; property:property-value;&#125; 위 CSS와 같이 중괄호({}) 안에 다양한 property사용이 가능합니다.","categories":[{"name":"frontend","slug":"frontend","permalink":"https://swtpumpkin.github.io/categories/frontend/"},{"name":"css","slug":"frontend/css","permalink":"https://swtpumpkin.github.io/categories/frontend/css/"}],"tags":[{"name":"syntax","slug":"syntax","permalink":"https://swtpumpkin.github.io/tags/syntax/"},{"name":"web","slug":"web","permalink":"https://swtpumpkin.github.io/tags/web/"},{"name":"css","slug":"css","permalink":"https://swtpumpkin.github.io/tags/css/"},{"name":"property","slug":"property","permalink":"https://swtpumpkin.github.io/tags/property/"}]},{"title":"selector","slug":"frontend/css/select","date":"2017-12-05T02:00:00.000Z","updated":"2020-01-08T04:06:19.007Z","comments":true,"path":"frontend/css/select/","link":"","permalink":"https://swtpumpkin.github.io/frontend/css/select/","excerpt":"","text":"selectorCSS는 HTML의 style을 정의할 때 사용한다. 이때 HTML의 요소를 선택하여 CSS를 적용해야하는데 이때 HTML의 요소를 선택하는 것이 selector(선택자)입니다. 1234h1 &#123; color:...; size:...;&#125; 위 CSS에서 h1은 선택자입니다. 위 코드처럼 작성하면 h1이라는 HTML의 모든 요소를 선택하여 color와 size를 지정 할 수 있습니다. 1234#id &#123; color:...; size:...;&#125; 위 처럼 id를 selector로 사용하는 경우에는 #을 앞에 붙여줘야 합니다.","categories":[{"name":"frontend","slug":"frontend","permalink":"https://swtpumpkin.github.io/categories/frontend/"},{"name":"css","slug":"frontend/css","permalink":"https://swtpumpkin.github.io/categories/frontend/css/"}],"tags":[{"name":"syntax","slug":"syntax","permalink":"https://swtpumpkin.github.io/tags/syntax/"},{"name":"web","slug":"web","permalink":"https://swtpumpkin.github.io/tags/web/"},{"name":"css","slug":"css","permalink":"https://swtpumpkin.github.io/tags/css/"},{"name":"selector","slug":"selector","permalink":"https://swtpumpkin.github.io/tags/selector/"}]},{"title":"id / class","slug":"frontend/html/idClass","date":"2017-12-04T23:00:00.000Z","updated":"2020-01-08T04:06:19.007Z","comments":true,"path":"frontend/html/idClass/","link":"","permalink":"https://swtpumpkin.github.io/frontend/html/idClass/","excerpt":"","text":"Attribute Description id 유일한 식별자로써 중복지정이 불가능하다. class 중복지정이 가능하다. # id? id는 element마다 하나의 값만 갖을 수 있다. 주민등록번호 또는 여권번호와 같이 고유한 값만 갖을 수 있습니다. 따라서 주민등록번호와 여권번호가 중복되지 않듯이 id값도 중복선언이 되지 않습니다. class?class는 여러가지를 중복 사용 할 수 있습니다. 사람들의 이름과 같다고 생각하면 됩니다. 이름은 고유 값이 아니기 때문에 살다보면 이름이 같은 사람들을 종종 만나는 경우가 있습니다. 따라서 class는 중복 선언이 가능하기 때문에 여러번 사용이 가능합니다. 1234&lt;div id=\"divNemberOne\" class=\"defaultClass\"&gt;&lt;/div&gt;&lt;div id=\"divNembertwo\" class=\"defaultClass\"&gt;&lt;/div&gt; 따라서 위외 같이 id는 한번만 사용 가능하지만 class는 중복 사용이 가능합니다. CSS를 사용 할 때 동일한 속성이 있을 때마다 class로 지정하여 class를 적절히 사용하면 중복 선언을 줄일 수 있습니다.","categories":[{"name":"frontend","slug":"frontend","permalink":"https://swtpumpkin.github.io/categories/frontend/"},{"name":"html","slug":"frontend/html","permalink":"https://swtpumpkin.github.io/categories/frontend/html/"}],"tags":[{"name":"web","slug":"web","permalink":"https://swtpumpkin.github.io/tags/web/"},{"name":"html","slug":"html","permalink":"https://swtpumpkin.github.io/tags/html/"},{"name":"id","slug":"id","permalink":"https://swtpumpkin.github.io/tags/id/"},{"name":"class","slug":"class","permalink":"https://swtpumpkin.github.io/tags/class/"}]},{"title":"semantic / non-semantic tag","slug":"frontend/html/semantic","date":"2017-12-04T00:00:00.000Z","updated":"2020-01-08T04:06:19.008Z","comments":true,"path":"frontend/html/semantic/","link":"","permalink":"https://swtpumpkin.github.io/frontend/html/semantic/","excerpt":"","text":"semantic tag?semantic태그는 의미가 있는 태그이다. 예를들어 h1태그는 header 1이란 뜻으로 태그 자체가 의미를 갖고 있습니다. section, article, header와 같이 태그 자체가 무엇을 의미하는지 알 수 있는 태그가 있습니다. non-semantic tag?non-semantic태그는 아무런 의미가 없는 태그이다. 예를들어 div태그는 말 그대로 division이고 아무런 의미를 갖는 태그는 아닙니다. div는 주로 컨테이너, 박스의 용도와 같이 안에 내용물을 담는 용도로 사용하게 됩니다. span태그도 마찬가지로 아무런 의미가 없습니다. span은 짧다는 뜻을 갖고있는데 이 태그가 짧은 문장인지 문단인건지 태그로는 전혀 알 수 없습니다. span태그는 텍스트를 위한 컨테이너 또는 박스와 같은 의미로 생각하면 되고 텍스트를 위한 컨테이너가 필요할 때 span태그를 사용하면 됩니다.","categories":[{"name":"frontend","slug":"frontend","permalink":"https://swtpumpkin.github.io/categories/frontend/"},{"name":"html","slug":"frontend/html","permalink":"https://swtpumpkin.github.io/categories/frontend/html/"}],"tags":[{"name":"web","slug":"web","permalink":"https://swtpumpkin.github.io/tags/web/"},{"name":"html","slug":"html","permalink":"https://swtpumpkin.github.io/tags/html/"},{"name":"semantic","slug":"semantic","permalink":"https://swtpumpkin.github.io/tags/semantic/"},{"name":"non-semantic","slug":"non-semantic","permalink":"https://swtpumpkin.github.io/tags/non-semantic/"}]},{"title":"meta tag","slug":"frontend/html/metaTag","date":"2017-12-03T23:00:00.000Z","updated":"2020-01-08T04:06:19.007Z","comments":true,"path":"frontend/html/metaTag/","link":"","permalink":"https://swtpumpkin.github.io/frontend/html/metaTag/","excerpt":"","text":"meta tag?meta tag는 extra information입니다. 즉 추가 정보라고 생각하면 됩니다. meta tag는 브라우저를 위한 정보이고 유저를 위한 정보는 아닙니다. 그렇기 때문에 head tag안에 사용합니다. 과거에는 메타태그가 검색결과에 미치는 영향이 컷지만 상업적으로 악용하는 페이지가 많아 구글과 같은 검색엔진 회사에서는 요즘 메타태그 보다는 웹표준을 지켜 만든 웹사이트를 우선적으로 검색 결과에 노출시켜준다고 합니다. charset123&lt;head&gt; &lt;meta charset=\"utf-8\"&gt;&lt;/head&gt; charactor encoding이라는 것이고 UTF-8로 설정합니다. charset은 만든 웹사이트가 어떤 언어로 되어있는지 브라우저에게 알려줍니다. charset을 잘 못 설정하게 되면 웹사이트는 언어를 해독하지 못하여 ��蠍�덩어리로 표현됩니다. 1&lt;meta charset=\"euc-jp\"&gt; 위와 같이 언어를 일본어로 설정하고 12345&lt;body&gt; &lt;h1&gt; 한글 &lt;/h1&gt;&lt;/body&gt; 바디 태그 안에 한글을 사용하게 되면위와 같이 한글인식이 되지않아 글씨가 깨지게 됩니다. name12345&lt;head&gt; &lt;meta name=\"author\" content=\"swtpumpkin\"&gt; &lt;meta name=\"description\" content=\"Welcom to my HTML page\"&gt; &lt;meta name=\"keyword\" content=\"kakao, clone, study\"&gt;&lt;/head&gt; name의 속성은 meta tag의 요소에서 문서를 정의합니다. attribute content author 페이지의 저자를 의미합니다. description 페이지의 내용을 설명하는 문자열을 지정 할 수 있습니다. keyword 페이지와 관계있는 키워드를 작성합니다. 콤마(,)로 구분합니다. ectmeta tag는 이 외에도 facebook, naver, twitter등 특정한 곳에서 사용되는 태그가 있습니다.","categories":[{"name":"frontend","slug":"frontend","permalink":"https://swtpumpkin.github.io/categories/frontend/"},{"name":"html","slug":"frontend/html","permalink":"https://swtpumpkin.github.io/categories/frontend/html/"}],"tags":[{"name":"web","slug":"web","permalink":"https://swtpumpkin.github.io/tags/web/"},{"name":"html","slug":"html","permalink":"https://swtpumpkin.github.io/tags/html/"},{"name":"meta tag","slug":"meta-tag","permalink":"https://swtpumpkin.github.io/tags/meta-tag/"}]},{"title":"hexo markdown table 사용법","slug":"git/hexo/hexoTable","date":"2017-12-03T23:00:00.000Z","updated":"2020-01-08T04:06:19.010Z","comments":true,"path":"git/hexo/hexoTable/","link":"","permalink":"https://swtpumpkin.github.io/git/hexo/hexoTable/","excerpt":"","text":"tablehexo를 사용하면서 블로깅 시 table 작성이 필요할 경우가 생깁니다. table을 작성하려고 할 때 계속 에러가 났는데 해결방법을 찾아 블로깅 합니다! 사용방법12345|컬럼1|컬럼2||:-:|:-:||값1-1|값2-1||값1-2|값2-2||값1-3|값2-3| 위와 같이 작성하면 됩니다. 12345|컬럼1|컬럼2|컬럼3||:-:|:-:|:-:||값1-1|값2-1|값3-1||값1-2|값2-2|값3-2||값1-3|값2-3|값3-3| 컬럼이 늘어나게 되면 똑같은 양식으로 작성합니다. 주의사항hexo사용 시 md(markdown)을 사용하게 되는데 다음과 같이 작성하면 문제가 생기게 됩니다. 123456test|컬럼1|컬럼2||:-:|:-:||값1-1|값2-1||값1-2|값2-2||값1-3|값2-3| 문제점이 무엇인지 딱 봐서는 모르겠지만! 위의 코드와 같이 작성하게 되면 문제가 발생합니다. 자세히 보면 table작성을 문자열(‘test’) 바로 다음줄부터 작성을 하였습니다. 그렇게 되면 아래와 같이 table은 작성이 안되고 쓴 그대로 페이지에 표출됩니다.꼭 주의하셔야 할 점은! 띄어쓰기 입니다. 띄어쓰기를 하지 않는다면 문법에 맞게 작성하였더라도 위 사진과 같이 md에서 작성한 문법과 동일하게 표출됩니다. 123456 |컬럼1|컬럼2||:-:|:-:||값1-1|값2-1||값1-2|값2-2||값1-3|값2-3| 위 코드와 같이 한줄을 띄어쓰기 하고 table을 작성해야 아래와 같이 table이 잘 작성됩니다. 컬럼1 컬럼2 값1-1 값2-1 값1-2 값2-2 값1-3 값2-3 1234567|컬럼1|컬럼2||:-:|:-:||값1-1|값2-1||값1-2|값2-2||값1-3|값2-3|다음 줄에 바로 작성하고 있다. 위 코드처럼 table을 작성하면 컬럼1 컬럼2 값1-1 값2-1 값1-2 값2-2 값1-3 값2-3 다음 줄에 바로 작성하고 있다. 위 테이블 결과와 같이 내용을 작성하더라도 table은 잘 작성되니 꼭 table만드 실 때 첫 줄은 띄어쓰기 하시기 바랍니다.","categories":[{"name":"git","slug":"git","permalink":"https://swtpumpkin.github.io/categories/git/"},{"name":"hexo","slug":"git/hexo","permalink":"https://swtpumpkin.github.io/categories/git/hexo/"}],"tags":[{"name":"table","slug":"table","permalink":"https://swtpumpkin.github.io/tags/table/"},{"name":"hexo","slug":"hexo","permalink":"https://swtpumpkin.github.io/tags/hexo/"},{"name":"헥소","slug":"헥소","permalink":"https://swtpumpkin.github.io/tags/%ED%97%A5%EC%86%8C/"},{"name":"markdown","slug":"markdown","permalink":"https://swtpumpkin.github.io/tags/markdown/"},{"name":"md","slug":"md","permalink":"https://swtpumpkin.github.io/tags/md/"}]},{"title":"iterm2","slug":"develop/iterm2","date":"2017-11-27T01:00:00.000Z","updated":"2020-01-08T04:06:19.005Z","comments":true,"path":"develop/iterm2/","link":"","permalink":"https://swtpumpkin.github.io/develop/iterm2/","excerpt":"","text":"iterm2?멋진 개발 환경을 위해 또는 zsh를 사용하기 위해 iterm2를 많이 사용합니다. 테마를 적용하려면 더욱 멋진 개발환경을 사용 할 수 있습니다. 설치방법iterm2홈페이지에 가서 iterm2를 다운로드합니다.다운로드 받은 파일을 압축 해제 후 응용프로그램에 넣어줍니다.독에 iterm2를 위와 같은 방법으로 유지시켜주게 되면 iterm2을 완전히 종료하더라도 독에 유지 할 수 있습니다.","categories":[{"name":"develop","slug":"develop","permalink":"https://swtpumpkin.github.io/categories/develop/"}],"tags":[{"name":"develop","slug":"develop","permalink":"https://swtpumpkin.github.io/tags/develop/"},{"name":"mac","slug":"mac","permalink":"https://swtpumpkin.github.io/tags/mac/"},{"name":"개발환경설정","slug":"개발환경설정","permalink":"https://swtpumpkin.github.io/tags/%EA%B0%9C%EB%B0%9C%ED%99%98%EA%B2%BD%EC%84%A4%EC%A0%95/"},{"name":"iterm2","slug":"iterm2","permalink":"https://swtpumpkin.github.io/tags/iterm2/"}]},{"title":"nvm","slug":"develop/nvm","date":"2017-11-27T00:00:00.000Z","updated":"2020-01-08T04:06:19.006Z","comments":true,"path":"develop/nvm/","link":"","permalink":"https://swtpumpkin.github.io/develop/nvm/","excerpt":"","text":"nvmnvm(Node Version Manager)이란? 말 그대로 노드의 버전을 관리해주는 것으로 node 개발 환경이라면 버전을 바꿔가며 개발하는 경우가 있는데 nvm을 통해 버전관리를 할 수 있습니다. 설치방법1curl -o- https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;creationix&#x2F;nvm&#x2F;v0.31.4&#x2F;install.sh | bash 위 명령어를 터미널에서 실행합니다. nvm 0.31.4버전을 설치하는 코드입니다. 현재 가장 최신의 nvm 버전입니다. 추후 업그레이드 하게 되면 버전은 변경됩니다. nvm설치 후 터미널을 재시작합니다. 1vi ~&#x2F;.bash_profile vi에디터를 통해 위 파일을 실행합니다. 12export NVM_DIR&#x3D;&quot;$HOME&#x2F;.nvm&quot;[ -s &quot;$NVM_DIR&#x2F;nvm.sh&quot; ] &amp;&amp; . &quot;$NVM_DIR&#x2F;nvm.sh&quot; # This loads nvm 위 코드를 복사하여 실행된 파일에 붙여넣습니다. nvm은 설치되었지만 node는 설치되지 않았습니다.","categories":[{"name":"develop","slug":"develop","permalink":"https://swtpumpkin.github.io/categories/develop/"}],"tags":[{"name":"develop","slug":"develop","permalink":"https://swtpumpkin.github.io/tags/develop/"},{"name":"mac","slug":"mac","permalink":"https://swtpumpkin.github.io/tags/mac/"},{"name":"개발환경설정","slug":"개발환경설정","permalink":"https://swtpumpkin.github.io/tags/%EA%B0%9C%EB%B0%9C%ED%99%98%EA%B2%BD%EC%84%A4%EC%A0%95/"},{"name":"nvm","slug":"nvm","permalink":"https://swtpumpkin.github.io/tags/nvm/"}]},{"title":"brew","slug":"develop/brew","date":"2017-11-26T23:00:00.000Z","updated":"2020-01-08T04:06:19.005Z","comments":true,"path":"develop/brew/","link":"","permalink":"https://swtpumpkin.github.io/develop/brew/","excerpt":"","text":"homebrewmacOS 용 패키지 관리자입니다. 설치방법1&#x2F;usr&#x2F;bin&#x2F;ruby -e &quot;$(curl -fsSL https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;Homebrew&#x2F;install&#x2F;master&#x2F;install)&quot; 위 코드를 터미널에 작성 후 설치합니다. 1brew -v 위 코드를 이용하여 설치가 잘 되었는지 확인합니다. 12Homebrew 1.3.8Homebrew&#x2F;homebrew-core (git revision b66c; last commit 2017-11-27) 위와 같이 brew의 버전이 나온다면 설치가 잘 된 것 입니다. 2017년 11월 27일 현재 1.3.8 버전입니다.","categories":[{"name":"develop","slug":"develop","permalink":"https://swtpumpkin.github.io/categories/develop/"}],"tags":[{"name":"develop","slug":"develop","permalink":"https://swtpumpkin.github.io/tags/develop/"},{"name":"brew","slug":"brew","permalink":"https://swtpumpkin.github.io/tags/brew/"},{"name":"mac","slug":"mac","permalink":"https://swtpumpkin.github.io/tags/mac/"},{"name":"개발환경설정","slug":"개발환경설정","permalink":"https://swtpumpkin.github.io/tags/%EA%B0%9C%EB%B0%9C%ED%99%98%EA%B2%BD%EC%84%A4%EC%A0%95/"}]},{"title":"code ENOSELF","slug":"backend/node/codeEnoself","date":"2017-11-23T00:00:00.000Z","updated":"2020-01-08T04:06:19.003Z","comments":true,"path":"backend/node/codeEnoself/","link":"","permalink":"https://swtpumpkin.github.io/backend/node/codeEnoself/","excerpt":"","text":"code ENOSELF?npm을 이용하다보면 code ENOSELF에러를 간혹 보게 되는 경우가 있습니다. 뭔지 모르겠지만 이런 에러가 뜨면 너무 당황하게 됩니다. 검색을 해도 뭐가 뭔지 모르는 분들을 위해 설명드립니다. 에러의 이유!간단합니다.보통 이렇게 폴더를 만들고 1npm init -y 위 코드를 실행하여 package.json을 생성합니다. 123456789101112&#123; \"name\": \"sharp\", \"version\": \"1.0.0\", \"description\": \"\", \"main\": \"index.js\", \"scripts\": &#123; \"test\": \"echo \\\"Error: no test specified\\\" &amp;&amp; exit 1\" &#125;, \"keywords\": [], \"author\": \"\", \"license\": \"ISC\"&#125; 그러면 &quot;name&quot;: &quot;sharp&quot;부분이 sharp가 됩니다. 1npm install sharp --save 위 코드를 실행시키면 다음과 같이 에러가 발생하게 됩니다.json파일에 이미 sharp라는 이름이 있기때문에 sharp모듈이 설치가 안되는 것입니다. 따라서 name부분을 수정해주면 됩니다. 123456789101112&#123; \"name\": \"test\", \"version\": \"1.0.0\", \"description\": \"\", \"main\": \"index.js\", \"scripts\": &#123; \"test\": \"echo \\\"Error: no test specified\\\" &amp;&amp; exit 1\" &#125;, \"keywords\": [], \"author\": \"\", \"license\": \"ISC\"&#125; name을 모듈 이름과 겹치지 않게 설정하게 되면 code ENOSELF에러를 해결 할 수 있습니다.","categories":[{"name":"backend","slug":"backend","permalink":"https://swtpumpkin.github.io/categories/backend/"},{"name":"node","slug":"backend/node","permalink":"https://swtpumpkin.github.io/categories/backend/node/"}],"tags":[{"name":"node","slug":"node","permalink":"https://swtpumpkin.github.io/tags/node/"},{"name":"javascript","slug":"javascript","permalink":"https://swtpumpkin.github.io/tags/javascript/"},{"name":"error","slug":"error","permalink":"https://swtpumpkin.github.io/tags/error/"},{"name":"npm","slug":"npm","permalink":"https://swtpumpkin.github.io/tags/npm/"},{"name":"code enoself","slug":"code-enoself","permalink":"https://swtpumpkin.github.io/tags/code-enoself/"}]},{"title":"multer","slug":"backend/node/multer","date":"2017-11-22T23:00:00.000Z","updated":"2020-01-08T04:06:19.004Z","comments":true,"path":"backend/node/multer/","link":"","permalink":"https://swtpumpkin.github.io/backend/node/multer/","excerpt":"","text":"multer?node.js에서 파일을 업로드 하려면 multer모듈을 사용해 파일 업로드가 가능합니다. 파일 업로드를 도와주는 모듈이라고 생각하시면 됩니다. 기본환경 설정위와 같이 파일, 폴더 환경을 구성합니다. uploads폴더는 업로드 된 파일이 저장되는 폴더입니다. 12345block content form(action='/upload', method='post', enctype=\"multipart/form-data\") label input(type='file', name='file', required) button(type='submit') 업로드 index.pug파일을 위와 같은 코드로 작성하게 되면 다음과 같이 익스플로러에 표시됩니다.enctype=&quot;multipart/form-data&quot;과 같이 enctype을 설정해주어야 사용자가 전송한 파일을 서버로 전송 할 수 있습니다. multer 설정1npm install multer --save 위 코드를 통해 multer를 설치합니다. 12345const express = require('express')const multer = require('multer')const upload = multer(&#123; dest: 'uploads/'&#125;) multer를 require 해줍니다. upload는 multer를 통해 파일이 들어오면 저장될 위치를 설정하는 곳입니다. dest뒤 저장할 폴더를 설정합니다. 12345678910111213const PORT = 3003const app = express()app.set('view engine', 'pug')app.get('/', (req, res) =&gt; &#123; res.render('index.pug')&#125;)app.post('/upload', upload.single('file'), (req, res) =&gt; &#123; console.log(req.file) res.redirect('/')&#125;)app.listen(PORT, () =&gt; &#123; console.log(`listening $&#123;PORT&#125;...`)&#125;) pug를 사용하였기 때문에 app.set(&#39;view engine&#39;, &#39;pug&#39;)를 사용하여 셋팅하였습니다.여기서 주의 할 점은 upload.single의 괄호()안 내용이 post될 name이랑 같아야합니다. 위 사진을 꼭 참고 바랍니다.위와 같이 환경을 꾸며주게 되면 기본설정은 끝났습니다.하지만 이렇게 설정해주면 작은(?)문제가 발생합니다.위 사진과 같이 원본파일의 이름은 javascript.png파일이지만 저장되는 파일 이름은 a7ab2f0b7194e845b92d8f494b56d3ba로 알 수 없는 이름 그리고 확장자가 없어지게 됩니다.확장자가 사라져 어떤 파일인지 알아볼 수 없긴 하지만 사진파일은 열 수 있습니다. 하지만 확장자를 지정해주려면 약간의 커스텀이 필요합니다. multer 세부 설정123const upload = multer(&#123; dest: 'uploads/'&#125;) 이 업로드 부분을 수정하도록 하겠습니다. 123456789const customStorage = multer.diskStorage(&#123; destination: function (req, file, cb) &#123; cb(null, './uploads') &#125;, filename: function (req, file, cb) &#123; cb(null, file.originalname) &#125;&#125;)const upload = multer(&#123; storage: customStorage &#125;) upload로 설정된 변수를 위와 같이 변경하게 되면 파일을 업로드 할 때 원본의 이름 + 확장자가 저장됩니다. 여기서 파일 업로드 시 중복되게 된다면 filename 부분을 설정하면 됩니다.코드 option에 따라 설정을 변경하였더니 a7ab2f0b7194e845b92d8f494b56d3ba와 같이 알 수 없는 이름으로 저장되었던 파일이 javascript.png 파일로 저장 할 수 있게 되었습니다. 업로드 크기 파일을 제한 할 수 있습니다. 1const upload = multer(&#123; storage: customStorage &#125;) 이렇게 선언된 upload 변수에 옵션을 넣어주면 됩니다. 12345const maxsize = 1024 * 1024 // 1mbconst upload = multer(&#123; storage: storage, limits: &#123;fileSize: maxsize&#125;&#125;) maxsize변수를 선언하고 limits 옵션을 사용하여 파일 사이즈를 custom 할 수 있습니다.","categories":[{"name":"backend","slug":"backend","permalink":"https://swtpumpkin.github.io/categories/backend/"},{"name":"node","slug":"backend/node","permalink":"https://swtpumpkin.github.io/categories/backend/node/"}],"tags":[{"name":"node","slug":"node","permalink":"https://swtpumpkin.github.io/tags/node/"},{"name":"javascript","slug":"javascript","permalink":"https://swtpumpkin.github.io/tags/javascript/"},{"name":"npm","slug":"npm","permalink":"https://swtpumpkin.github.io/tags/npm/"},{"name":"multer","slug":"multer","permalink":"https://swtpumpkin.github.io/tags/multer/"},{"name":"파일업로드","slug":"파일업로드","permalink":"https://swtpumpkin.github.io/tags/%ED%8C%8C%EC%9D%BC%EC%97%85%EB%A1%9C%EB%93%9C/"}]},{"title":"mocha & chai","slug":"backend/node/mochaChai","date":"2017-11-20T00:00:00.000Z","updated":"2020-01-08T04:06:19.004Z","comments":true,"path":"backend/node/mochaChai/","link":"","permalink":"https://swtpumpkin.github.io/backend/node/mochaChai/","excerpt":"","text":"TDD?테스트 주도 개발(Test-driven development TDD)이라는 말로 소프트웨어 개발 프로세스 중 하나입니다. 개발자는 새로운 소프트웨어를 개발하기 전 자동화된 테스트 케이스를 작성하고 테스트를 통과하는 코드를 만들고 개발이 완료되면 리펙토링을 통해 코드 양을 줄여야합니다. 코드리펙토링 시 코드가 제대로 동작하는지 일일히 테스트 할 필요 없이 테스트 모듈을 실행하면 자동으로 테스트 할 수 있습니다. 테스트코드를 한번 작성하면 유지보수가 빠르게 진행 될 수 있고 개발기간이 짧아지면 개발비용 또한 줄일 수 있습니다. MochaJavascript를 이용하여 Node.js서버로 개발할 때 Mocah는 많은 개발자가 사용하는 테스트 모듈입니다. ChaiChai는 assertion을 위해 사용하는 라이브러리 입니다. 테스트 코드 초기 셋팅위 환경과 같이 test폴더를 만들고 app.js, appTest.js를 만듭니다. 1npm init -y 위 코드를 사용해서 package.json을 생성합니다. 123456789101112131415&#123; \"name\": \"mochatest\", \"version\": \"1.0.0\", \"description\": \"Simple app for testing.\", \"main\": \"app.js\", \"scripts\": &#123; \"test\": \"mocha\" &#125;, \"author\": \"\", \"license\": \"ISC\", \"dependencies\": &#123; \"chai\": \"^4.1.2\", \"mocha\": \"^4.0.1\" &#125;&#125; 위와 같이 package.json 파일을 작성합니다. scripts안에 test를 mocha로 작성하게 되면 1npm run test 위 코드를 실행 시 mocha가 실행되게 됩니다. 테스트 코드 작성123module.exports = () =&gt; &#123; return 'hello' &#125; app.js파일을 위와 같이 작성합니다. 위 코드는 app.js를 실행하게 되면 hello가 출력되도록 작성된 코드입니다. 1234567const assert = require('chai').assertconst app = require('../app')describe('App', () =&gt; &#123; it('app should return hello', () =&gt; &#123; assert.equal(app(), 'hello') &#125;)&#125;) appTest.js파일을 위와 같이 작성합니다. describe()로 테스트 공간을 만들고 it()안에 테스트 코드를 작성합니다. it()안에 문자열을 넣을 수 있는데 &#39;app should return hello&#39;와 같이 app.js파일이 실행되면 hello가 반환 된다는 설명을 넣을 수 있습니다. 1npm run test 위 코드를 실행하게 되면 아래와 같은 결과가 나오게 됩니다.만약 테스트의 결과가 잘 못 되게 된다면 아래와 같은 결과가 나오게 됩니다. 응용1234567891011module.exports = &#123; sayHello: () =&gt; &#123; return 'hello' &#125;, sayYeh: () =&gt; &#123; return 'yeh' &#125;, sayHaha: () =&gt; &#123; return 'haha' &#125;&#125; app.js파일에 여러개의 함수를 작성합니다. 123456789101112131415161718const assert = require('chai').assertconst sayHello = require('../app').sayHelloconst sayYeh = require('../app').sayYehconst sayHaha = require('../app').sayHahadescribe('App', () =&gt; &#123; it('sayHello should return hello', () =&gt; &#123; let result = sayHello() assert.equal(result, 'hello') &#125;) it('sayYeh should return yeh', () =&gt; &#123; let result = sayYeh() assert.equal(result, 'yeh') &#125;) it('sayHaha should return haha', () =&gt; &#123; let result = sayHaha() assert.equal(result, 'haha') &#125;)&#125;) appTest.js파일에 위와 같이 작성합니다. 1npm run test 위 코드를 실행하게 되면 아래와 같이 여러개의 함수를 한번에 실행 할 수 있습니다.이와 같이 함수의 실행 결과를 미리 작성하고 코드를 작성하게 된다면 일단 동작하는 코드를 작성 할 수 있고 코드 리펙토링을 하는데도 하나씩 테스트 할 필요 없이 테스트가 진행 될 수 있습니다.","categories":[{"name":"backend","slug":"backend","permalink":"https://swtpumpkin.github.io/categories/backend/"},{"name":"node","slug":"backend/node","permalink":"https://swtpumpkin.github.io/categories/backend/node/"}],"tags":[{"name":"node","slug":"node","permalink":"https://swtpumpkin.github.io/tags/node/"},{"name":"javascript","slug":"javascript","permalink":"https://swtpumpkin.github.io/tags/javascript/"},{"name":"npm","slug":"npm","permalink":"https://swtpumpkin.github.io/tags/npm/"},{"name":"mocha","slug":"mocha","permalink":"https://swtpumpkin.github.io/tags/mocha/"},{"name":"chai","slug":"chai","permalink":"https://swtpumpkin.github.io/tags/chai/"},{"name":"tdd","slug":"tdd","permalink":"https://swtpumpkin.github.io/tags/tdd/"}]},{"title":"validator","slug":"backend/node/validator","date":"2017-11-19T23:00:00.000Z","updated":"2020-01-08T04:06:19.004Z","comments":true,"path":"backend/node/validator/","link":"","permalink":"https://swtpumpkin.github.io/backend/node/validator/","excerpt":"","text":"validator?valid란 단어는 유효한이란 뜻을 갖고 있습니다. validator란 값이 유효한지 검증해주는 모듈입니다. 예를들어 회원가입 시 이메일에 대한 정보를 얻어야한다면 이메일 형식이 맞는지 하나하나 확인해야하는 경우가 있습니다. 하지만 validator 모듈을 사용하게 되면 바로 검증 할 수 있습니다. validator 사용방법1npm install validator 위 코드를 통해 validator를 설치해줍니다. 1const validator = require('validator') 사용할 자바스크립트 파일에서 위 코드를 요청하여 validator를 활성화 해줍니다.node REPL에서 실행해 볼 수 있습니다.위와 같이 터미널에서 validator를 활성화 해줍니다.위와 같이 이메일 형식에 맞으면 true 이메일 형식에 맞지 않으면 false를 반환합니다.이메일 형식 이외에도 많은 검증 모듈이 있습니다. 여기를 누르셔서 validator에서 제공하는 모듈이 어떤 것이 있는지 확인해주세요.","categories":[{"name":"backend","slug":"backend","permalink":"https://swtpumpkin.github.io/categories/backend/"},{"name":"node","slug":"backend/node","permalink":"https://swtpumpkin.github.io/categories/backend/node/"}],"tags":[{"name":"node","slug":"node","permalink":"https://swtpumpkin.github.io/tags/node/"},{"name":"javascript","slug":"javascript","permalink":"https://swtpumpkin.github.io/tags/javascript/"},{"name":"npm","slug":"npm","permalink":"https://swtpumpkin.github.io/tags/npm/"},{"name":"validator","slug":"validator","permalink":"https://swtpumpkin.github.io/tags/validator/"},{"name":"검증","slug":"검증","permalink":"https://swtpumpkin.github.io/tags/%EA%B2%80%EC%A6%9D/"}]},{"title":"hexo favicon(파비콘) 사용법","slug":"git/hexo/hexoFavicon","date":"2017-11-18T23:00:00.000Z","updated":"2020-01-08T04:06:19.010Z","comments":true,"path":"git/hexo/hexoFavicon/","link":"","permalink":"https://swtpumpkin.github.io/git/hexo/hexoFavicon/","excerpt":"","text":"파비콘이란?파비콘이란 웹페이지를 대표하는 아이콘입니다. 주소탭에 보면 위와 사진과 같이 빨간 네모 안에 호박이미지가 파비콘이라 할 수 있습니다. 파비콘 설정 방법위 사진에 보이는 경로와 같이 blog/themes/hueman/source/css/images/favicon.ico와 같은 동일한 경로로 설정할 favicon이미지를 넣습니다. 이 블로그는 hueman을 기반으로 만들어져있기 때문에 themes뒤 경로가 hueman입니다. 각 사용자마다 테마가 다르기때문에 테마에 맞게 경로를 설정 바랍니다.blog/themes/hueman/_config.yml경로에 있는 _config.yml파일에 customize부분의 favicon경로를 css/images/favicon.ico로 설정합니다. 파비콘 초기화 방법파비콘이 초기화 되지 않는다면 파비콘이 적용되지 않을 수 있습니다. 따라서 ~/Library/Application Support/Google/Chrome/Default/경로에 있는 favicon파일을 모두 삭제 후 리로딩해보시기 바랍니다. 파인더를 여시고 commend + shift + g를 누른 후 위 경로를 복사 붙여넣기 한다면 바로 접근 가능합니다.","categories":[{"name":"git","slug":"git","permalink":"https://swtpumpkin.github.io/categories/git/"},{"name":"hexo","slug":"git/hexo","permalink":"https://swtpumpkin.github.io/categories/git/hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://swtpumpkin.github.io/tags/hexo/"},{"name":"헥소","slug":"헥소","permalink":"https://swtpumpkin.github.io/tags/%ED%97%A5%EC%86%8C/"},{"name":"favicon","slug":"favicon","permalink":"https://swtpumpkin.github.io/tags/favicon/"},{"name":"파비콘","slug":"파비콘","permalink":"https://swtpumpkin.github.io/tags/%ED%8C%8C%EB%B9%84%EC%BD%98/"}]},{"title":"passport-local","slug":"backend/node/passportLocal","date":"2017-11-12T23:00:00.000Z","updated":"2020-01-08T04:06:19.004Z","comments":true,"path":"backend/node/passportLocal/","link":"","permalink":"https://swtpumpkin.github.io/backend/node/passportLocal/","excerpt":"","text":"로컬 로그인passport를 이용하여 로컬 로그인을 구현 할 수 있습니다. 로컬 로그인이란 id, password를 통한 회원가입 후 로그인을 할 수 있게 해줍니다. 모듈 설치 및 require12345npm install passportnpm install passport-localnpm install cookie-sessionnpm install bcryptnpm install express 위 코드를 터미널에 작성하여 필수 모듈을 설치합니다. 회원 가입 페이지12345678910block body h1 회원가입 form(action&#x3D;&#39;&#x2F;auth&#x2F;register&#39;, method&#x3D;&#39;post&#39;) input(type&#x3D;&#39;text&#39;, placeholder&#x3D; &#39;아이디&#39;, name&#x3D;&#39;user_id&#39;) br input(type&#x3D;&#39;password&#39;, placeholder&#x3D; &#39;비밀번호&#39;, name&#x3D;&#39;password&#39;) br input(type&#x3D;&#39;text&#39;, placeholder&#x3D; &#39;닉네임&#39;, name&#x3D;&#39;nickname&#39;) br button(type&#x3D;&#39;submit&#39;) 회원가입 pug를 사용하여 회원가입 페이지를 구현하였고 local 회원가입의 경로는 /auth/register으로 지정하였습니다.아이디, 비밀번호, 닉네임을 넣어주고 회원가입 버튼을 누르면 POST요청으로 회원가입 되게 됩니다. 로그인 페이지1234567block body h1 로그인 p Local 로그인 form(action&#x3D;&#39;&#x2F;auth&#x2F;login&#39;, method&#x3D;&#39;post&#39;) input(type&#x3D;&#39;text&#39;, placeholder&#x3D; &#39;아이디&#39;, name&#x3D;&#39;user_id&#39;) input(type&#x3D;&#39;password&#39;, placeholder&#x3D; &#39;비밀번호&#39;, name&#x3D;&#39;password&#39;) button(type&#x3D;&#39;submit&#39;) 로그인 pug를 사용하여 로그인 페이지를 구현하였고 로그인 경로는 /auth/login으로 지정하였습니다.아디와 비밀번호를 넣어주고 로그인 버튼을 누르면 POST요청으로 로그인 요청이 가고 조건에 충족되면 로그인 됩니다. Passport 로직 구현기본설정123456789101112131415161718const passport = require('passport')const LocalStrategy = require('passport-local').Strategyconst bcrypt = require('bcrypt')const express = require('express')const cookieSession = require('cookie-session')const app = express()const router = express.Router()router.use(cookieSession(&#123; name: 'localPassport', keys: [ process.env.SESSION_SECRET ], cookie: &#123; maxAge: 1000 * 60 * 60 * 24 // 유효기간 1일 &#125;&#125;))router.use(passport.initialize())router.use(passport.session()) 위 설정을 해주면 기본설정은 끝났습니다. 여기서 가장 중요한 부분은 router.use(passport.initialize())와 router.use(passport.session())가 꼭 쿠키세션 다음에 선언되어야 합니다. cookieSession 앞에 선언되게 되면 serialize 후 user의 정보가 담기지 않고 초기화 되기 때문에 꼭 순서를 확인하시고 코딩하시기 바랍니다. 회원가입12345678910111213141516router.post('/auth/register', (req, res) =&gt; &#123; const user_id = req.body.user_id, password = bcrypt.hashSync(req.body.password, 10), nickname = req.body.nickname query.checkAlreadyJoinId(&#123;user_id&#125;) .then(matched =&gt; &#123; if (matched) &#123; throw new Error ('이미 사용중인 아이디가 있습니다.') &#125; else &#123; query.createUser(&#123;user_id, password, nickname&#125;) .then(() =&gt; &#123; res.redirect('/auth/login') &#125;) &#125; &#125;)&#125;) /auth/register의 경로롤 user_id, passport, nickname이 body에 담겨 들어오게 되면 바디파서를 통해 각 변수에 담아줍니다. 쿼리를 통해 user_id가 중복되었는지 확인하고 중복되었다면 이미 사용중인 아이디가 있습니다.라는 에러를 표출해줍니다. 만약에 user_id가 중복되지 않는다면 새로운 아이디를 생성 후 로그인페이지로 리다이렉트 시켜줍니다. 비밀번호는 보안으로 bcrypt를 사용하였습니다. 로그인12345678910111213141516router.post('/login', (req, res, next) =&gt; &#123; passport.authenticate('local', (err, user, info) =&gt; &#123; if (err) &#123; return next(err) &#125; if(!user) &#123; throw new Error ('아이디와 비밀번호를 입력해주세요.') &#125; req.logIn(user, err =&gt; &#123; if (err) &#123; return next(err) &#125; res.redirect('/auth/success') &#125;) &#125;)(req, res, next)&#125;) 로그인 라우터를 통해 들어온 정보는 LocalStrategy로 전달됩니다.1234router.post('/login', passport.authenticate('local', &#123; successRedirect: '/', failureRedirect: '/auth/login'&#125;)); 로그인 라우터는 위 코드처럼 간단하게 사용 가능합니다. 사용 조건에 따라 Custom 바랍니다.123456passport.use(new LocalStrategy(&#123; usernameField: 'user_id' &#125;, (user_id, password, done) =&gt; &#123; query.checkAlreadyJoinId(&#123;user_id&#125;) .then(matched =&gt; &#123; (matched &amp;&amp; bcrypt.compareSync(password, matched.access_token))? done(null, matched) : done(new Error('아이디 또는 패스워드가 일치하지 않습니다.')) &#125;)&#125;)) LocalStrategy로 전달되면 쿼리를 통해 user의 정보를 확인하고 bcrypt를 통해 비밀번호를 비교합니다. 비교된 결과가 모두 조건에 맞으면 Passport Serializer로 전달됩니다.123passport.serializeUser((user, done) =&gt; &#123; done(null, `$&#123;user.user_id&#125;:$&#123;user.nickname&#125;`) &#125;) Passport Serializer로 전달되면 user정보를 Session에 저장합니다.1234567891011passport.deserializeUser((user, done) =&gt; &#123; const [user_id, nickname] = user.split(':') query.getLocalUserById(&#123;user_id, nickname&#125;) .then(user =&gt; &#123; if (user) &#123; done(null, user) &#125; else &#123; done(new Error('해당 정보와 일치하는 사용자가 없습니다.')) &#125; &#125;)&#125;) Passport Deserializser에선 페이지 이동시마다 user의 정보가 맞는지 확인하게 됩니다.","categories":[{"name":"backend","slug":"backend","permalink":"https://swtpumpkin.github.io/categories/backend/"},{"name":"node","slug":"backend/node","permalink":"https://swtpumpkin.github.io/categories/backend/node/"}],"tags":[{"name":"node","slug":"node","permalink":"https://swtpumpkin.github.io/tags/node/"},{"name":"javascript","slug":"javascript","permalink":"https://swtpumpkin.github.io/tags/javascript/"},{"name":"npm","slug":"npm","permalink":"https://swtpumpkin.github.io/tags/npm/"},{"name":"authentication","slug":"authentication","permalink":"https://swtpumpkin.github.io/tags/authentication/"},{"name":"oauth","slug":"oauth","permalink":"https://swtpumpkin.github.io/tags/oauth/"},{"name":"인증","slug":"인증","permalink":"https://swtpumpkin.github.io/tags/%EC%9D%B8%EC%A6%9D/"},{"name":"passport-local","slug":"passport-local","permalink":"https://swtpumpkin.github.io/tags/passport-local/"}]},{"title":"knex join","slug":"backend/mysql/knexJoin","date":"2017-10-23T23:00:00.000Z","updated":"2020-01-08T04:06:19.002Z","comments":true,"path":"backend/mysql/knexJoin/","link":"","permalink":"https://swtpumpkin.github.io/backend/mysql/knexJoin/","excerpt":"","text":"knex join?knex에서 join을 사용하면 foreign key로 연결된 테이블을 연결 할 수 있습니다. knex join query 작성 방법위 sql table을 보면 chat_room을 사이로 user와 city의 table이 연결되어 있습니다. city.id는 chat_room.city_id와 연결되어있고 user.id는 chat_room.creater와 연결되어있습니다. 공통된 연결을 통하여 하나의 가상테이블을 작성 할 수 있습니다. 1234knex('user') .join('chat_room', 'chat_room.creator', 'user.id') .join('city', 'chat_room.city_id', 'city.id') .as('temporary_table') 위 코드를 실행하면 temporary_table이라는 이름의 임시테이블이 생성됩니다. knex join query 참조하는 방법123456getAllRoomList () &#123; return knex('user') .join('chat_room', 'chat_room.creator', 'user.id') .join('city', 'chat_room.city_id', 'city.id') .as('temporary_table')&#125; 위 코드를 getAllRoomList라는 함수에 저장하게 되면 1let query = this.getAllRoomList() 위 코드와 같이 query라는 변수에 담을 수 있습니다. 12345678910111213getDataRoomList (&#123;city_id, start_at, like, id&#125;) &#123; let query = this.getAllRoomList() if(city_id &amp;&amp; start_at)&#123; if(like)&#123; query = query.where(&#123;city_id, start_at&#125;) query = query.orderBy('like', 'desc') &#125;else if(id)&#123; query = query.where(&#123;city_id, start_at&#125;) query = query.orderBy('id', 'desc') &#125; &#125; return query&#125; 따라서 연결된 테이블에서 원하는 검색 조건에 대한 결과를 갖고오길 원한다면 위 코드와 같이 합쳐진 코드의 결과를 변수에 담아두고 필터링하면 됩니다.","categories":[{"name":"backend","slug":"backend","permalink":"https://swtpumpkin.github.io/categories/backend/"},{"name":"mySQL","slug":"backend/mySQL","permalink":"https://swtpumpkin.github.io/categories/backend/mySQL/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"https://swtpumpkin.github.io/tags/mysql/"},{"name":"knex","slug":"knex","permalink":"https://swtpumpkin.github.io/tags/knex/"},{"name":"join","slug":"join","permalink":"https://swtpumpkin.github.io/tags/join/"},{"name":"가상테이블","slug":"가상테이블","permalink":"https://swtpumpkin.github.io/tags/%EA%B0%80%EC%83%81%ED%85%8C%EC%9D%B4%EB%B8%94/"},{"name":"테이블 연결","slug":"테이블-연결","permalink":"https://swtpumpkin.github.io/tags/%ED%85%8C%EC%9D%B4%EB%B8%94-%EC%97%B0%EA%B2%B0/"}]},{"title":"passport-kakao","slug":"backend/node/passportKakao","date":"2017-10-11T23:00:00.000Z","updated":"2020-01-08T04:06:19.004Z","comments":true,"path":"backend/node/passportKakao/","link":"","permalink":"https://swtpumpkin.github.io/backend/node/passportKakao/","excerpt":"","text":"카카오를 통한 로그인한국에선 카카오톡을 사용하는 사용자가 매우 많습니다. 한국에서 서비스하는 페이지들은 카카오를 통한 로그인을 사용하면 사용자가 쉽게 가입이 가능 할 것입니다. kakao 설정KAKAO Developers경로를 이동하여 로그인 후 앱 만들기를 누릅니다.생성하길 원하는 프로젝트의 이름을 지정 후 앱 만들기를 선택합니다.플랫폼 추가버튼을 누른 후 원하는 플랫폼을 선택합니다.(웹, Android, ios가 있습니다.)사이트 도메인에는 홈페이지의 주소를 입력하고 Redirect Path에는 callback될 주소를 입력합니다.보안 강화를 위해 Client Secret을 발행 받을 수 있습니다. 상태부분을 활성화 해주면됩니다.사용자 관리에서 사용을 활성화 하게 되면 서비스에 필요 정보 수집에 대한 정보를 선택 할 수 있습니다. 설치 및 사용 방법1npm install passport-kakao 위 코드를 터미널에 작성하여 passport-kakao을 설치한다. 1const KakaoStrategy = require('passport-kakao').Strategy 설치한 모듈을 require 시켜줍니다. 1234567891011121314151617181920212223passport.use(new KakaoStrategy(&#123; clientID: process.env.KAKAO_CLIENT_ID, clientSecret: process.env.KAKAO_CLIENT_SECRET, callbackURL: process.env.KAKAO_CALLBACK_URL&#125;,(accessToken, refreshToken, profile, done) =&gt; &#123; const profile_photo = profile._json.properties.profile_image? profile._json.properties.profile_image : null query.firstOrCreateUserByProvider( 'kakao', profile.id, accessToken, profile_photo ).then(user =&gt; &#123; done(null, user) &#125;).catch(err =&gt; &#123; done(err) &#125;)&#125;))router.get('/kakao', passport.authenticate('kakao'))router.get('/kakao/callback', passport.authenticate('kakao', &#123; successRedirect: '/', failureRedirect: '/login', failureFlash: true&#125;)) clientID는 카카오에서 만들어 주는 고유 id입니다.clientSecret는 카카오의 설정 secret입니다.callbackURL는 로그인 후 콜백 주소입니다. 콜백에서 로그인 성공 후와 실패 후의 경로를 옵션으로 선택 가능합니다.accessToken은 카카오에서 생성하는 사용자의 고유 토큰입니다.avatar_url은 카카오에서 기본 제공하는 프로필 사진을 담는 변수입니다. (변수 뒤 값은 카카오 응답의 경로입니다.)","categories":[{"name":"backend","slug":"backend","permalink":"https://swtpumpkin.github.io/categories/backend/"},{"name":"node","slug":"backend/node","permalink":"https://swtpumpkin.github.io/categories/backend/node/"}],"tags":[{"name":"node","slug":"node","permalink":"https://swtpumpkin.github.io/tags/node/"},{"name":"javascript","slug":"javascript","permalink":"https://swtpumpkin.github.io/tags/javascript/"},{"name":"npm","slug":"npm","permalink":"https://swtpumpkin.github.io/tags/npm/"},{"name":"authentication","slug":"authentication","permalink":"https://swtpumpkin.github.io/tags/authentication/"},{"name":"oauth","slug":"oauth","permalink":"https://swtpumpkin.github.io/tags/oauth/"},{"name":"인증","slug":"인증","permalink":"https://swtpumpkin.github.io/tags/%EC%9D%B8%EC%A6%9D/"},{"name":"passport-kakao","slug":"passport-kakao","permalink":"https://swtpumpkin.github.io/tags/passport-kakao/"}]},{"title":"node.js 버전 관리","slug":"backend/node/nodeVersionSet","date":"2017-10-08T23:00:00.000Z","updated":"2020-01-08T04:06:19.004Z","comments":true,"path":"backend/node/nodeVersionSet/","link":"","permalink":"https://swtpumpkin.github.io/backend/node/nodeVersionSet/","excerpt":"","text":"nvm 버전 관리nvm을 이용하여 node버전을 관리 할 수 있습니다. nvm 설정 방법 node 버전 확인1node -v 위 코드를 사용하여 현재 노드버전을 확인 할 수 있습니다. 최신버전의 노드 설치 방법1nvm install v8 v8을 사용하게 되면 8버전의 가장 최신버전으로 설치됩니다.(상세 버전 설치도 가능합니다.)현재 최신의 노드 버전은 v8.6.0입니다.(블로깅 날짜 현재 버전)따라서 위 코드를 사용하게 되면 v8.6.0으로 설치됩니다.최신버전의 노드가 9버전대라면 nvm install v9로 설치 할 수 있습니다. 터미널 노드 버전 변경1nvm use v8 위 코드를 사용하여 노드의 버전을 변경 할 수 있습니다.v8만 사용하게 되면 설치된 8버전 중 최신의 버전으로 설정됩니다. 터미널 노드 버전 default 설정1nvm alias default v8.6.0 위 코드를 사용하여 default버전을 설정 할 수 있습니다.노드 버전을 바꾸고 터미널 재시작 시 원하는 버전을 기본값으로 설정하려면 위 코드를 사용해야합니다.","categories":[{"name":"backend","slug":"backend","permalink":"https://swtpumpkin.github.io/categories/backend/"},{"name":"node","slug":"backend/node","permalink":"https://swtpumpkin.github.io/categories/backend/node/"}],"tags":[{"name":"nvm","slug":"nvm","permalink":"https://swtpumpkin.github.io/tags/nvm/"},{"name":"node","slug":"node","permalink":"https://swtpumpkin.github.io/tags/node/"},{"name":"javascript","slug":"javascript","permalink":"https://swtpumpkin.github.io/tags/javascript/"},{"name":"노드 버전","slug":"노드-버전","permalink":"https://swtpumpkin.github.io/tags/%EB%85%B8%EB%93%9C-%EB%B2%84%EC%A0%84/"}]},{"title":"level 2. 이상한 문자만들기 (Javascript)","slug":"algorithm/level2/createStrangeString","date":"2017-09-30T23:00:00.000Z","updated":"2020-02-17T03:49:00.323Z","comments":true,"path":"algorithm/level2/createStrangeString/","link":"","permalink":"https://swtpumpkin.github.io/algorithm/level2/createStrangeString/","excerpt":"","text":"이상한 문자만들기문제toWeirdCase함수는 문자열 s를 매개변수로 입력받습니다.문자열 s에 각 단어의 짝수번째 인덱스 문자는 대문자로, 홀수번째 인덱스 문자는 소문자로 바꾼 문자열을 리턴하도록 함수를 완성하세요.예를 들어 s가 “try hello world”라면 첫 번째 단어는 “TrY”, 두 번째 단어는 “HeLlO”, 세 번째 단어는 “WoRlD”로 바꿔 “TrY HeLlO WoRlD”를 리턴하면 됩니다.주의 문자열 전체의 짝/홀수 인덱스가 아니라, 단어(공백을 기준)별로 짝/홀수 인덱스를 판단합니다. 풀이 (본인)1234567891011121314function toWeirdCase(s) &#123; var result = []; var divStr = s.split(' '); for(var num = 0; num &lt; divStr.length; num++)&#123; var sumArr = []; for(var numInner = 0; numInner&lt;divStr[num].split('').length; numInner++)&#123; (numInner%2)? sumArr.push(divStr[num].split('')[numInner]) : sumArr.push(divStr[num].split('')[numInner].toUpperCase()) &#125; result.push(sumArr.join('')); &#125; return result.join(' ');&#125;// 아래는 테스트로 출력해 보기 위한 코드입니다.console.log(\"결과 : \" + toWeirdCase(\"try hello world\")); 풀이 (다른 사람)12345function toWeirdCase(s)&#123; return s.toUpperCase().replace(/(\\w)(\\w)/g, function(a)&#123;return a[0].toUpperCase()+a[1].toLowerCase();&#125;)&#125;// 아래는 테스트로 출력해 보기 위한 코드입니다.console.log(\"결과 : \" + toWeirdCase(\"try hello world\")); 배운점 정규표현식을 이용하여 코드를 1줄로 줄였다. 느낀점 대부분 짧은 코드는 정규표현식을 사용하였는데 실무에서 어떻게 사용해야할지 궁금하다.","categories":[{"name":"Algorism","slug":"Algorism","permalink":"https://swtpumpkin.github.io/categories/Algorism/"},{"name":"level2","slug":"Algorism/level2","permalink":"https://swtpumpkin.github.io/categories/Algorism/level2/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://swtpumpkin.github.io/tags/javascript/"},{"name":"자바스크립트","slug":"자바스크립트","permalink":"https://swtpumpkin.github.io/tags/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/"},{"name":"algorithm","slug":"algorithm","permalink":"https://swtpumpkin.github.io/tags/algorithm/"},{"name":"create strange string","slug":"create-strange-string","permalink":"https://swtpumpkin.github.io/tags/create-strange-string/"},{"name":"이상한 문자 만들기","slug":"이상한-문자-만들기","permalink":"https://swtpumpkin.github.io/tags/%EC%9D%B4%EC%83%81%ED%95%9C-%EB%AC%B8%EC%9E%90-%EB%A7%8C%EB%93%A4%EA%B8%B0/"},{"name":"알고리즘","slug":"알고리즘","permalink":"https://swtpumpkin.github.io/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/"}]},{"title":"level 1. 문자열 내 p와 y의 개수 (Javascript)","slug":"algorithm/level1/numOfPandY","date":"2017-09-30T23:00:00.000Z","updated":"2020-02-17T03:49:00.330Z","comments":true,"path":"algorithm/level1/numOfPandY/","link":"","permalink":"https://swtpumpkin.github.io/algorithm/level1/numOfPandY/","excerpt":"","text":"문자열 내 p와 y의 개수문제numPY함수는 대문자와 소문자가 섞여있는 문자열 s를 매개변수로 입력받습니다.s에 ‘p’의 개수와 ‘y’의 개수를 비교해 같으면 True, 다르면 False를 리턴하도록 함수를 완성하세요. ‘p’, ‘y’ 모두 하나도 없는 경우는 항상 True를 리턴합니다.예를들어 s가 “pPoooyY”면 True를 리턴하고 “Pyy”라면 False를 리턴합니다. 풀이 (본인)12345678910111213141516171819function numPY(s)&#123; var cntP = 0; var cntY = 0; var up = s.toUpperCase() //함수를 완성하세요 for (var a = 0; a &lt; up.length ; a++)&#123; if(up.charAt(a) == 'P')&#123; cntP += 1; &#125; else if(up.charAt(a) == 'Y')&#123; cntY += 1; &#125; &#125; return (cntP === cntY)? true : false;&#125;// 아래는 테스트로 출력해 보기 위한 코드입니다.console.log(numPY(\"pPoooyY\"));console.log(numPY(\"pPoooY\"));console.log(numPY(\"ooo\")); 풀이 (다른 사람(오답))1234567function numPY(s) &#123; return s.match(/p/ig).length == s.match(/y/ig).length;&#125;// 아래는 테스트로 출력해 보기 위한 코드입니다.console.log(numPY(\"pPoooyY\"));console.log(numPY(\"pPoooY\"));console.log(numPY(\"ooo\")); 배운점 match 메소드에 대해 다른사람의 코드를 보고 배웠지만 에러가 난다. 정규표현식을 사용하면 코드가 짧아진다.","categories":[{"name":"Algorism","slug":"Algorism","permalink":"https://swtpumpkin.github.io/categories/Algorism/"},{"name":"level1","slug":"Algorism/level1","permalink":"https://swtpumpkin.github.io/categories/Algorism/level1/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://swtpumpkin.github.io/tags/javascript/"},{"name":"자바스크립트","slug":"자바스크립트","permalink":"https://swtpumpkin.github.io/tags/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/"},{"name":"algorithm","slug":"algorithm","permalink":"https://swtpumpkin.github.io/tags/algorithm/"},{"name":"알고리즘","slug":"알고리즘","permalink":"https://swtpumpkin.github.io/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/"},{"name":"문자열 내 p와 y의 개수","slug":"문자열-내-p와-y의-개수","permalink":"https://swtpumpkin.github.io/tags/%EB%AC%B8%EC%9E%90%EC%97%B4-%EB%82%B4-p%EC%99%80-y%EC%9D%98-%EA%B0%9C%EC%88%98/"}]},{"title":"level 1. 서울에서 김서방 찾기 (Javascript)","slug":"algorithm/level1/findMrKimInSeoul","date":"2017-09-29T23:00:00.000Z","updated":"2020-02-17T03:49:00.329Z","comments":true,"path":"algorithm/level1/findMrKimInSeoul/","link":"","permalink":"https://swtpumpkin.github.io/algorithm/level1/findMrKimInSeoul/","excerpt":"","text":"서울에서 김서방 찾기문제findKim 함수(메소드)는 String형 배열 seoul을 매개변수로 받습니다.seoul의 element중 “Kim”의 위치 x를 찾아, “김서방은 x에 있다”는 String을 반환하세요.seoul에 “Kim”은 오직 한 번만 나타나며 잘못된 값이 입력되는 경우는 없습니다. 풀이 (본인)12345function findKim(seoul)&#123; return \"김서방은 \" + seoul.indexOf('Kim') + \"에 있다\";&#125;// 실행을 위한 테스트코드입니다.console.log(findKim([\"Queen\", \"Tod\", \"Kim\"])); 배운점 처음 자바스크립트를 배울 때 for문을 통해 Array를 for문을 통해 검색하였다. 하지만 지금은 Array Method를 이용하여 간결하게 코드를 완성하였다. 느낀점 배울수록 보인다.","categories":[{"name":"Algorism","slug":"Algorism","permalink":"https://swtpumpkin.github.io/categories/Algorism/"},{"name":"level1","slug":"Algorism/level1","permalink":"https://swtpumpkin.github.io/categories/Algorism/level1/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://swtpumpkin.github.io/tags/javascript/"},{"name":"자바스크립트","slug":"자바스크립트","permalink":"https://swtpumpkin.github.io/tags/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/"},{"name":"algorithm","slug":"algorithm","permalink":"https://swtpumpkin.github.io/tags/algorithm/"},{"name":"알고리즘","slug":"알고리즘","permalink":"https://swtpumpkin.github.io/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/"},{"name":"find mr.kim in seoul","slug":"find-mr-kim-in-seoul","permalink":"https://swtpumpkin.github.io/tags/find-mr-kim-in-seoul/"},{"name":"서울에서 김서방 찾기","slug":"서울에서-김서방-찾기","permalink":"https://swtpumpkin.github.io/tags/%EC%84%9C%EC%9A%B8%EC%97%90%EC%84%9C-%EA%B9%80%EC%84%9C%EB%B0%A9-%EC%B0%BE%EA%B8%B0/"}]},{"title":"level 1. 문자열 다루기 기본 (Javascript)","slug":"algorithm/level1/handlingString","date":"2017-09-29T23:00:00.000Z","updated":"2020-02-17T03:49:00.321Z","comments":true,"path":"algorithm/level1/handlingString/","link":"","permalink":"https://swtpumpkin.github.io/algorithm/level1/handlingString/","excerpt":"","text":"문자열 다루기 기본문제alpha_string46함수는 문자열 s를 매개변수로 입력받습니다.s의 길이가 4혹은 6이고, 숫자로만 구성되있는지 확인해주는 함수를 완성하세요.예를들어 s가 “a234”이면 False를 리턴하고 “1234”라면 True를 리턴하면 됩니다. 풀이 (본인)12345function alpha_string46(s)&#123; return (s.split('').length=== 6 || s.split('').length=== 4)? /^\\d+$/.test(s) : false;&#125;// 아래는 테스트로 출력해 보기 위한 코드입니다.console.log( alpha_string46(\"a234\") ); 풀이 (다른 사람)123456function alpha_string46(s)&#123; var regex = /^\\d&#123;6&#125;$|^\\d&#123;4&#125;$/; return regex.test(s);&#125;// 아래는 테스트로 출력해 보기 위한 코드입니다.console.log( alpha_string46(\"a234\") ); 배운점 정규표현식을 이용하면 더욱 간단한 코드 작성이 가능해진다.","categories":[{"name":"Algorism","slug":"Algorism","permalink":"https://swtpumpkin.github.io/categories/Algorism/"},{"name":"level1","slug":"Algorism/level1","permalink":"https://swtpumpkin.github.io/categories/Algorism/level1/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://swtpumpkin.github.io/tags/javascript/"},{"name":"자바스크립트","slug":"자바스크립트","permalink":"https://swtpumpkin.github.io/tags/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/"},{"name":"algorithm","slug":"algorithm","permalink":"https://swtpumpkin.github.io/tags/algorithm/"},{"name":"알고리즘","slug":"알고리즘","permalink":"https://swtpumpkin.github.io/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/"},{"name":"hadling string","slug":"hadling-string","permalink":"https://swtpumpkin.github.io/tags/hadling-string/"},{"name":"문자열 다루기","slug":"문자열-다루기","permalink":"https://swtpumpkin.github.io/tags/%EB%AC%B8%EC%9E%90%EC%97%B4-%EB%8B%A4%EB%A3%A8%EA%B8%B0/"}]},{"title":"Problem 1","slug":"algorithm/project euler/PE1","date":"2017-09-29T04:00:00.000Z","updated":"2020-02-17T03:49:00.320Z","comments":true,"path":"algorithm/project euler/PE1/","link":"","permalink":"https://swtpumpkin.github.io/algorithm/project%20euler/PE1/","excerpt":"","text":"1000보다 작은 자연수 중에서 3 또는 5의 배수를 모두 더하면?문제10보다 작은 자연수 중에서 3 또는 5의 배수는 3, 5, 6, 9 이고, 이것을 모두 더하면 23입니다.1000보다 작은 자연수 중에서 3 또는 5의 배수를 모두 더하면 얼마일까요? 풀이 (본인)1234567let sum = 0;for(let num = 1; num &lt;= 1000; num++)&#123; if(num % 3 === 0 || num % 5 === 0)&#123; sum += num; &#125;&#125;console.log(sum) //234168 1234567891011public class ThreeAndFive &#123; public static void main(String[] args) &#123; int sum = 0; for (int i = 1; i &lt; 1000; i++)&#123; if(i % 3 == 0 || i % 5 == 0)&#123; sum = sum + i; &#125; &#125; System.out.println(sum); &#125;&#125; 풀이 (다른 사람)123function checkNumber(n) &#123; return n % 3 === 0 || n % 5 === 0; &#125;function add(a,b) &#123; return a + b; &#125;_.range(1,1000).filter(checkNumber).reduce(add, 0); 배운점 다른 사람들의 코드를 보면 if를 두개 쓴 사람도 있는데 ||를 통해 한줄로 줄이는게 좋을 것 같다. 대부분의 사람들이 나와 같은 코드를 작성하였는데 특이한 코드를 작성 한 사람이 있어 추가하였다.(하지만 어떻게 동작하는지 이해가 어렵다.)","categories":[{"name":"Algorism","slug":"Algorism","permalink":"https://swtpumpkin.github.io/categories/Algorism/"},{"name":"ProjectEuler","slug":"Algorism/ProjectEuler","permalink":"https://swtpumpkin.github.io/categories/Algorism/ProjectEuler/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://swtpumpkin.github.io/tags/javascript/"},{"name":"자바스크립트","slug":"자바스크립트","permalink":"https://swtpumpkin.github.io/tags/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/"},{"name":"algorithm","slug":"algorithm","permalink":"https://swtpumpkin.github.io/tags/algorithm/"},{"name":"알고리즘","slug":"알고리즘","permalink":"https://swtpumpkin.github.io/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/"},{"name":"PROJECT EULER","slug":"PROJECT-EULER","permalink":"https://swtpumpkin.github.io/tags/PROJECT-EULER/"},{"name":"3의 배수 5의 배수","slug":"3의-배수-5의-배수","permalink":"https://swtpumpkin.github.io/tags/3%EC%9D%98-%EB%B0%B0%EC%88%98-5%EC%9D%98-%EB%B0%B0%EC%88%98/"}]},{"title":"Problem 10","slug":"algorithm/project euler/PE10","date":"2017-09-29T04:00:00.000Z","updated":"2020-02-17T03:49:00.324Z","comments":true,"path":"algorithm/project euler/PE10/","link":"","permalink":"https://swtpumpkin.github.io/algorithm/project%20euler/PE10/","excerpt":"","text":"이백만 이하 소수의 합문제10 이하의 소수를 모두 더하면 2 + 3 + 5 + 7 = 17 이 됩니다.이백만(2,000,000) 이하 소수의 합은 얼마입니까? 풀이 (본인)12345678910111213141516var num = 2;var result = 0;while(num&lt;2000000)&#123; var priNum = true; for(var divNum = 2; divNum &lt; num; divNum++)&#123; if(num%divNum === 0)&#123; priNum = false; break; &#125; &#125; if(priNum)&#123; result += num; &#125; num++&#125;console.log(result) 풀이 (다른 사람)123456789101112131415var num = 2;var arr = [2];var sum = 2;while(num &lt; 2000000)&#123; num++; for(var i=0;i&lt;arr.length;i++)&#123; if(num%arr[i] == 0) break; if(i == arr.length-1)&#123; arr.push(num); sum += num; &#125; &#125; &#125;;console.log(sum) npm middleware 사용하여 소수의 합 구하기sieve-of-eratosthenes는 에라스토테네스의 체를 이용한 알고리즘입니다. 1npm install sieve-of-eratosthenes 위 코드를 실행하여 sieve-of-eratosthenes를 설치합니다.node REPL을 통해서 위 사진과 같이 계산이 가능하다. 배운점 배열을 이용해서 소수들로 나눠보고 나누어지지 않는다면 소수를 추가하는 코드를 작성하니 속도가 10배정도 차이났다. 에라토스테네스 체를 이용하여 소수의 계산을 획기적으로 계산 할 수 있다.(1초 안에 연산가능) 느낀점 에라토스테네스 체를 알았지만 실제로 구현하기는 어렵다.(지금 상태에서….)","categories":[{"name":"Algorism","slug":"Algorism","permalink":"https://swtpumpkin.github.io/categories/Algorism/"},{"name":"ProjectEuler","slug":"Algorism/ProjectEuler","permalink":"https://swtpumpkin.github.io/categories/Algorism/ProjectEuler/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://swtpumpkin.github.io/tags/javascript/"},{"name":"자바스크립트","slug":"자바스크립트","permalink":"https://swtpumpkin.github.io/tags/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/"},{"name":"algorithm","slug":"algorithm","permalink":"https://swtpumpkin.github.io/tags/algorithm/"},{"name":"알고리즘","slug":"알고리즘","permalink":"https://swtpumpkin.github.io/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/"},{"name":"PROJECT EULER","slug":"PROJECT-EULER","permalink":"https://swtpumpkin.github.io/tags/PROJECT-EULER/"}]},{"title":"Problem 4","slug":"algorithm/project euler/PE4","date":"2017-09-29T04:00:00.000Z","updated":"2020-02-17T03:49:00.327Z","comments":true,"path":"algorithm/project euler/PE4/","link":"","permalink":"https://swtpumpkin.github.io/algorithm/project%20euler/PE4/","excerpt":"","text":"세자리 수를 곱해 만들 수 있는 가장 큰 대칭수문제앞에서부터 읽을 때나 뒤에서부터 읽을 때나 모양이 같은 수를 대칭수(palindrome)라고 부릅니다.두 자리 수를 곱해 만들 수 있는 대칭수 중 가장 큰 수는 9009 (= 91 × 99) 입니다.세 자리 수를 곱해 만들 수 있는 가장 큰 대칭수는 얼마입니까? 풀이 (본인)작은 수 부터12345678910111213var maxNum = 0;for(var num = 100; num&lt;1000; num++)&#123; var multi = 0; for(var innerNum = 100; innerNum&lt;1000; innerNum++)&#123; multi = num * innerNum; if(multi === (''+multi).split('').reverse().join('')*1)&#123; if(multi&gt;maxNum)&#123; maxNum = multi; &#125; &#125; &#125;&#125;console.log(maxNum); 큰 수 부터12345678910111213var maxNum = 0;for(var num = 999; num&gt;=100; num--)&#123; var multi = 0; for(var innerNum = 999; innerNum&gt;=100; innerNum--)&#123; multi = num * innerNum; if(multi === (''+multi).split('').reverse().join('')*1)&#123; if(multi&gt;maxNum)&#123; maxNum = multi; &#125; &#125; &#125;&#125;console.log(maxNum) 풀이 (다른 사람)12345678910111213141516function getPalindrome()&#123; var maximum = 0; for(var i = 999; i&gt;99; i--)&#123; for(var j = 999; j&gt;99; j--)&#123; var tempResult = i*j; var reverseNum = tempResult.toString().split('').reverse().join(''); if( tempResult == reverseNum)&#123; if(maximum &lt; tempResult)&#123; maximum = tempResult; &#125; &#125; &#125; &#125; return maximum;&#125;console.log(\"maximun : \"+getPalindrome()); 배운점 가장 큰 수부터 코드를 작성한 사람이 있어 코드를 큰 수부터 돌아가도록 작성하였더니 속도가 조금 빨라졌다.","categories":[{"name":"Algorism","slug":"Algorism","permalink":"https://swtpumpkin.github.io/categories/Algorism/"},{"name":"ProjectEuler","slug":"Algorism/ProjectEuler","permalink":"https://swtpumpkin.github.io/categories/Algorism/ProjectEuler/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://swtpumpkin.github.io/tags/javascript/"},{"name":"자바스크립트","slug":"자바스크립트","permalink":"https://swtpumpkin.github.io/tags/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/"},{"name":"algorithm","slug":"algorithm","permalink":"https://swtpumpkin.github.io/tags/algorithm/"},{"name":"알고리즘","slug":"알고리즘","permalink":"https://swtpumpkin.github.io/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/"},{"name":"PROJECT EULER","slug":"PROJECT-EULER","permalink":"https://swtpumpkin.github.io/tags/PROJECT-EULER/"},{"name":"대칭수","slug":"대칭수","permalink":"https://swtpumpkin.github.io/tags/%EB%8C%80%EC%B9%AD%EC%88%98/"}]},{"title":"Problem 7","slug":"algorithm/project euler/PE7","date":"2017-09-29T04:00:00.000Z","updated":"2020-02-17T03:49:00.313Z","comments":true,"path":"algorithm/project euler/PE7/","link":"","permalink":"https://swtpumpkin.github.io/algorithm/project%20euler/PE7/","excerpt":"","text":"10001번째의 소수문제소수를 크기 순으로 나열하면 2, 3, 5, 7, 11, 13, … 과 같이 됩니다.이 때 10,001번째의 소수를 구하세요. 풀이 (본인)12345678910111213141516171819function numberOfPrime(n) &#123; var countPrime = 0; for(var num = 1; num &lt; Number.MAX_VALUE; num++)&#123; var count = 0; for(var innerNum = 1; innerNum&lt;=num; innerNum++)&#123; if(num%innerNum===0)&#123; count++; &#125; &#125; if(count === 2)&#123; countPrime++; &#125; if(countPrime === n)&#123; return num; break; &#125; &#125;&#125;console.log(numberOfPrime(10001)); 풀이 (본인 개선 코드)12345678910111213141516171819var num = 2;var priCnt = 0;while(num)&#123; var priNum = true; for(var divNum = 2; divNum &lt; num; divNum++)&#123; if(num%divNum === 0)&#123; priNum = false; break; &#125; &#125; if(priNum)&#123; priCnt++ &#125; if(priCnt === 10001)&#123; console.log(num) break &#125; num++&#125; 배운점 소수 코드를 작성 할 때 1과 자기자신만 나눠지는 수를 소수로 생각하여 나머지(%)가 0인 함수를 찾아 개수가 2개일때만 소수로 판별하는 함수를 작성 하였는데 코드 실행 속도가 너무 오래 걸려 개선하였다.(10배정도 속도가 빨라짐.) count 대신 boolean타입으로 소수 구별하는 방법을 잘 사용해야겠다.","categories":[{"name":"Algorism","slug":"Algorism","permalink":"https://swtpumpkin.github.io/categories/Algorism/"},{"name":"ProjectEuler","slug":"Algorism/ProjectEuler","permalink":"https://swtpumpkin.github.io/categories/Algorism/ProjectEuler/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://swtpumpkin.github.io/tags/javascript/"},{"name":"자바스크립트","slug":"자바스크립트","permalink":"https://swtpumpkin.github.io/tags/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/"},{"name":"algorithm","slug":"algorithm","permalink":"https://swtpumpkin.github.io/tags/algorithm/"},{"name":"알고리즘","slug":"알고리즘","permalink":"https://swtpumpkin.github.io/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/"},{"name":"PROJECT EULER","slug":"PROJECT-EULER","permalink":"https://swtpumpkin.github.io/tags/PROJECT-EULER/"}]},{"title":"Problem 5","slug":"algorithm/project euler/PE5","date":"2017-09-29T04:00:00.000Z","updated":"2020-02-17T03:49:00.309Z","comments":true,"path":"algorithm/project euler/PE5/","link":"","permalink":"https://swtpumpkin.github.io/algorithm/project%20euler/PE5/","excerpt":"","text":"1 ~ 20 사이의 어떤 수로도 나누어 떨어지는 가장 작은 수문제1 ~ 10 사이의 어떤 수로도 나누어 떨어지는 가장 작은 수는 2520입니다.그러면 1 ~ 20 사이의 어떤 수로도 나누어 떨어지는 가장 작은 수는 얼마입니까? 풀이 (본인)123456789101112131415var maxNum = Number.MAX_VALUE;var minNum = 0;for(var num = 1; num&lt;maxNum; num++)&#123; var count = 0; for(var innerNum = 1; innerNum &lt;= 20; innerNum++)&#123; if(num%innerNum === 0)&#123; count++; &#125; &#125; if(count === 20)&#123; minNum = num; break; &#125;&#125;console.log(minNum); //232792560 풀이 (본인 개선 코드)12345678910111213141516var num = 0;while(true)&#123; num++ var divided = true; for(var innerNum = 20; innerNum &gt; 0; innerNum--)&#123; if(num%innerNum !== 0)&#123; divided = false; break; &#125; &#125; if(divided)&#123; console.log(num) break; &#125;&#125;// 결과 232792560 배운점 코드에 불필요한 count를 제거하니 속도가 증가하였다. count 대신 boolean type를 사용하니 속도가 증가하였다. 무한loop를 사용하여 원하는 연산 결과가 끝나면 나오도록 코드를 작성하는 것이 효율적이였다.(변수를 적게 사용) 큰 수부터 나누도록 하여 나누어떨어지지 않는 수를 제거하니 속도가 개선되었다.","categories":[{"name":"Algorism","slug":"Algorism","permalink":"https://swtpumpkin.github.io/categories/Algorism/"},{"name":"ProjectEuler","slug":"Algorism/ProjectEuler","permalink":"https://swtpumpkin.github.io/categories/Algorism/ProjectEuler/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://swtpumpkin.github.io/tags/javascript/"},{"name":"자바스크립트","slug":"자바스크립트","permalink":"https://swtpumpkin.github.io/tags/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/"},{"name":"algorithm","slug":"algorithm","permalink":"https://swtpumpkin.github.io/tags/algorithm/"},{"name":"알고리즘","slug":"알고리즘","permalink":"https://swtpumpkin.github.io/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/"},{"name":"PROJECT EULER","slug":"PROJECT-EULER","permalink":"https://swtpumpkin.github.io/tags/PROJECT-EULER/"}]},{"title":"REPL","slug":"backend/node/repl","date":"2017-09-25T23:00:00.000Z","updated":"2020-01-08T04:06:19.004Z","comments":true,"path":"backend/node/repl/","link":"","permalink":"https://swtpumpkin.github.io/backend/node/repl/","excerpt":"","text":"REPL이란?REPL은 Read Eval Print Loop의 약자입니다. Node.js의 REPL 환경은 자바스크립트로 작성된 코드를 테스트 할 때 유용합니다. REPL 사용 방법REPL은 터미널에서 사용가능합니다. 1node 위 코드를 사용하여 node환경의 REPL을 활성화합니다.위 환경처럼 간단한 연산도 가능합니다.위 환경처럼 javascript파일을 불러와서 REPL을 실행 할 수 있습니다.","categories":[{"name":"backend","slug":"backend","permalink":"https://swtpumpkin.github.io/categories/backend/"},{"name":"node","slug":"backend/node","permalink":"https://swtpumpkin.github.io/categories/backend/node/"}],"tags":[{"name":"node","slug":"node","permalink":"https://swtpumpkin.github.io/tags/node/"},{"name":"javascript","slug":"javascript","permalink":"https://swtpumpkin.github.io/tags/javascript/"},{"name":"REPL","slug":"REPL","permalink":"https://swtpumpkin.github.io/tags/REPL/"},{"name":"READ EVAL PRINT LOOP","slug":"READ-EVAL-PRINT-LOOP","permalink":"https://swtpumpkin.github.io/tags/READ-EVAL-PRINT-LOOP/"}]},{"title":"body-parser","slug":"backend/node/bodyParser","date":"2017-09-23T23:00:00.000Z","updated":"2020-01-08T04:06:19.003Z","comments":true,"path":"backend/node/bodyParser/","link":"","permalink":"https://swtpumpkin.github.io/backend/node/bodyParser/","excerpt":"","text":"body-parser?body-parser란 Node.js에서 body의 요청을 파싱해주는 미들웨어입니다. req.body에 들어오는 data를 파싱해줍니다. POST에 들어오는 data를 JSON형식으로 바꿔줘서 req.body.***과 같은 방법으로 사용 가능합니다. body-parser 사용 방법1npm body-parser 터미널에서 위 코드를 실행하여 body-parser를 설치합니다. 1const bodyParser = require('body-parser') 사용할 자바스크립트 파일에서 위 코드를 요청하여 body-parser를 활성화 해줍니다. 1app.use(bodyParser.json()) 위 코드를 사용하면 최상위 javascript파일에서 body-parser를 사용하게 되면 하위 모든 파일에서 body-parser 미들웨어를 사용 할 수 있습니다.","categories":[{"name":"backend","slug":"backend","permalink":"https://swtpumpkin.github.io/categories/backend/"},{"name":"node","slug":"backend/node","permalink":"https://swtpumpkin.github.io/categories/backend/node/"}],"tags":[{"name":"node","slug":"node","permalink":"https://swtpumpkin.github.io/tags/node/"},{"name":"javascript","slug":"javascript","permalink":"https://swtpumpkin.github.io/tags/javascript/"},{"name":"npm","slug":"npm","permalink":"https://swtpumpkin.github.io/tags/npm/"},{"name":"bodyparser","slug":"bodyparser","permalink":"https://swtpumpkin.github.io/tags/bodyparser/"},{"name":"바디파서","slug":"바디파서","permalink":"https://swtpumpkin.github.io/tags/%EB%B0%94%EB%94%94%ED%8C%8C%EC%84%9C/"}]},{"title":"JSONWebToken","slug":"backend/node/jsonWebToken","date":"2017-09-23T00:00:00.000Z","updated":"2020-01-08T04:06:19.003Z","comments":true,"path":"backend/node/jsonWebToken/","link":"","permalink":"https://swtpumpkin.github.io/backend/node/jsonWebToken/","excerpt":"","text":"JSONWebToken(JWT)?예전에는 사용자(client)의 정보를 쿠키에 담아 저장했었습니다.쿠키에 저장하는 방식은 쿠키를 변조하여 쉽게 정보를 바꿀 수 있기 때문에 보안에 취약했습니다.JWT는 유저가 로그인하면 서버는 유저의 정보를 토큰에 담아 전달하게 됩니다.서버는 클라이언트의 요청받을때마다 유효한 토큰인지 검증합니다. JWT의 형태JWT는 .을 이용하여 구분되어 있습니다. 첫번째 .앞은 header로 구성되어있고 두번째 .앞은 내용, 마지막은 서명으로 구성되어 있습니다. JWT는 JWT 디코딩 사이트를 통해 인코딩 된 값을 디코딩할 수 있습니다. 그렇기때문에 JWT에는 비밀번호를 담는 것은 매우 위험합니다. JWT 사용 방법1npm install jsonwebtoken 터미널에서 위 코드를 실행하여 jsonwebtoken을 설치합니다. 1const jwt = require('jsonwebtoken') 사용할 자바스크립트 파일에서 위 코드를 요청하여 jsonwebtoken을 활성화 해줍니다. 1const token = jwt.sign(id, 'mysecret') 위 코드처럼 user생성과 로그인시 user의 id로만 JWT를 발행할 수 있습니다.","categories":[{"name":"backend","slug":"backend","permalink":"https://swtpumpkin.github.io/categories/backend/"},{"name":"node","slug":"backend/node","permalink":"https://swtpumpkin.github.io/categories/backend/node/"}],"tags":[{"name":"node","slug":"node","permalink":"https://swtpumpkin.github.io/tags/node/"},{"name":"javascript","slug":"javascript","permalink":"https://swtpumpkin.github.io/tags/javascript/"},{"name":"npm","slug":"npm","permalink":"https://swtpumpkin.github.io/tags/npm/"},{"name":"security","slug":"security","permalink":"https://swtpumpkin.github.io/tags/security/"},{"name":"보안","slug":"보안","permalink":"https://swtpumpkin.github.io/tags/%EB%B3%B4%EC%95%88/"},{"name":"JSONWebToken","slug":"JSONWebToken","permalink":"https://swtpumpkin.github.io/tags/JSONWebToken/"},{"name":"JWT","slug":"JWT","permalink":"https://swtpumpkin.github.io/tags/JWT/"}]},{"title":"bcrypt","slug":"backend/node/bcrypt","date":"2017-09-22T23:00:00.000Z","updated":"2020-01-08T04:06:19.003Z","comments":true,"path":"backend/node/bcrypt/","link":"","permalink":"https://swtpumpkin.github.io/backend/node/bcrypt/","excerpt":"","text":"bcrypt?가끔 뉴스를 보면 커뮤니티사이트가 해킹되었지만 어느 사이트는 바로 비밀번호를 바꾸라고 권장하고 어느사이트는 걱정하지 않아도 된다고 합니다. bcrypt는 암호화 하는 과정에 salt를 이용하여 매번 결과가 다르게 출력됩니다.하지만 md5 hash 암호화는 같은 password라는 단어를 암호화 하게 되면 항상 5f4dcc3b5aa765d61d8327deb882cf99를 반환합니다. 따라서 암호를 복호화 하는 과정이 매우 복잡하기 때문에 다른 hash함수를 이용하여 암호화하는 방법보다 더 안전하다고 할 수 있습니다. bcrypt 사용 방법1npm install bcrypt 터미널에서 위 코드를 실행하여 bcrypt를 설치합니다. 1const bcrypt = require('bcrypt') 사용할 자바스크립트 파일에서 위 코드를 요청하여 bcrypt를 활성화 해줍니다. 1const hashed_password = bcrypt.hashSync(password, 10) 위 코드처럼 password를 bctypt를 이용하여 암호화해 줄 수 있습니다. 괄호 안의 10이란 숫자는 2^10번 연산하라는 것입니다. 1const matched = bcrypt.compareSync(password, user.hashed_password) 위 코드는 암호화된 코드와 user가 입력한 코드를 비교하는 코드입니다. compareSync를 이용하여 앞의 password와 뒤의 user.hashed_password를 비교하게 됩니다.","categories":[{"name":"backend","slug":"backend","permalink":"https://swtpumpkin.github.io/categories/backend/"},{"name":"node","slug":"backend/node","permalink":"https://swtpumpkin.github.io/categories/backend/node/"}],"tags":[{"name":"node","slug":"node","permalink":"https://swtpumpkin.github.io/tags/node/"},{"name":"javascript","slug":"javascript","permalink":"https://swtpumpkin.github.io/tags/javascript/"},{"name":"npm","slug":"npm","permalink":"https://swtpumpkin.github.io/tags/npm/"},{"name":"bcrypt","slug":"bcrypt","permalink":"https://swtpumpkin.github.io/tags/bcrypt/"},{"name":"security","slug":"security","permalink":"https://swtpumpkin.github.io/tags/security/"},{"name":"보안","slug":"보안","permalink":"https://swtpumpkin.github.io/tags/%EB%B3%B4%EC%95%88/"}]},{"title":"passport-naver","slug":"backend/node/passportNaver","date":"2017-09-20T00:00:00.000Z","updated":"2020-01-08T04:06:19.004Z","comments":true,"path":"backend/node/passportNaver/","link":"","permalink":"https://swtpumpkin.github.io/backend/node/passportNaver/","excerpt":"","text":"네이버를 통한 로그인2017년 현재 네이버 점유율이 50%가 무너졌다고 해도 아직까지 네이버를 사용하는 사용자가 많습니다.따라서 앱에서 네이버를 통한 로그인을 구현하면 사용자가 앱 가입이 수월할 것입니다. naver 설정NAVER Developers경로를 통하여 페이지 이동 후 오픈 API 이용 신청을 선택합니다.네이버 아이디를 통한 로그인 구현을 위하여 네아로(네이버 아이디로 로그인) 선택 후 원하는 data를 선택합니다.환경 설정 또한 원하는 조건으로 선택 후 주소를 설정합니다.클라이언트 id와 secret를 이용하면 됩니다. 설치 및 사용 방법1npm install passport-naver 위 코드를 터미널에 작성하여 passport-naver을 설치합니다. 1const NaverStrategy = require('passport-naver').Strategy 설치한 모듈을 require 시켜줍니다. 1234567891011121314151617181920212223passport.use(new NaverStrategy(&#123; clientID: process.env.NAVER_CLIENT_ID, clientSecret: process.env.NAVER_CLIENT_SECRET, callbackURL: process.env.NAVER_CALLBACK_URL&#125;, (accessToken, refreshToken, profile, done) =&gt; &#123; const avatar_url = profile._json.profile_image ? profile._json.profile_image : null query.firstOrCreateUserByProvider( 'naver', profile.id, accessToken, avatar_url ).then(user =&gt; &#123; done(null, user) &#125;).catch(err =&gt; &#123; done(err) &#125;)&#125;))app.get('/auth/naver', passport.authenticate('naver'))app.get('/auth/naver/callback', passport.authenticate('naver', &#123; successRedirect: '/', failureRedirect: '/login', failureFlash: true&#125;)) clientID는 네이버에서 제공하는 id입니다.clientSecret는 네이버에서 제공하는 secret입니다.callbackURL는 로그인 후 콜백 주소입니다. 콜백에서 로그인 성공 후와 실패 후의 경로를 옵션으로 선택 가능합니다.accessToken은 네이버에서 생성하는 사용자의 고유 토큰입니다.avatar_url은 네이버에서 제공하는 프로필사진을 담는 변수입니다.","categories":[{"name":"backend","slug":"backend","permalink":"https://swtpumpkin.github.io/categories/backend/"},{"name":"node","slug":"backend/node","permalink":"https://swtpumpkin.github.io/categories/backend/node/"}],"tags":[{"name":"node","slug":"node","permalink":"https://swtpumpkin.github.io/tags/node/"},{"name":"javascript","slug":"javascript","permalink":"https://swtpumpkin.github.io/tags/javascript/"},{"name":"npm","slug":"npm","permalink":"https://swtpumpkin.github.io/tags/npm/"},{"name":"authentication","slug":"authentication","permalink":"https://swtpumpkin.github.io/tags/authentication/"},{"name":"oauth","slug":"oauth","permalink":"https://swtpumpkin.github.io/tags/oauth/"},{"name":"인증","slug":"인증","permalink":"https://swtpumpkin.github.io/tags/%EC%9D%B8%EC%A6%9D/"},{"name":"passport-naver","slug":"passport-naver","permalink":"https://swtpumpkin.github.io/tags/passport-naver/"}]},{"title":"passport-facebook","slug":"backend/node/passportFacebook","date":"2017-09-19T23:00:00.000Z","updated":"2020-01-08T04:06:19.004Z","comments":true,"path":"backend/node/passportFacebook/","link":"","permalink":"https://swtpumpkin.github.io/backend/node/passportFacebook/","excerpt":"","text":"OAuth?OAuth를 사용하면 사용자의 아이디와 암호가 노출되지 않도록 하면서도 애플리케이션에 API 접근 권한을 안전하게 위임할 수 있습니다.유명한 소셜 네트워크나 API 제공자들은 대부분 OAuth 2.0을 지원하고 있습니다.OAuth는 직접 구현하기는 너무나 어렵기 때문에 대부분의 SNS는 npm에 미리 준비되어 있는 Passport strategy만 구현을 함으로써 애플리케이션에 OAuth 인증을 쉽게 추가할 수 있습니다. facebook 설정facebook페이지로 이동하여 개발자 등록을 합니다.표시 이름에 원하는 app이름을 설정합니다.설정 - 기본 설정으로 이동합니다.기본설정 - 플랫폼 추가 - 웹사이트를 선택합니다.앱 도메인 주소를 설정합니다.개발한 앱을 활성화 시키려면 앱을 공개해주면 됩니다. 설치 및 사용 방법1npm install passport-facebook 위 코드를 터미널에 작성하여 passport-facebook을 설치합니다. 1const FacebookStrategy = require('passport-facebook').Strategy; 설치한 모듈을 require 시켜줍니다. 1234567891011121314151617181920212223242526passport.use(new FacebookStrategy(&#123; clientID: process.env.FACEBOOK_CLIENT_ID, clientSecret: process.env.FACEBOOK_CLIENT_SECRET, callbackURL: process.env.FACEBOOK_CALLBACK_URL, profileFields: ['id', 'displayName', 'photos', 'email']&#125;, (accessToken, refreshToken, profile, done) =&gt; &#123; const avatar_url = profile.photos[0] ? profile.photos[0].value : null query.firstOrCreateUserByProvider( 'facebook', profile.id, accessToken, avatar_url ).then(user =&gt; &#123; done(null, user) &#125;).catch(err =&gt; &#123; done(err) &#125;)&#125;))app.get('/auth/facebook', passport.authenticate('facebook', &#123; scope: ['public_profile', 'manage_pages']&#125;))app.get('/auth/facebook/callback', passport.authenticate('facebook', &#123; successRedirect: '/', failureRedirect: '/login', failureFlash: true&#125;)) clientID는 페이스북에서 만들어 주는 고유 id입니다.clientSecret는 페이스북의 설정 secret입니다.callbackURL는 로그인 후 콜백 주소입니다. 콜백에서 로그인 성공 후와 실패 후의 경로를 옵션으로 선택 가능합니다.profileFields에서 어떠한 정보를 요청 할 것인지 설정해주어야 페이스북의 응답에서 볼 수 있습니다.accessToken은 페이스북에서 생성하는 사용자의 고유 토큰입니다.avatar_url은 페이스북에서 기본 제공하는 프로필 사진을 담는 변수입니다.(변수 뒤 값은 페이스북 응답의 경로입니다.)","categories":[{"name":"backend","slug":"backend","permalink":"https://swtpumpkin.github.io/categories/backend/"},{"name":"node","slug":"backend/node","permalink":"https://swtpumpkin.github.io/categories/backend/node/"}],"tags":[{"name":"node","slug":"node","permalink":"https://swtpumpkin.github.io/tags/node/"},{"name":"javascript","slug":"javascript","permalink":"https://swtpumpkin.github.io/tags/javascript/"},{"name":"npm","slug":"npm","permalink":"https://swtpumpkin.github.io/tags/npm/"},{"name":"authentication","slug":"authentication","permalink":"https://swtpumpkin.github.io/tags/authentication/"},{"name":"oauth","slug":"oauth","permalink":"https://swtpumpkin.github.io/tags/oauth/"},{"name":"passport-facebook","slug":"passport-facebook","permalink":"https://swtpumpkin.github.io/tags/passport-facebook/"},{"name":"인증","slug":"인증","permalink":"https://swtpumpkin.github.io/tags/%EC%9D%B8%EC%A6%9D/"}]},{"title":"knex seed","slug":"backend/mysql/knexSeed","date":"2017-09-17T23:00:00.000Z","updated":"2020-01-08T04:06:19.002Z","comments":true,"path":"backend/mysql/knexSeed/","link":"","permalink":"https://swtpumpkin.github.io/backend/mysql/knexSeed/","excerpt":"","text":"knex seed?knex에서 seed를 사용하면 마이그레이션 파일과 상관없이 테스트 또는 시드 데이터로 데이터베이스를 체울 수 있습니다. 시드 파일 생성 방법1knex seed:make &#96;생성할 파일 이름&#96; 위 코드를 실행하면 다음과 같이 폴더와 파일이 생성됩니다.seed의 디렉토리는 상대 경로 여야합니다.따라서 ./seeds 의 경로에 파일이 생성됩니다.seed파일은 생성할 파일 명을 바꿔서 실행하게 되면 여러개를 만들 수 있습니다.seed파일의 실행은 migration과 다르게 사전순으로 실행됩니다.사전순으로 실행 되기 때문에 foreign key로 연결되어 있다면 순서를 고려하여 seed 파일을 생성해야 합니다. 시드 사용 방법12345678910exports.seed = function(knex, Promise) &#123; return knex('table_name').del() .then(function () &#123; return knex('table_name').insert([ &#123;id: 1, colName: 'rowValue1'&#125;, &#123;id: 2, colName: 'rowValue2'&#125;, &#123;id: 3, colName: 'rowValue3'&#125; ]); &#125;);&#125;; 처음 seed를 생성하게 되면 위 코드와 같이 기본 seed파일이 생성됩니다. 1234567891011121314151617181920212223const faker = require('faker')const randomstring = require('randomstring')exports.seed = function(knex, Promise) &#123; return knex('user') .insert(&#123; id: 'kim', password: 'jeongwon' &#125;) .then(()=&gt;&#123; const arr = [] for (var i = 0; i &lt; 20; i++)&#123; arr.push( knex('url_entry') .insert(&#123; id: randomstring.generate(8), long_url: faker.internet.url(), user_id: 'fast' &#125;) ) &#125; return Promise.all(arr) &#125;)&#125;; 위 코드와 같이 원하는 데이터 생성을 원하는대로 넣고 실행하게 되면 dummy data를 생성 할 수 있습니다.위에서 작성한 코드를 실행하려면 다음과 같이 터미널에서 실행하면 됩니다. 1knex seed:run 위 코드를 실행하게 되면 MySQL서버에 dummy data가 들어가게 됩니다.","categories":[{"name":"backend","slug":"backend","permalink":"https://swtpumpkin.github.io/categories/backend/"},{"name":"mySQL","slug":"backend/mySQL","permalink":"https://swtpumpkin.github.io/categories/backend/mySQL/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"https://swtpumpkin.github.io/tags/mysql/"},{"name":"knex","slug":"knex","permalink":"https://swtpumpkin.github.io/tags/knex/"},{"name":"seed","slug":"seed","permalink":"https://swtpumpkin.github.io/tags/seed/"},{"name":"mockup data","slug":"mockup-data","permalink":"https://swtpumpkin.github.io/tags/mockup-data/"},{"name":"dummy data","slug":"dummy-data","permalink":"https://swtpumpkin.github.io/tags/dummy-data/"}]},{"title":"CSURF","slug":"backend/node/csurf","date":"2017-09-17T23:00:00.000Z","updated":"2020-01-08T04:06:19.003Z","comments":true,"path":"backend/node/csurf/","link":"","permalink":"https://swtpumpkin.github.io/backend/node/csurf/","excerpt":"","text":"데이터 해킹 3가지 XSS SQL Injection CSRF CSRF크로스 사이트 요청 위조(Cross-site request forgery)의 약어로 사용자가 자신의 의지와는 무관하게 공격자가 의도한 행위(수정, 삭제, 등록 등)를 특정 웹사이트에 요청하게 하는 공격을 말한다.유명 경매사이트인 옥션에서 발생한 개인정보 유출 사건에서 사용된 공격 방식 중 하나다.쿠키를 통한 인증방식에서 사용되는 공격기법이다. 공격과정 이용자는 정상적인 쿠키를 얻는 로그인을 진행한다. 공격자는 이미지 태그 안에 공격코드를 작성하여 이용자에게 보낸다.1&lt;img src=\"http://ttticketttt.org/ticket-cancel/?user_id=134\"&gt; 이용자가 공격용 페이지를 열면, 브라우저는 이미지 파일을 받아오기 위해 공격용 URL을 연다. 이용자는 의도치 않게 실행하는 순간 브라우저에서 요청을 보내서 공격이 실행되게 된다. CSURFCSRF Secret와 Token을 만들어서 서로 매칭이 되는지 확인하는 기능을 제공합니다.Secret는 session에 저장하고 Token은 POST body에 저장합니다.POST body에 토큰을 저장하려면 form 작성 시 직접 포함해야합니다.Secret와 Token은 사용자마다 모두 다릅니다.하지만 매칭 시 사용자마다 Secret와 Token은 일치하도록 만들어져있습니다. CSURF 사용방법1npm install csurf 터미널에서 위 코드를 실행하여 csurf를 설치합니다. 123const csurf = require('csurf')const csrfMiddleware = csurf()app.use(csrfMiddleware) 위 코드와 같이 작성하여 app에서 사용 가능하도록 합니다. 123app.get('/', (req,res)=&gt;&#123; res.render('index.ejs',&#123;csrfToken: req.csrfToken()&#125;)&#125;) 위 코드와 같이 render되는 부분에 csrfToken을 추가합니다. 123&lt;form&gt; &lt;input type=\"hidden\" name=\"_csrf\" value=\"&lt;%= csrfToken %&gt;\"&gt;&lt;/form&gt; form태그 안에 submit하는 부분이 있다면 hidden타입으로 csrfToken을 숨겨 POST하도록 합니다.위 코드와 같이 작성하면 render되는 부분과 POST될 때 토큰을 비교하여 보안코드가 일치하는지 확인합니다.","categories":[{"name":"backend","slug":"backend","permalink":"https://swtpumpkin.github.io/categories/backend/"},{"name":"node","slug":"backend/node","permalink":"https://swtpumpkin.github.io/categories/backend/node/"}],"tags":[{"name":"node","slug":"node","permalink":"https://swtpumpkin.github.io/tags/node/"},{"name":"javascript","slug":"javascript","permalink":"https://swtpumpkin.github.io/tags/javascript/"},{"name":"보안","slug":"보안","permalink":"https://swtpumpkin.github.io/tags/%EB%B3%B4%EC%95%88/"},{"name":"csrf","slug":"csrf","permalink":"https://swtpumpkin.github.io/tags/csrf/"},{"name":"csurf","slug":"csurf","permalink":"https://swtpumpkin.github.io/tags/csurf/"},{"name":"크로스 사이트 요청 위조","slug":"크로스-사이트-요청-위조","permalink":"https://swtpumpkin.github.io/tags/%ED%81%AC%EB%A1%9C%EC%8A%A4-%EC%82%AC%EC%9D%B4%ED%8A%B8-%EC%9A%94%EC%B2%AD-%EC%9C%84%EC%A1%B0/"}]},{"title":"MySQL Select","slug":"backend/mysql/mysqlSelect","date":"2017-09-11T02:00:00.000Z","updated":"2020-01-08T04:06:19.003Z","comments":true,"path":"backend/mysql/mysqlSelect/","link":"","permalink":"https://swtpumpkin.github.io/backend/mysql/mysqlSelect/","excerpt":"","text":"SELECTMySQL에서 데이터를 불러오려면 SELECT를 이용해야합니다.위 데이터베이스를 기반으로 검색을 해보도록 하겠습니다. USE 문법 사용법원하는 database선택 1use employees 위 코드를 사용하여 database선택을 먼저 합니다.위 코드를 실행하면 사진과 같이 database가 볼드체로 바뀌는데 볼드체로 바뀌게 되면 database선택이 완료된 것 입니다.코드를 이용하여 선택하는 것 이외에도 database이름을 더블클릭하여도 database선택이 가능합니다. SELECT 문법 사용법 table 검색employees 데이터베이스에서 departments의 내용을 검색하는 방법에는 2가지가 있습니다. 1SELECT column_name1, column_name2 FROM database_name.table_name database를 선택하지 않았을 때에는 database_name.table_name를 사용해야 합니다. 1SELECT column_name1, column_name2 FROM table_name 1SELECT dept_no, dept_name FROM departments 위 코드와 같이 departments의 모든 column을 입력하면 테이블의 목록이 아래와 같이 나타나게 됩니다.위 코드의 모든 table 내용을 보고싶다면 모든 column을 입력하는 것 보다 *로 한번에 선택 가능합니다. 1select * from departments 위 코드처럼 테이블의 모든 내용을 보고싶다면 * 사용을 추천합니다. table의 컬럼이름 바꿔서 검색table의 column_name을 검색 후 AS를 이용하여 이름을 바꿔 표시가 가능합니다. 1SELECT column_name1 AS trans_name1, column_name2 AS trans_name2 FROM database_name.table_name 1SELECT dept_no AS &#39;부서코드&#39;, dept_name AS &#39;부서명&#39; FROM departments 위 코드를 실행하게 되면 dept_no가 부서코드로 dept_name이 부서명으로 바뀌었습니다. 1SELECT dept_no &#39;부서코드&#39;, dept_name &#39;부서명&#39; FROM departments 위 코드와 같이 AS를 생략하여도 같은 AS를 사용한 것과 같은 결과를 볼 수 있습니다. table 정렬하기ORDER BY 구문을 사용하면 특정 컬럼에 대한 정렬 기준을 세워 테이블을 출력할 수 있습니다.ORDER BY 뒤에 정렬을 원하는 column명을 선택하면 해당 column이 오름차순으로 정렬됩니다. 12SELECT * FROM table_nameORDER BY column_name; 12SELECT * FROM salariesORDER BY salary; 위 코드를 실행하여 salary column의 data가 오름차순으로 정렬 된 것을 볼 수 있습니다. tabla 중복제거 후 정렬하기column선택 시 DISTINCT를 사용하면 해당 column의 중복된 값을 제거하고 보여줍니다. 12SELECT DISTINCT column_name FROM table_nameORDER BY column_name; 12SELECT DISTINCT first_name FROM employeesORDER BY first_name; 위 코드를 실행하게 되면 first_name의 중복된 요소를 제거하고 오름차순으로 정렬 된 것을 볼 수 있습니다. 필터링table의 요소 중 원하는 내용만 선택 가능합니다.WHERE 뒤 원하는 내용의 column이름과 찾을 값을 입력 후 검색이 가능합니다. 12SELECT * FROM table_nameWHERE column_name &#x3D; &#39;search_value&#39; 12SELECT * FROM employeesWHERE first_name &#x3D; &#39;Shahid&#39; 위 코드를 사용하여 검색한 결과 Shahid라는 이름을 갖고있는 사람만 검색되었습니다. 검색 연산자WHERE뒤 다양한 연산자 사용이 가능합니다.WHERE 구문 내에서 자주 사용되는 연산자와 그 뜻을 아래 표에서 확인할 수 있습니다. 연산자 뜻 A=B A와 B가 같음 A!=B 또는 A&lt;&gt;B A와 B가 같지 않음 A&lt;B A와 B보다 작음 A&lt;=B A와 B보다 작거나 같음 A&gt;B A와 B보다 큼 A&gt;=B A와 B보다 크거나 같음 A IS NULL A가 NULL임 A IS NOT NULL A가 NULL이 아님 A LIKE ‘%PATTERN%’ A가 패턴과 일치함 A REGEXP ‘/EXPRESSION/‘ A가 정규표현식을 만족함 A BETWEEN B AND C A가 B와 C사이에 있음(B,C 포함) A IN (B,C,D) A가 B,C,D 중 하나와 일치함 NOT A A가 거짓 A OR B A 또는 B 둘 중 하나가 참 A AND B A와 B모두 참 연산자 우선순위다른 프로그래밍 언어가 그렇듯이 SQL에도 연산자 우선순위가 존재합니다.예를 들어, OR보다 AND가 먼저 연산되기 때문에 아래와 같이 사용할 때는 주의해야 합니다.또한 ()괄호를 사용하여 연산을 우선 할 수 있습니다.","categories":[{"name":"backend","slug":"backend","permalink":"https://swtpumpkin.github.io/categories/backend/"},{"name":"mySQL","slug":"backend/mySQL","permalink":"https://swtpumpkin.github.io/categories/backend/mySQL/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"https://swtpumpkin.github.io/tags/mysql/"},{"name":"DB","slug":"DB","permalink":"https://swtpumpkin.github.io/tags/DB/"},{"name":"Database","slug":"Database","permalink":"https://swtpumpkin.github.io/tags/Database/"},{"name":"데이터베이스","slug":"데이터베이스","permalink":"https://swtpumpkin.github.io/tags/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4/"},{"name":"select","slug":"select","permalink":"https://swtpumpkin.github.io/tags/select/"},{"name":"use","slug":"use","permalink":"https://swtpumpkin.github.io/tags/use/"},{"name":"where","slug":"where","permalink":"https://swtpumpkin.github.io/tags/where/"},{"name":"order by","slug":"order-by","permalink":"https://swtpumpkin.github.io/tags/order-by/"}]},{"title":"MySQL data type","slug":"backend/mysql/mysqlDataType","date":"2017-09-11T01:00:00.000Z","updated":"2020-01-08T04:06:19.002Z","comments":true,"path":"backend/mysql/mysqlDataType/","link":"","permalink":"https://swtpumpkin.github.io/backend/mysql/mysqlDataType/","excerpt":"","text":"MySQL 데이터 타입MySQL에는 여러가지 데이터 타입을 갖고있습니다. 하지만 boolean타입은 갖고있지 않습니다. STRING문자열에는 두가지 타입이 존재합니다.CHAR는 고정형이고, VARCHAR는 가변형입니다. TYPE 사용되는 바이트 예제 CHAR(n) 정확히 n (&lt;=255) CHAR(5) ‘Hello’는 5바이트 사용CHAR(50) ‘Hello’는 50바이트 사용 VARCHAR(n) 최대 n 까지(&lt;=65535) VARCHAR(100) ‘Hello’는 5바이트 사용VARCHAR(5) ‘Hello’는 5바이트 사용 데이터가 많아지면 CHAR타입과 VARCHAR타입의 속도 차이가 있습니다.100만건이 넘는 데이터를 검색했을 때 CHAR를 사용했을 경우에는 0.54 sec가 걸렸으며 VARCHAR를 사용했을 경우에는 0.64 sec 가 걸렸습니다.따라서 상황에 따라 CHAR와 VARCHAR를 번갈아가며 선택하는 것도 좋을 것 같습니다. CHARCHAR(10)을 설정하게 되면 ‘test’를 입력하더라도 삽입된 데이터의 크기는 10byte입니다.CHAR 타입은 길이를 지정해주면 남은 공간은 빈칸으로 체우게 됩니다. VARCHAR(variable length character string)짧은 문자열을 저장하기 위해 가장 널리 사용되는 타입입니다. 컬럼 타입으로 지정할 때는 아래와 같이 문자열의 길이(바이트)를 명시해야 합니다.VARCHAR(255) – 255는 가장 널리 사용되는 길이입니다. (utf8 인코딩 방식으로 한글은 1글자당 3바이트이다.)저장을 하기 위한 가장 효과적인 길이는 255입니다. TEXT긴 문자열을 저장하기 위해 사용되는 타입입니다. TEXT 타입의 컬럼에는 64MB까지 저장할 수 있습니다. 요구사항에 따라 크기가 다른 다양한 종류의 TEXT 타입(TINYTEXT, TEXT, MEDIUMTEXT, LONGTEXT)을 사용할 수 있습니다. TYPE 사용되는 바이트 속성 TINYTEXT(n) 최대 n (&lt;=255) 문자열로 취급 TEXT(n) 최대 n (&lt;=65535) 문자열로 취급 MEDIUMTEXT(n) 최대 n (&lt;=16777215) 문자열로 취급 LONGTEXT(n) 최대 n (&lt;=4294967295) 문자열로 취급 NUMBER정수, 고정 소수점, 부동 소수점을 위한 타입이 있습니다. 모든 수 타입은 양수만을 저장하기 위해 타입 뒤에 UNSIGNED 지시자를 사용할 수 있습니다. 부동 소수점은 정확성보다 성능을 우선시한다. 고정 소수점은 성능은 느려도 정확성을 우선시한다.(10진수의 정확성) INTEGER (INT 타입)정수를 위한 타입입니다. INT로 줄여 쓸 수도 있습니다. 요구사항에 따라 크기가 다른 다양한 종류의 INT 타입(TINYINT, SMALLINT, MEDIUMINT, INT, BIGINT)을 사용할 수 있습니다. TYPE Storage Minimum Value Maximum Value (Bytes) (Signed/Unsigned) (Signed/Unsigned) TINYINT 1 -128 127 0 255 SMALLINT 2 -32768 32767 0 65535 MEDIUMINT 3 -8388608 8388607 0 16777215 INT 4 -2147483648 2147483647 0 4294967295 BIGINT 8 -922337203685775808 922337203685775807 0 18446744073709551615 Unsigned를 사용하게 되면 표현 할 수 있는 수가 커진다.MySQL에는 참, 거짓을 나타내는 boolean 관련 타입이 없습니다. 대신 TINYINT를 사용합니다. (boolean은 1비트/ TINYINT는 1바이트) DECIMAL고정 소수점 수를 위한 타입입니다.십진수의 정확한 계산이 필요할 때 사용합니다.정수부(최대 65), 소수부(최대 30, 정수부보다 짧거나 같아야 함)의 최대 길이를 각각 지정할 수 있습니다. 1DECIMAL(5, 2) -- 12345.67과 같은 수를 저장할 수 있습니다. DOUBLE (FLOAT)부동 소수점 수를 위한 타입입니다. 소수의 빠른 계산과 효율적 저장이 필요할 때 사용합니다.DOUBLE이 FLOAT보다 긴 수를 저장 할 수 있습니다. TIMEMySQL에는 시각의 저장을 위한 타입들이 준비되어 있습니다. 주로 사용되는 아래의 두 타입은 시간대 정보를 저장하지 않기 때문에, 사용에 주의를 요합니다. DATEDATE 타입은 날짜를 위한 타입입니다.‘1000-01-01’부터 ‘9999-12-31’까지를 나타낼 수 있습니다.크기는 3 바이트입니다. DATETIMEDATETIME 타입은 날짜와 시각을 같이 저장해야 할 때 사용합니다.‘1000-01-01 00:00:00’부터 ‘9999-12-31 23:59:59’까지 나타낼 수 있습니다.크기는 8 바이트입니다.","categories":[{"name":"backend","slug":"backend","permalink":"https://swtpumpkin.github.io/categories/backend/"},{"name":"mySQL","slug":"backend/mySQL","permalink":"https://swtpumpkin.github.io/categories/backend/mySQL/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"https://swtpumpkin.github.io/tags/mysql/"},{"name":"DB","slug":"DB","permalink":"https://swtpumpkin.github.io/tags/DB/"},{"name":"Database","slug":"Database","permalink":"https://swtpumpkin.github.io/tags/Database/"},{"name":"data type","slug":"data-type","permalink":"https://swtpumpkin.github.io/tags/data-type/"},{"name":"데이터베이스","slug":"데이터베이스","permalink":"https://swtpumpkin.github.io/tags/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4/"},{"name":"데이터 타입","slug":"데이터-타입","permalink":"https://swtpumpkin.github.io/tags/%EB%8D%B0%EC%9D%B4%ED%84%B0-%ED%83%80%EC%9E%85/"}]},{"title":"데이터베이스와 테이블","slug":"backend/mysql/mysqlDbAndTable","date":"2017-09-11T00:00:00.000Z","updated":"2020-01-08T04:06:19.003Z","comments":true,"path":"backend/mysql/mysqlDbAndTable/","link":"","permalink":"https://swtpumpkin.github.io/backend/mysql/mysqlDbAndTable/","excerpt":"","text":"데이터베이스와 테이블의 생성CREATE DATABASE는 데이터베이스를 만드는 명령어입니다.워크벤치를 실행하고 commend + T를 누르게 되면 새 쿼리 탭이 생성됩니다.처음 DB 생성전 아래의 SQL을 실행해보세요. 12-- 데이터베이스 생성CREATE DATABASE my_db; 쿼리에 작성 후 SQL을 실행하려면 commend + enter를 누르면 쿼리문이 실행됩니다.위 코드를 실행하게되면 아래와 같이 Action 탭에 잘 실행이 되었다고 나옵니다.하지만 바로 반영되지 않으므로 ⤹⤴︎ 새로고침 버튼을 눌러 새로고침 해주어야 합니다.my_db라는 Database가 잘 생성된 것을 볼 수 있습니다.CREATE TABLE은 테이블을 만드는 명령입니다. 아래 명령을 차례로 실행해보세요. 1234567891011-- 테이블 생성CREATE TABLE my_db.users ( -- &#96;name&#96;이라는 이름의 문자열 컬럼을 생성합니다. NULL을 허용하지 않습니다. name VARCHAR(30) NOT NULL, -- &#96;job&#96;이라는 이름의 문자열 컬럼을 생성합니다. NULL을 허용합니다. job VARCHAR(30), -- &#96;age&#96;라는 이름의 양수 컬럼을 생성합니다. NULL을 허용합니다. age INTEGER UNSIGNED, -- &#96;name&#96; 컬럼을 기본 키로 지정합니다. PRIMARY KEY (name)); 위 코드를 쿼리에 실행하게되면 다음과 같은 경로에 table이 생성됩니다.번개모양의 표를 누르게 되면 users라는 table이 실행됩니다. 1SELECT * FROM my_db.users; 이때 위 코드가 자동으로 쿼리에 실행되고 아래와 같은 표가 실행되게됩니다.표만 만들고 데이터를 넣어주지 않았으므로 데이터의 값은 null입니다. 데이터 추가하기123456789-- 하나의 레코드 추가하기INSERT INTO users (name, job, age)VALUES (&#39;윤민지&#39;, &#39;프론트엔드 개발자&#39;, 32);-- 여러 개의 레코드 추가하기INSERT INTO users (name, job, age)VALUES (&#39;한주원&#39;, &#39;프론트엔드 개발자&#39;, 39),(&#39;박현숙&#39;, &#39;백엔드 개발자&#39;, 48),(&#39;정병언&#39;, NULL, 25),(&#39;임동면&#39;, &#39;디자이너&#39;, NULL); 위 코드처럼 data를 하나씩 넣어 줄 수 있고 여러개를 한번에 추가 할 수 있습니다.아래 코드를 실행해보도록 하겠습니다.코드를 실행하면 위 사진처럼 data가 table에 들어가게 됩니다.NULL값을 넣게되면 table엔 NULL값이 들어가게 됩니다. 데이터 불러오기데이터를 불러올 때에는 table 전체를 불러오거나 원하는 데이터만 불러 올 수 있습니다. 12-- 모든 컬럼을 포함시켜 불러오기SELECT * FROM users; users라는 table 전체를 불러오려면 위 코드처럼 쿼리에 작성하여 실행하면 됩니다.그러면 위 사진처럼 table 전체가 불러와집니다. 12-- 특정 컬럼만 포함시켜 불러오기SELECT name, job FROM users; users table에 name과 job만 불러오길 원한다면 위 코드처럼 SELECT 와 FROM사이에 원하는 column의 명을 써주면 됩니다.위 코드를 실행해보도록 하겠습니다.위 사진과 같이 name, job컬럼만 보여집니다. 데이터 수정하기데이터를 수정하려면 다음과 같은 양식으로 코드를 작성해야합니다. 123UPDATE 테이블명SET 바꿀 컬럼명과 dataWHERE 찾을 컬럼명(data); 위와 같은 양식으로 UPDATE에서 바꾸길 원하는 table을 선택하고 WHERE에서 바꾸길 원하는 데이터를 선택하고 SET에서 바꿀 컬럼명과 data를 입력해줍니다.처음 정병언씨는 위 사진처럼 job 컬럼에 data는 null이였습니다. 123UPDATE usersSET job &#x3D; &#39;프로그래머&#39;WHERE name &#x3D; &#39;정병언&#39;; 위 코드를 실행해보도록 하겠습니다. 12SELECT * FROM my_db.usersWHERE name&#x3D;&#39;정병언&#39;; 위 코드로 데이터가 잘 바뀌었는지 확인해보겠습니다.위 사진과 같이 정병언씨의 직업에 null값에서 프로그래머로 변경되었습니다. 데이터 삭제하기원하는 데이터를 삭제 할 수 있습니다. 12DELETE FROM 테이블 명WHERE 원하는 컬럼명과 data; DELETE FROM뒤에는 삭제하길 원하는 table을 선택하고 WHERE뒤에는 삭제하길 원하는 컬럼명과 data를 선택합니다.위 사진처럼 정병언씨는 table에 존재합니다. 12DELETE FROM usersWHERE name &#x3D; &#39;정병언&#39;; 위 코드를 실행하여 정병언씨의 데이터를 삭제해보도록 하겠습니다.SELECT * FROM my_db.users;를 사용하여 쿼리를 실행하니 위 사진처럼 정병언씨의 data는 모두 삭제되었습니다.data의 삭제는 행이 삭제됩니다. 데이터베이스와 테이블의 삭제데이터 뿐만아니라 데이터베이스와 테이블 삭제가 가능합니다.DROP DATABASE, DROP TABLE 명령은 각각 데이터베이스와 테이블을 삭제하는 명령입니다.data를 삭제하려면 DELETE를 사용하였지만 데이터베이스와 테이블을 삭제하려면 DROP을 사용해야합니다. 테이블 삭제1DROP TABLE 테이블명; table을 삭제하려면 DROP TABLE뒤에 테이블명을 입력 후 실행하면 됩니다.users table을 삭제하기 전입니다. 12-- users 테이블 삭제DROP TABLE users; users라는 테이블을 위 코드를 실행하여 삭제해보도록 하겠습니다.위 코드를 실행하니 users라는 테이블이 삭제되었습니다. 데이터베이스 삭제1DROP DATABASE 데이터베이스 명; Database를 삭제하려면 DROP DATABASE뒤에 데이터베이스명을 입력 후 실행하면 됩니다.my_db database를 삭제하기 전입니다. 12-- my_db 데이터베이스 삭제DROP DATABASE my_db; my_db라는 database를 위 코드를 실행하여 삭제해보도록 하겠습니다.위 코드를 실행하니 my_db라는 database가 삭제되었습니다.","categories":[{"name":"backend","slug":"backend","permalink":"https://swtpumpkin.github.io/categories/backend/"},{"name":"mySQL","slug":"backend/mySQL","permalink":"https://swtpumpkin.github.io/categories/backend/mySQL/"}],"tags":[{"name":"create","slug":"create","permalink":"https://swtpumpkin.github.io/tags/create/"},{"name":"delete","slug":"delete","permalink":"https://swtpumpkin.github.io/tags/delete/"},{"name":"mysql","slug":"mysql","permalink":"https://swtpumpkin.github.io/tags/mysql/"},{"name":"DB","slug":"DB","permalink":"https://swtpumpkin.github.io/tags/DB/"},{"name":"Database","slug":"Database","permalink":"https://swtpumpkin.github.io/tags/Database/"},{"name":"데이터베이스","slug":"데이터베이스","permalink":"https://swtpumpkin.github.io/tags/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4/"},{"name":"삭제","slug":"삭제","permalink":"https://swtpumpkin.github.io/tags/%EC%82%AD%EC%A0%9C/"},{"name":"table","slug":"table","permalink":"https://swtpumpkin.github.io/tags/table/"},{"name":"테이블","slug":"테이블","permalink":"https://swtpumpkin.github.io/tags/%ED%85%8C%EC%9D%B4%EB%B8%94/"},{"name":"생성","slug":"생성","permalink":"https://swtpumpkin.github.io/tags/%EC%83%9D%EC%84%B1/"}]},{"title":"MySQL 설치","slug":"backend/mysql/mysqlInstall","date":"2017-09-10T23:00:00.000Z","updated":"2020-01-08T04:06:19.003Z","comments":true,"path":"backend/mysql/mysqlInstall/","link":"","permalink":"https://swtpumpkin.github.io/backend/mysql/mysqlInstall/","excerpt":"","text":"MySQL 오픈소스 관계형 데이터베이스 중 가장 많이 사용됩니다. 다른 RDBMS에 비해 사용하기 쉽고 도구가 많습니다. 2009년 이후 오라클이 소유중이며, 무료 에디션과 상용 에디션이 있습니다. Database 란?데이터를 저장하는 저장소를 의미합니다. 설치방법우선적으로 brew가 설치되어야 합니다. brew의 설치방법은 여기를 참조하시기 바랍니다. 1brew install mysql brew를 이용하여 mySQL을 설치합니다. 1mysql.server start mySQL을 실행합니다. 1mysql_secure_installation mySQL 설정합니다. 설정의 질문들이 나오는데 저는 아래와 같이 설정하였습니다. 12345678910Would you like to setup VALIDATE PASSWORD plugin? enter&#x2F;&#x2F; 복잡한 비밀번호 사용하도록 제한해주려면 yes || 비밀번호를 제한없이 사용하려면 noRemove anonymous users? yes&#x2F;&#x2F; 익명사용자를 삭제라혀면 yes || 익명사용자를 유지하려면 noDisallow root login remotely? yes&#x2F;&#x2F; localhost 외 접근을 제한하려면 yes || 허가하려면 noRemove test database and access to it? yes&#x2F;&#x2F; 기본적인 test DB를 삭제하려면 yes || 유지하려면 noReload privilege tables now? yes&#x2F;&#x2F; 권한을 하나라도 변경하셨다면 yes를 누르는 것을 추천합니다.","categories":[{"name":"backend","slug":"backend","permalink":"https://swtpumpkin.github.io/categories/backend/"},{"name":"mySQL","slug":"backend/mySQL","permalink":"https://swtpumpkin.github.io/categories/backend/mySQL/"}],"tags":[{"name":"설치","slug":"설치","permalink":"https://swtpumpkin.github.io/tags/%EC%84%A4%EC%B9%98/"},{"name":"mysql","slug":"mysql","permalink":"https://swtpumpkin.github.io/tags/mysql/"},{"name":"DB","slug":"DB","permalink":"https://swtpumpkin.github.io/tags/DB/"},{"name":"Database","slug":"Database","permalink":"https://swtpumpkin.github.io/tags/Database/"},{"name":"데이터베이스","slug":"데이터베이스","permalink":"https://swtpumpkin.github.io/tags/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4/"}]},{"title":"Tree","slug":"CS/dataStructure/tree","date":"2017-09-08T02:00:00.000Z","updated":"2020-05-06T07:34:44.381Z","comments":true,"path":"CS/dataStructure/tree/","link":"","permalink":"https://swtpumpkin.github.io/CS/dataStructure/tree/","excerpt":"","text":"Tree Tree는 비선형이고 계층을 갖고있는 자료구조입니다. 나무와 유사하게 계층적 구조를 갖고 있는 것을 의미합니다. 트리의 주된 목적은 탐색이며, 검색엔진, 댓글 구현 등 매우 다양한 곳에서 응용이 되고 있습니다. Binary Tree Structure(이진 트리)최대 2개의 자식을 갖는 트리 구조입니다. 이진트리의 탐색 전위 순회(pre-order)는 루트에서 왼쪽 트리를 탐색하고 오른쪽 트리를 순회합니다. 중위 순회(in-order)는 왼쪽트리의 끝부터 탐색을 시작하고 루트를 탐색 후 오른쪽 트리를 순회합니다. 후위 순회(post-order)는 왼쪽트리 끝부터 탐색을 시작하여 오른쪽 트리를 탐색 후 루트를 순회합니다. Tree를 javascript로 구현이진 트리로써 루트와 비교했을때 루트보다 큰 값은 오른쪽으로, 작은 값은 왼쪽으로 보내는 트리구조. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112const BinarySearchTree= () =&gt; &#123; const Node = (key) =&gt; &#123; this.key = key; this.left = null; this.right = null; &#125;; let root = null; // 트리구조에 data를 담는 구조 구현 // 값이 작으면 왼쪽, 값이 크면 오른쪽 const insertNode = (node, newNode) =&gt; &#123; if(newNode.key &lt; node.key)&#123; if(node.left === null)&#123; node.left = newNode; &#125; else &#123; insertNode(node.left, newNode); &#125; &#125; else &#123; if(node.right === null)&#123; node.right = newNode; &#125; else &#123; insertNode(node.right, newNode); &#125; &#125; &#125; // 트리구조에 data를 추가할 때 this.insert = (key) =&gt; &#123; let newNode = new Node(key); if(root === null)&#123; root = newNode; &#125; else &#123; insertNode(root, newNode); &#125; &#125;; // 전위 순회 const preOrderTraverseNode = (node, callback) =&gt; &#123; if(node !== null)&#123; callback(node.key); preOrderTraverseNode(node.left, callback); preOrderTraverseNode(node.right, callback); &#125; &#125; this.preOrderTraverse = (callback) =&gt; &#123; preOrderTraverseNode(root, callback); &#125;; // 중위 순회 var inOrderTraverseNode = (node, callback) =&gt; &#123; if(node !== null)&#123; inOrderTraverseNode(node.left, callback); callback(node.key); inOrderTraverseNode(node.right, callback); &#125; &#125; this.inOrderTraverse = (callback) =&gt; &#123; inOrderTraverseNode(root, callback); &#125;; // 후위 순회 var postOrderTraverseNode = (node, callback) =&gt; &#123; if(node !== null)&#123; postOrderTraverseNode(node.left, callback); postOrderTraverseNode(node.right, callback); callback(node.key); &#125; &#125; this.postOrderTraverse = (callback) =&gt; &#123; postOrderTraverseNode(root, callback); &#125;; // 트리구조의 최소값 (가장 왼쪽에 있는 마지막 값은 가장 트리구조에서 가장 작은 숫자이다.) this.min = () =&gt; &#123; return minNode(root); &#125; const minNode = (node) =&gt; &#123; if(node)&#123; while(node &amp;&amp; node.left !== null)&#123; node = node.left; &#125; return node.key &#125; return null; &#125;; // 트리구조의 최대값 (가장 오른쪽에 있는 마지막 값은 가장 트리구조에서 가장 큰 숫자이다.) this.max = function () &#123; return maxNode(root); &#125; const maxNode = (node) =&gt; &#123; if(node)&#123; while(node &amp;&amp; node.right !== null)&#123; node = node.right; &#125; return node.key; &#125; return null; &#125;; // 트리구조에서 원하는 값을 찾을 때. this.search = (key) =&gt; &#123; return searchNode(root, key); &#125;; const searchNode = (node, key) =&gt; &#123; if(node === null)&#123; return false; &#125; if(key &lt; node.key)&#123; return searchNode(node.left, key) &#125; else if(key &gt; node.key)&#123; return searchNode(node.left, key) &#125; else &#123; return true; &#125; &#125;&#125;const printNode = (value) =&gt; &#123; console.log(value);&#125;","categories":[{"name":"CS","slug":"CS","permalink":"https://swtpumpkin.github.io/categories/CS/"},{"name":"dataStructure","slug":"CS/dataStructure","permalink":"https://swtpumpkin.github.io/categories/CS/dataStructure/"}],"tags":[{"name":"tree","slug":"tree","permalink":"https://swtpumpkin.github.io/tags/tree/"},{"name":"javascript","slug":"javascript","permalink":"https://swtpumpkin.github.io/tags/javascript/"},{"name":"자바스크립트","slug":"자바스크립트","permalink":"https://swtpumpkin.github.io/tags/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/"},{"name":"트리","slug":"트리","permalink":"https://swtpumpkin.github.io/tags/%ED%8A%B8%EB%A6%AC/"}]},{"title":"Linked List","slug":"CS/dataStructure/linkedList","date":"2017-09-08T01:00:00.000Z","updated":"2020-05-06T07:34:44.380Z","comments":true,"path":"CS/dataStructure/linkedList/","link":"","permalink":"https://swtpumpkin.github.io/CS/dataStructure/linkedList/","excerpt":"","text":"Linked List란?Linked List는 Array List와는 다르게 엘리먼트와 엘리먼트 간의 연결(link)을 이용해서 리스트를 구현한 것을 의미합니다.각 element에는 data와 다음 element의 주소를 갖고있습니다.마지막 element의 주소는 null입니다. Array vs Linked ListArray는 메모리를 순서대로 할당합니다.Linked List 메모리를 랜덤으로 할당합니다.하지만 javascript의 array는 Linked List의 형태로 되어있어 javascript의 array는 정확한 array라고 할 수 없습니다.javascript의 splice가 Linked List의 구조를 갖고 있기 때문입니다.Array는 임의 접근(Random Access)이 쉽다.(원하는 장소에 접근이 가능합니다.)하지만 Linked List는 head에서 순서대로 접근을 해야합니다.따라서 원하는 장소에 접근을 원한다면 for문을 사용하여 순서대로 원하는 장소까지 접근을 해야 합니다. 메모리 내의 Array와 Linked List의 차이출처: opentutorials의 자료구조(Linked list)위 사진처럼 같은 Array의 각 요소(element)들은 메모리의 같은 곳에 모여있습니다.따라서 이미 선언된 배열보다 요소들이 늘어나게 되면 Array 전체를 다른 메모리 공간의 주소에 새로 저장해주어야 합니다.하지만 Linked List의 요소들은 메모리의 주소 값이 랜덤으로 할당되기 때문에 요소들이 늘어나게 되도 새로 메모리내 주소에 요소만 새로 할당해주면 됩니다.하지만 메모리의 주소값들이 랜덤이기 때문에 각 요소들은 다음 요소의 주소값을 갖고 있어야 합니다. Array와 Linked List 비교 Array vs Linked List Fixed Size Dynamic Hard Insert Easy Hard Deletion Easy Allowed Random Access Not allowed dosen’t need Extra memory space required Array는 크기가 고정되어있지만 Linked List는 크기가 유동적입니다.(메모리 할당의 차이) Array는 요소를 추가 삭제가 어렵지만 Linked List는 요소를 추가 삭제가 쉽습니다.(Linked List는 요소를 추가하거나 삭제하게 되면 요소의 전과 후의 주소를 연결해주기만 하면 됩니다.) Array는 요소의 접근이 쉽지만 Linked List는 요소에 접근하는데 어렵습니다.(다음 목차에 설명) Array는 여유메모리가 필요없지만 Linked List는 여유메모리가 요구됩니다.(Array는 요소들이 정해지면 덩어리로 메모리를 할당하여 주소를 갖고있게 되는데 Linked List는 다음 요소들이 유동적이기 때문에 메모리의 추가 사용이 가능 할 수도 있기때문입니다.) Array와 Linked List의 속도 Array vs Linked List o(1) access o(n) o(n) search o(n) o(n) insert o(1) o(n) remove o(1) Array는 원하는 요소를 한번에 접근이 가능합니다. 하지만 Linked List 위쪽 설명처럼 요소까지 접근하려면 각 요소마다 다음 요소의 주소를 찾아 접근을 해야합니다. 따라서 속도가 Array에 비해 느립니다. 하지만 요소를 추가 또는 삭제하는 속도는 Linked List가 Array에 비해 빠릅니다. Linked List를 javascript로 구현123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107function LinkedList() &#123; var Node = function(element)&#123; this.element = element; this.next = null; &#125;; var length = 0; var head = null; // Linked List에 요소를 추가 this.append = function(element)&#123; var node = new Node(element), current; if(head === null)&#123; head = node; &#125; else &#123; current = head; while(current.next)&#123; current = current.next; &#125; current.next = node; &#125; length++; &#125;; // Linked List에 원하는 위치의 요소를 삭제 this.removeAt = function(position)&#123; if(position &gt; -1 &amp;&amp; position &lt; length) &#123; var current = head, previous, index = 0; if(position === 0)&#123; head = current.next; &#125;else &#123; while(index++ &lt; position) &#123; previous = current; current = current.next; &#125; previous.next = current.next; &#125; length--; return current.element; &#125; else &#123; return null; &#125; &#125;; // Linked List의 요소 사이에 요소를 삽입 this.insert = function (position, element) &#123; if(position &gt;= 0 &amp;&amp; position &lt;= length)&#123; var current = head, previous, index = 0; if(position === 0)&#123; node.next = current; head = node; &#125; else &#123; while(index++ &lt; position) &#123; previous = current; current = current.next; &#125; node.next = current; previous.next = node; &#125; length++; return true; &#125; else &#123; return false; &#125; &#125;; // Linked List의 요소를 삭제 this.remove = function (element) &#123; var index = this.indexOf(element); return this.removeAt(index); &#125;; // Linked List의 위치 this.indexOf = function (element) &#123; var current = head; index = 0; while (current) &#123; if(element === current.element)&#123; return index; &#125; index++; current = current.next; &#125; return -1; &#125;; // Linked List가 비었는지 확인 this.isEmpty = function () &#123; return length === 0; &#125;; // Linked List의 사이즈 this.size = function () &#123; return length; &#125;; // Linked List를 문자로 변환 this.toString = function () &#123; var current = head, string = ''; while (current) &#123; string += current.element; current = current.next; &#125; return string; &#125;; // Linked List의 헤드(첫 요소)를 확인 this.getHead = function () &#123; return head; &#125;;&#125;","categories":[{"name":"CS","slug":"CS","permalink":"https://swtpumpkin.github.io/categories/CS/"},{"name":"dataStructure","slug":"CS/dataStructure","permalink":"https://swtpumpkin.github.io/categories/CS/dataStructure/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://swtpumpkin.github.io/tags/javascript/"},{"name":"자바스크립트","slug":"자바스크립트","permalink":"https://swtpumpkin.github.io/tags/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/"},{"name":"linkedlist","slug":"linkedlist","permalink":"https://swtpumpkin.github.io/tags/linkedlist/"},{"name":"링크드리스트","slug":"링크드리스트","permalink":"https://swtpumpkin.github.io/tags/%EB%A7%81%ED%81%AC%EB%93%9C%EB%A6%AC%EC%8A%A4%ED%8A%B8/"}]},{"title":"hexo 태그 사용법","slug":"git/hexo/hexoTag","date":"2017-09-07T23:00:00.000Z","updated":"2020-01-08T04:06:19.010Z","comments":true,"path":"git/hexo/hexoTag/","link":"","permalink":"https://swtpumpkin.github.io/git/hexo/hexoTag/","excerpt":"","text":"태그hexo blog를 사용하면서 블로깅 하려고 하는데 항상 tag에러로 tag 기능을 잘 사용하지 못 했습니다. 구글링해도 원인을 찾지 못하다 우연히 tag사용방법을 알게 되었습니다. hueman 테마를 사용 할 때 태그를 사용하려면 특별한 문법이 필요했습니다. 따라서 나와 같이 블로그를 사용하면서 tag기능을 잘 사용하지 못하는 블로거들을 위하여 tag 사용법을 posting합니다. 사용방법위 사진과 같이 헤드 부분에 tag부분을 똑같이 작성하면 됩니다. 123456tags: - hexo - hueman - tag - 태그 - 헥소 위 코드와 같이 tag를 작성하고 개행을 하여 띄어쓰기2번 또는 tab한번을 한 후 - 태그내용을 작성하면 됩니다.위 사진처럼 각각의 단어마다 tag설정이 완료 되었습니다.","categories":[{"name":"git","slug":"git","permalink":"https://swtpumpkin.github.io/categories/git/"},{"name":"hexo","slug":"git/hexo","permalink":"https://swtpumpkin.github.io/categories/git/hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://swtpumpkin.github.io/tags/hexo/"},{"name":"헥소","slug":"헥소","permalink":"https://swtpumpkin.github.io/tags/%ED%97%A5%EC%86%8C/"},{"name":"hueman","slug":"hueman","permalink":"https://swtpumpkin.github.io/tags/hueman/"},{"name":"tag","slug":"tag","permalink":"https://swtpumpkin.github.io/tags/tag/"},{"name":"태그","slug":"태그","permalink":"https://swtpumpkin.github.io/tags/%ED%83%9C%EA%B7%B8/"}]},{"title":"hexo블로그 구글 웹마스터 도구에 속성 추가 및 인증","slug":"git/hexo/hexoWebMaster","date":"2017-09-06T23:00:00.000Z","updated":"2020-01-08T04:06:19.010Z","comments":true,"path":"git/hexo/hexoWebMaster/","link":"","permalink":"https://swtpumpkin.github.io/git/hexo/hexoWebMaster/","excerpt":"","text":"구글 웹마스터 도구(Search Console)에 속성 추가 및 인증자신이 만든 github blog를 구글 검색시 표출을 원한다면 웹마스터 도구에 등록을 해야한다고 한다. 따라서 다음과 같이 인증방법을 어떻게 하는지 추가하였습니다. 참고바랍니다. 인증방법구글 웹마스터 도구에 접속합니다.위 사이트에서 자신의 github blog 주소를 적고 속성추가를 누릅니다.1번 옆 html파일을 다운로드 받습니다./blogroot/public 경로에 다운로드 받은 html file을 넣습니다.hexo clean - hexo generate - hexo deploy 를 이용하여 다시 배포를 합니다.위 사이트에서 3번 항목을 눌렀을 때 404응답이 나면 조금 기다렸다가 다시 눌러보도록 합니다.3번 항목을 누른 후 404응답이 아닌 다른 html 파일이 열리면 성공입니다.확인을 누르고 다음페이지에 위와 같은 사진이 뜨면 성공입니다.","categories":[{"name":"git","slug":"git","permalink":"https://swtpumpkin.github.io/categories/git/"},{"name":"hexo","slug":"git/hexo","permalink":"https://swtpumpkin.github.io/categories/git/hexo/"}],"tags":[{"name":"google","slug":"google","permalink":"https://swtpumpkin.github.io/tags/google/"},{"name":"webmaster","slug":"webmaster","permalink":"https://swtpumpkin.github.io/tags/webmaster/"},{"name":"hexo","slug":"hexo","permalink":"https://swtpumpkin.github.io/tags/hexo/"},{"name":"헥소","slug":"헥소","permalink":"https://swtpumpkin.github.io/tags/%ED%97%A5%EC%86%8C/"}]},{"title":"Queue","slug":"CS/dataStructure/queue","date":"2017-09-01T01:00:00.000Z","updated":"2020-05-06T07:34:44.380Z","comments":true,"path":"CS/dataStructure/queue/","link":"","permalink":"https://swtpumpkin.github.io/CS/dataStructure/queue/","excerpt":"","text":"Queue란?위 파이프 사진처럼 Queue는 순서대로 들어오고 순서대로 나간다고 생각하면 됩니다. Queue (DFS, 너비탐색) Queue는 FIFO (First Input First Out) 구조를 갖습니다. 들어오는 순서대로 인덱스를 지정해서 순서대로 실행 할 수 있도록 만들어진 구조입니다. 일반적으로 javascript는 Stack의 구조를 갖는데 먼저 들어온 데이터를 우선적으로 처리할 때 사용합니다. 큐의 추상적 데이터형 (ADT , abstract data type) enqueue : push를 이용하여 데이터를 넣음 dequeue : shift를 이용하여 데이터를 꺼냄.(처음 데이터) front : 데이터의 가장 처음 값을 확인만 함. isEmpty : 데이터가 비어있는지 확인. clear : 데이터 초기화 (빈 배열을 할당하여 초기화) print : 남아있는 배열의 데이터를 문자열로 출력. Queue을 javascript로 구현123456789101112131415161718192021222324const queue = () =&gt; &#123; let items = []; this.enqueue = (element) =&gt; &#123; return items.push(element); &#125;; this.dequeue = () =&gt; &#123; return items.shift(); &#125;; this.front = () =&gt; &#123; return items[0]; &#125;; this.isEmpty = () =&gt; &#123; return items.length === 0; &#125;; this.clear = () =&gt; &#123; items = []; &#125;; this.size = () =&gt; &#123; return items.length; &#125;; this.print = () =&gt; &#123; console.log(items.toString()); &#125;;&#125; Queue를 이용하여 데이터 입출력 구현 (본인: javascript)12345678910111213141516const Queue= () =&gt; &#123; let inbox = []; let outbox = []; this.enqueue = (elem) =&gt; &#123; if (outbox.length&gt;0)&#123; inbox = outbox.reverse(); &#125; return inbox.push(elem) &#125; this.dequeue = () =&gt; &#123; while(inbox.length&gt;0)&#123; outbox.push(inbox.pop()); &#125; return ''+inbox.pop(); &#125;&#125; Queue를 이용하여 우선순위를 비교 우선순위가 높은 것을 Queue로 구현 (강사님: javascript)12345678910111213141516171819202122232425262728293031323334353637383940const PriorityQueue = () =&gt; &#123; let items = []; const QueueElement = (element, priority) =&gt; &#123; this.element = element; this.priority = priority; &#125; this.enqueue = (element, priority) =&gt; &#123; const queueElement = new QueueElement(element, priority); if(!items.length) &#123; items.push(queueElement); &#125; else &#123; let added = false; for(let i = 0; i&lt;items.length; i++)&#123; if(queueElement.priority &lt; items[i].priority) &#123; items.splice(i,0,queueElement); added = true; break; &#125; &#125; if(!added)&#123; items.push(queueElement); &#125; &#125; &#125; this.dequeue = () =&gt; &#123; return items.shift; &#125; this.front = () =&gt; &#123; return items[0]; &#125; this.size = () =&gt; &#123; return items.length; &#125; this.clear = () =&gt; &#123; items = []; &#125; this.print = () =&gt; &#123; console.log(''+items); &#125;&#125; 배운점 Queue가 어떻게 구현되는지 배웠습니다. 데이터를 가공 할 때 우선순위를 매겨 우선 실행히 되어야 할 data를 우선실행되도록 하는 방법도 배웠습니다.","categories":[{"name":"CS","slug":"CS","permalink":"https://swtpumpkin.github.io/categories/CS/"},{"name":"dataStructure","slug":"CS/dataStructure","permalink":"https://swtpumpkin.github.io/categories/CS/dataStructure/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://swtpumpkin.github.io/tags/javascript/"},{"name":"자바스크립트","slug":"자바스크립트","permalink":"https://swtpumpkin.github.io/tags/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/"},{"name":"queue","slug":"queue","permalink":"https://swtpumpkin.github.io/tags/queue/"},{"name":"큐","slug":"큐","permalink":"https://swtpumpkin.github.io/tags/%ED%81%90/"}]},{"title":"Stack","slug":"CS/dataStructure/stack","date":"2017-09-01T00:00:00.000Z","updated":"2020-05-06T07:34:44.381Z","comments":true,"path":"CS/dataStructure/stack/","link":"","permalink":"https://swtpumpkin.github.io/CS/dataStructure/stack/","excerpt":"","text":"Stack이란?위 사진과 같이 서류는 순서대로 쌓여지고 맨 위 서류부터 읽는다고 생각하면 스택을 이해하기 쉽습니다. Stack (BFS, 깊이탐색) Stack은 LIFO(Last In First Out) 구조를 갖습니다. Stack은 축약 자료형이고 push와 pop을 사용합니다. push로 데이터를 넣어주고 pop을 이용하여 데이터를 뽑아옵니다. 가장 나중에 들어온 데이터를 가장 먼저 사용을 합니다. peek는 가장 나중에 들어온 데이터를 의미합니다. 스택의 추상적 데이터형 (ADT , abstract data type) push : 데이터를 넣음. pop : 데이터를 꺼냄.(마지막 데이터) peek : 데이터의 가장 나중에 넣은 값을 확인만 함. size : 데이터의 개수. isEmpty : 데이터가 비어있는지 확인. clear : 데이터 초기화 (빈 배열을 할당하여 초기화) print : 남아있는 배열의 데이터를 문자열로 출력. Stack을 javascript로 구현123456789101112131415161718192021222324const stact = () =&gt; &#123; let items = []; this.push = (element) =&gt; &#123; return items.push(element); &#125;; this.pop = () =&gt; &#123; return items.pop(); &#125;; this.peek = () =&gt; &#123; return items[items.length-1]; &#125;; this.size = () =&gt; &#123; return items.length; &#125;; this.isEmpty = () =&gt; &#123; return items.length === 0; &#125;; this.clear = () =&gt; &#123; items = []; &#125;; this.print = () =&gt; &#123; console.log(items.toString()) &#125;;&#125; Stack을 이용하여 10진수를 2진수로 변환 (본인: javascript)12345678910111213const converter = (num) =&gt; &#123; let arr = []; let result = ''; while(num&gt;0)&#123; (num%2)? arr.push(1): arr.push(0) num = Math.floor(num/2); &#125; for(let num = arr.length; num&gt;0; num--)&#123; result += arr.pop(); &#125; return result;&#125;console.log(converter(10)); // 1010 Stack을 이용하여 10진수를 2진수로 변환 (강사님: javascript)12345678910111213const divideBy2 = (decimal) =&gt; &#123; let remStack = new Stack(), rem, binaryString = ''; while (decimal &gt; 0) &#123; rem = Math.floor(decimal % 2); remStack.push(rem); decimal = Math.floor(decimal / 2); &#125; while (!remStack.isEmpty()) &#123; binaryString += remStack.pop().toString(); &#125;&#125; 배운점 자료구조에서 중요한 Stack이 어떻게 작동하는지, 어떤 상황에서 사용해야 하는지에 대해 배웠습니다. javascript의 실행컨택스트(Execution Context)에서 논리적 스택구조에 대해 배웠는데 실제 프로그래밍을 하면서 어떻게 작동하는지 이해하게 되었습니다.느낀점 강사님은 기존에 javascript로 구현하였던 스택을 이용하여 10진수를 2진수로 변환하였는데 똑같이 이용하는 방법을 익혀야겠습니다.","categories":[{"name":"CS","slug":"CS","permalink":"https://swtpumpkin.github.io/categories/CS/"},{"name":"dataStructure","slug":"CS/dataStructure","permalink":"https://swtpumpkin.github.io/categories/CS/dataStructure/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://swtpumpkin.github.io/tags/javascript/"},{"name":"자바스크립트","slug":"자바스크립트","permalink":"https://swtpumpkin.github.io/tags/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/"},{"name":"stack","slug":"stack","permalink":"https://swtpumpkin.github.io/tags/stack/"},{"name":"스택","slug":"스택","permalink":"https://swtpumpkin.github.io/tags/%EC%8A%A4%ED%83%9D/"}]},{"title":"level 3. 다음 큰 숫자 (Javascript)","slug":"algorithm/level3/nextBigNum","date":"2017-08-31T23:00:00.000Z","updated":"2020-02-17T03:49:00.326Z","comments":true,"path":"algorithm/level3/nextBigNum/","link":"","permalink":"https://swtpumpkin.github.io/algorithm/level3/nextBigNum/","excerpt":"","text":"다음 큰 숫자문제어떤 수 N(1≤N≤1,000,000) 이 주어졌을 때, N의 다음 큰 숫자는 다음과 같습니다. N의 다음 큰 숫자는 N을 2진수로 바꾸었을 때의 1의 개수와 같은 개수로 이루어진 수입니다. 1번째 조건을 만족하는 숫자들 중 N보다 큰 수 중에서 가장 작은 숫자를 찾아야 합니다.예를 들어, 78을 2진수로 바꾸면 1001110 이며, 78의 다음 큰 숫자는 83으로 2진수는 1010011 입니다.N이 주어질 때, N의 다음 큰 숫자를 찾는 nextBigNumber 함수를 완성하세요. 풀이 (본인)123456789101112131415161718192021222324252627282930function nextBigNumber(n)&#123; var answer = 0; var countPre = 0; var increaseNum = n; var arr = ''+n.toString(2).split('') for(var num = 0; num&lt;arr.length; num++)&#123; if(arr[num]*1 === 1)&#123; countPre++ &#125; &#125; increaseNum++ while(true)&#123; var innerCount = 0; var increaseArr = ''+increaseNum.toString(2).split('') for(var innerNum = 0; innerNum&lt;increaseArr.length; innerNum++)&#123; if(increaseArr[innerNum]*1 === 1)&#123; innerCount++; &#125; &#125; if(innerCount === countPre)&#123; return increaseNum; break; &#125; increaseNum++; &#125; return answer;&#125;//아래 코드는 테스트를 위한 코드입니다.console.log(nextBigNumber(78)); // 83console.log(nextBigNumber(857171)); //857173 풀이 (다른 사람)123456789101112131415function nextBigNumber(n)&#123; var answer = 0; let s = Number(n).toString(2) let c = s.split('').filter(x =&gt; 1===parseInt(x,10)).length while(true)&#123; n+=1 if(Number(n).toString(2).split('').filter(x =&gt; 1===parseInt(x,10)).length ===c)&#123; break &#125; &#125; return n;&#125;//아래 코드는 테스트를 위한 코드입니다.console.log(nextBigNumber(78)); // 83console.log(nextBigNumber(857171)); //857173 배운점 Array 프로퍼티 중 filter를 이용하여 1의 요소만 배열에 담은 배열의 길이만 체크하는 함수를 사용 할 수 있다는 것을 배웠다. ECMAScript6를 배웠는데 사용을 잘 하지 못하고 있어서 사용법을 익혀야겠다. 느낀점 코드 작성 시 몰랐지만 increaseNum++을 한번만 사용해도 코드가 잘 돌아가는데 나중에 눈 디버깅으로 체크하여 불필요한 코드가 작성되어 있는 것을 확인하였다. 코드를 작성하고 중복 선언된 코드를 제거 할 수 있는 능력을 키워야겠다.","categories":[{"name":"Algorism","slug":"Algorism","permalink":"https://swtpumpkin.github.io/categories/Algorism/"},{"name":"level3","slug":"Algorism/level3","permalink":"https://swtpumpkin.github.io/categories/Algorism/level3/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://swtpumpkin.github.io/tags/javascript/"},{"name":"자바스크립트","slug":"자바스크립트","permalink":"https://swtpumpkin.github.io/tags/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/"},{"name":"algorithm","slug":"algorithm","permalink":"https://swtpumpkin.github.io/tags/algorithm/"},{"name":"알고리즘","slug":"알고리즘","permalink":"https://swtpumpkin.github.io/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/"},{"name":"next big number","slug":"next-big-number","permalink":"https://swtpumpkin.github.io/tags/next-big-number/"},{"name":"다음 큰 숫자","slug":"다음-큰-숫자","permalink":"https://swtpumpkin.github.io/tags/%EB%8B%A4%EC%9D%8C-%ED%81%B0-%EC%88%AB%EC%9E%90/"}]},{"title":"hexo에서 마크다운 이미지 파일 사용법","slug":"git/hexo/hexoImg","date":"2017-08-31T23:00:00.000Z","updated":"2020-01-08T04:06:19.010Z","comments":true,"path":"git/hexo/hexoImg/","link":"","permalink":"https://swtpumpkin.github.io/git/hexo/hexoImg/","excerpt":"","text":"헥소 이미지 올리는 방법헥소를 이용하여 블로그를 사용하다보면 img파일을 첨부하고 싶을 때가 있습니다.처음 블로그를 시작했을때 사진을 올리는 방법을 몰라 vscode 에디터에서는 이미지가 잘 올라가 보였지만 generator과정에서 경로가 잘못되어 사진첨부가 안 된 경우가 있었습니다.저와 같은 실수를 하는 사람들을 위하여 사진 첨부하는 방법을 알려드리겠습니다. 헥소 이미지 올리는 순서위와 같이 /source/image 폴더 안에 사진을 넣습니다. ![](/image/hexoimg.png) 다음과 같은 경로로 마크다운에서 파일을 지정해줍니다.위 순서와 같이 경로를 지정해주고 배포하면 위 사진과 같이 블로그에 사진이 보이게 됩니다.","categories":[{"name":"git","slug":"git","permalink":"https://swtpumpkin.github.io/categories/git/"},{"name":"hexo","slug":"git/hexo","permalink":"https://swtpumpkin.github.io/categories/git/hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://swtpumpkin.github.io/tags/hexo/"},{"name":"image","slug":"image","permalink":"https://swtpumpkin.github.io/tags/image/"},{"name":"img","slug":"img","permalink":"https://swtpumpkin.github.io/tags/img/"},{"name":"이미지","slug":"이미지","permalink":"https://swtpumpkin.github.io/tags/%EC%9D%B4%EB%AF%B8%EC%A7%80/"},{"name":"헥소","slug":"헥소","permalink":"https://swtpumpkin.github.io/tags/%ED%97%A5%EC%86%8C/"}]},{"title":"level 2. 콜라츠 추측 (Javascript)","slug":"algorithm/level2/collatzConjecture","date":"2017-08-30T23:00:00.000Z","updated":"2020-02-17T03:49:00.318Z","comments":true,"path":"algorithm/level2/collatzConjecture/","link":"","permalink":"https://swtpumpkin.github.io/algorithm/level2/collatzConjecture/","excerpt":"","text":"콜라츠 추측문제1937년 Collatz란 사람에 의해 제기된 이 추측은, 입력된 수가 짝수라면 2로 나누고, 홀수라면 3을 곱하고 1을 더한 다음, 결과로 나온 수에 같은 작업을 1이 될 때까지 반복할 경우 모든 수가 1이 된다는 추측입니다.예를 들어, 입력된 수가 6이라면 6→3→10→5→16→8→4→2→1 이 되어 총 8번 만에 1이 됩니다.collatz 함수를 만들어 입력된 수가 몇 번 만에 1이 되는지 반환해 주세요.단, 500번을 반복해도 1이 되지 않는다면 –1을 반환해 주세요. 풀이 (본인)1234567891011121314151617function collatz(num) &#123; var count = 0; while (true) &#123; if(count&gt;=500)&#123; return -1; &#125;else if(num != 1)&#123; (num%2)? num=num*3+1 : num=num/2; &#125;else if(num === 1)&#123; return count; &#125; count ++; &#125;&#125;//테스트를 출력하기 위한 코드입니다.console.log(collatz(6)); //8console.log(collatz(8)); //3console.log(collatz(1256699)); //-1 풀이 (다른 사람)1234567function collatz(num,count = 0) &#123; return num == 1 ? (count &gt;= 500 ? -1 : count) : collatz(num % 2 == 0 ? num / 2 : num * 3 + 1,++count);&#125;//테스트를 출력하기 위한 코드입니다.console.log(collatz(6)); //8console.log(collatz(8)); //3console.log(collatz(1256699)); //-1 배운점 이중 for문처럼 이중 삼항연산자를 사용하여 한줄로 문제를 해결 가능하다는 것을 배웠다. 느낀점 이중 삼항연산자를 사용하면 코드는 짧아지지만 가독성은 나쁘다. 코드를 간결하게 사용하는 것이 좋은지 아니면 가독성이 좋게 짜는것이 좋은지에 대한 궁금증이 생긴다.","categories":[{"name":"Algorism","slug":"Algorism","permalink":"https://swtpumpkin.github.io/categories/Algorism/"},{"name":"level2","slug":"Algorism/level2","permalink":"https://swtpumpkin.github.io/categories/Algorism/level2/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://swtpumpkin.github.io/tags/javascript/"},{"name":"자바스크립트","slug":"자바스크립트","permalink":"https://swtpumpkin.github.io/tags/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/"},{"name":"algorithm","slug":"algorithm","permalink":"https://swtpumpkin.github.io/tags/algorithm/"},{"name":"알고리즘","slug":"알고리즘","permalink":"https://swtpumpkin.github.io/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/"},{"name":"collatz conjecture","slug":"collatz-conjecture","permalink":"https://swtpumpkin.github.io/tags/collatz-conjecture/"},{"name":"콜라츠 추측","slug":"콜라츠-추측","permalink":"https://swtpumpkin.github.io/tags/%EC%BD%9C%EB%9D%BC%EC%B8%A0-%EC%B6%94%EC%B8%A1/"}]},{"title":"level 2. 하샤드 수 (Javascript)","slug":"algorithm/level2/numOfHashard","date":"2017-08-21T23:00:00.000Z","updated":"2020-02-17T03:49:00.311Z","comments":true,"path":"algorithm/level2/numOfHashard/","link":"","permalink":"https://swtpumpkin.github.io/algorithm/level2/numOfHashard/","excerpt":"","text":"하샤드 수문제양의 정수 x가 하샤드 수이려면 x의 자릿수의 합으로 x가 나누어져야 합니다. 예를들어 18의 자릿수 합은 1+8=9이고, 18은 9로 나누어 떨어지므로 18은 하샤드 수입니다.Harshad함수는 양의 정수 n을 매개변수로 입력받습니다. 이 n이 하샤드수인지 아닌지 판단하는 함수를 완성하세요.예를들어 n이 10, 12, 18이면 True를 리턴 11, 13이면 False를 리턴하면 됩니다. 풀이 (본인)1234567891011121314function Harshad(n)&#123; var strArr = n.toString().split(''); var numSum = 0; for(var num = 0; num&lt;strArr.length; num++)&#123; numSum += strArr[num]*1 &#125; return (n%numSum===0)? true: false;&#125;// 아래는 테스트로 출력해 보기 위한 코드입니다.console.log(Harshad(10)); // trueconsole.log(Harshad(13)); // falseconsole.log(Harshad(18)); // trueconsole.log(Harshad(2341)); // falseconsole.log(Harshad(222220)); // true 풀이 (다른 사람)123456789function Harshad(n)&#123; return !(n%(n+'').split('').reduce(function (i, sum) &#123;return +sum + +i;&#125;));&#125;// 아래는 테스트로 출력해 보기 위한 코드입니다.console.log(Harshad(10)); // trueconsole.log(Harshad(13)); // falseconsole.log(Harshad(18)); // trueconsole.log(Harshad(2341)); // falseconsole.log(Harshad(222220)); // true 배운점 Array의 메서드로 reduce를 사용하여 for문을 사용하지 않아도 순회하는 함수 사용을 할 수 있다는 것을 배웠다. 느낀점 for문을 사용하면 브라우저의 속도 측면에서 reduce메소드보다 느리므로 알고리즘의 작동속도를 빠르게 하는 스킬을 늘려야겠다.","categories":[{"name":"Algorism","slug":"Algorism","permalink":"https://swtpumpkin.github.io/categories/Algorism/"},{"name":"level2","slug":"Algorism/level2","permalink":"https://swtpumpkin.github.io/categories/Algorism/level2/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://swtpumpkin.github.io/tags/javascript/"},{"name":"자바스크립트","slug":"자바스크립트","permalink":"https://swtpumpkin.github.io/tags/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/"},{"name":"algorithm","slug":"algorithm","permalink":"https://swtpumpkin.github.io/tags/algorithm/"},{"name":"알고리즘","slug":"알고리즘","permalink":"https://swtpumpkin.github.io/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/"},{"name":"number of hashard","slug":"number-of-hashard","permalink":"https://swtpumpkin.github.io/tags/number-of-hashard/"},{"name":"하샤드 수","slug":"하샤드-수","permalink":"https://swtpumpkin.github.io/tags/%ED%95%98%EC%83%A4%EB%93%9C-%EC%88%98/"}]},{"title":"level 1. 약수의 합 (Javascript)","slug":"algorithm/level1/sumOfDivisors","date":"2017-08-21T00:00:00.000Z","updated":"2020-02-17T03:49:00.315Z","comments":true,"path":"algorithm/level1/sumOfDivisors/","link":"","permalink":"https://swtpumpkin.github.io/algorithm/level1/sumOfDivisors/","excerpt":"","text":"약수의 합문제어떤 수를 입력받아 그 수의 약수를 모두 더한 수 sumDivisor 함수를 완성해 보세요.예를 들어 12가 입력된다면 12의 약수는 [1, 2, 3, 4, 6, 12]가 되고, 총 합은 28이 되므로 28을 반환해 주면 됩니다. 풀이 (본인)1234567891011function sumDivisor(inputNum) &#123; var sum = 0; for(var num = 1; num&lt;=inputNum; num++)&#123; if(inputNum%num===0)&#123; sum +=num; &#125; &#125; return sum;&#125;// 아래는 테스트로 출력해 보기 위한 코드입니다.console.log(sumDivisor(12)); // 28 풀이 (다른 사람)12345678910111213function sumDivisor(num) &#123; let n = num; let a = [] while(0 &lt; num)&#123; if(n % num === 0)&#123; a.push(num) &#125; num-- &#125; return a.reduce((a,b) =&gt; a+b);&#125;// 아래는 테스트로 출력해 보기 위한 코드입니다.console.log(sumDivisor(12)); // 28 배운점 배열의 요소로 담아 나중에 한번에 더하는 코드를 작성 할 수 있다는 것을 배웠다. 느낀점 대부분의 사람들은 본인이 작성한 코드와 비슷하게 작성을 하였짐만 배열의 요소를 이용하여 코드를 작성 한 코드를 보았다. 배열의 요소를 이용하게 되면 함수를 한번 더 사용해야 하므로 속도가 느려질것같다.(아마 문제에서 배열을 보여줘서 배열을 이용한 것 같다.) 대부분의 사람들이 작성한 코드가 가장 빠른 속도를 갖는 코드인 것 같다.","categories":[{"name":"Algorism","slug":"Algorism","permalink":"https://swtpumpkin.github.io/categories/Algorism/"},{"name":"level1","slug":"Algorism/level1","permalink":"https://swtpumpkin.github.io/categories/Algorism/level1/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://swtpumpkin.github.io/tags/javascript/"},{"name":"자바스크립트","slug":"자바스크립트","permalink":"https://swtpumpkin.github.io/tags/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/"},{"name":"algorithm","slug":"algorithm","permalink":"https://swtpumpkin.github.io/tags/algorithm/"},{"name":"알고리즘","slug":"알고리즘","permalink":"https://swtpumpkin.github.io/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/"},{"name":"sum of divisors","slug":"sum-of-divisors","permalink":"https://swtpumpkin.github.io/tags/sum-of-divisors/"},{"name":"약수의 합","slug":"약수의-합","permalink":"https://swtpumpkin.github.io/tags/%EC%95%BD%EC%88%98%EC%9D%98-%ED%95%A9/"}]},{"title":"level 1. 피보나치 수 (Javascript)","slug":"algorithm/level1/fibonacciNumber","date":"2017-08-20T23:00:00.000Z","updated":"2020-02-17T03:49:00.301Z","comments":true,"path":"algorithm/level1/fibonacciNumber/","link":"","permalink":"https://swtpumpkin.github.io/algorithm/level1/fibonacciNumber/","excerpt":"","text":"피보나치 수문제피보나치 수는 F(0) = 0, F(1) = 1일 때, 2 이상의 n에 대하여 F(n) = F(n-1) + F(n-2) 가 적용되는 점화식입니다.2 이상의 n이 입력되었을 때, fibonacci 함수를 제작하여 n번째 피보나치 수를 반환해 주세요.예를 들어 n = 3이라면 2를 반환해주면 됩니다. 풀이 (본인)12345678910111213function fibonacci(n) &#123; var pre = 0; var cur = 1; var last = 0; for(var num = 1; num&lt;n; num++)&#123; last = pre + cur; pre = cur; cur = last; &#125; return last;&#125;// 아래는 테스트로 출력해 보기 위한 코드입니다.console.log(fibonacci(3)); 풀이 (다른 사람)123456function fibonacci(num) &#123; if(num &lt; 2) return num; return fibonacci(num-1) + fibonacci(num-2);&#125;// 아래는 테스트로 출력해 보기 위한 코드입니다.console.log(fibonacci(3)) 배운점 피보나치 수열에 대해 이해를 하며 코드를 작성하여 피보나치 수열에 대해 이해할 수 있었다.","categories":[{"name":"Algorism","slug":"Algorism","permalink":"https://swtpumpkin.github.io/categories/Algorism/"},{"name":"level1","slug":"Algorism/level1","permalink":"https://swtpumpkin.github.io/categories/Algorism/level1/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://swtpumpkin.github.io/tags/javascript/"},{"name":"자바스크립트","slug":"자바스크립트","permalink":"https://swtpumpkin.github.io/tags/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/"},{"name":"algorithm","slug":"algorithm","permalink":"https://swtpumpkin.github.io/tags/algorithm/"},{"name":"알고리즘","slug":"알고리즘","permalink":"https://swtpumpkin.github.io/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/"},{"name":"fibonacci","slug":"fibonacci","permalink":"https://swtpumpkin.github.io/tags/fibonacci/"},{"name":"피보나치","slug":"피보나치","permalink":"https://swtpumpkin.github.io/tags/%ED%94%BC%EB%B3%B4%EB%82%98%EC%B9%98/"}]},{"title":"level 1. 수박수박수박수박수박수? (Javascript)","slug":"algorithm/level1/repeatString","date":"2017-08-19T23:00:00.000Z","updated":"2020-02-17T03:49:00.317Z","comments":true,"path":"algorithm/level1/repeatString/","link":"","permalink":"https://swtpumpkin.github.io/algorithm/level1/repeatString/","excerpt":"","text":"수박수박수박수박수박수?문제water_melon함수는 정수 n을 매개변수로 입력받습니다.길이가 n이고, 수박수박수…와 같은 패턴을 유지하는 문자열을 리턴하도록 함수를 완성하세요.예를들어 n이 4이면 ‘수박수박’을 리턴하고 3이라면 ‘수박수’를 리턴하면 됩니다. 풀이 (본인)1234567891011function waterMelon(n)&#123; var melon = ['수','박']; var result = []; for(var num = 0; num&lt;n; num++)&#123; result.push(melon[num%2]) &#125; return result.join('');&#125;// 실행을 위한 테스트코드입니다.console.log(\"n이 3인 경우: \"+ waterMelon(3)) //수박수console.log(\"n이 4인 경우: \"+ waterMelon(4)) //수박수박 풀이 (다른 사람)1234567function waterMelon(n)&#123; // n을 2로나눈 몫 만큼 곱하고 나머지가 있으면 '수' 더해라. return (\"수박\").repeat(n/2) + ((n%2) ? '수' : '');&#125;// 실행을 위한 테스트코드입니다.console.log(\"n이 3인 경우: \"+ waterMelon(3)) //수박수console.log(\"n이 4인 경우: \"+ waterMelon(4)) //수박수박 배운점 문자열을 배열의 형태로 바꾸는 방법만 생각했는데 문자열의 메소드를 사용하는 방법에 대해 배웠다. 느낀점 문자열이면 문자열의 메소드를 이용하는 코드를 작성하는 연습을 해야겠다.","categories":[{"name":"Algorism","slug":"Algorism","permalink":"https://swtpumpkin.github.io/categories/Algorism/"},{"name":"level1","slug":"Algorism/level1","permalink":"https://swtpumpkin.github.io/categories/Algorism/level1/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://swtpumpkin.github.io/tags/javascript/"},{"name":"자바스크립트","slug":"자바스크립트","permalink":"https://swtpumpkin.github.io/tags/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/"},{"name":"algorithm","slug":"algorithm","permalink":"https://swtpumpkin.github.io/tags/algorithm/"},{"name":"알고리즘","slug":"알고리즘","permalink":"https://swtpumpkin.github.io/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/"},{"name":"repeat string","slug":"repeat-string","permalink":"https://swtpumpkin.github.io/tags/repeat-string/"},{"name":"수박수박...","slug":"수박수박","permalink":"https://swtpumpkin.github.io/tags/%EC%88%98%EB%B0%95%EC%88%98%EB%B0%95/"}]},{"title":"level 1. 핸드폰번호 가리기 (Javascript)","slug":"algorithm/level1/phoneNumHide","date":"2017-08-18T00:00:00.000Z","updated":"2020-02-17T03:49:00.304Z","comments":true,"path":"algorithm/level1/phoneNumHide/","link":"","permalink":"https://swtpumpkin.github.io/algorithm/level1/phoneNumHide/","excerpt":"","text":"핸드폰 번호 가리기문제개인정보 보호를 위해 고객들의 전화번호는 맨 뒷자리 4자리를 제외한 나머지를 ““으로 바꿔야 합니다.전화번호를 문자열 s로 입력받는 hide_numbers함수를 완성하세요.예를들어 s가 “01033334444”면 “*4444”를 리턴하고, “027778888”인 경우는 “8888”을 리턴하면 됩니다. 풀이 (본인)123456789101112function hideNumbers(str)&#123; var lastFour = str.split('').slice(-4).join(''); var star = []; for(var num = 0; num&lt;str.split('').length-4; num++)&#123; star.push('*'); &#125; var starStr = star.join(''); return starStr+lastFour;&#125;// 아래는 테스트로 출력해 보기 위한 코드입니다.console.log(hideNumbers('01033334444')); // *******4444console.log(hideNumbers('027778888')); // *****8888 풀이 (다른 사람)123456function hide_numbers(s) &#123; return s.replace(/\\d(?=\\d&#123;4&#125;)/g, \"*\");&#125;// 아래는 테스트로 출력해 보기 위한 코드입니다.console.log(hideNumbers('01033334444')); // *******4444console.log(hideNumbers('027778888')); // *****8888 풀이 (다른 사람)12345678function hide_numbers(s)&#123; var result = \"*\".repeat(s.length - 4) + s.slice(-4); //함수를 완성해주세요 return result;&#125;// 아래는 테스트로 출력해 보기 위한 코드입니다.console.log(hideNumbers('01033334444')); // *******4444console.log(hideNumbers('027778888')); // *****8888 배운점 정규표현식을 사용하면 짧은 코드로 끝낼 수 있다. string type 프로퍼티를 이용해도 간결하게 끝낼 수 있다. 느낀점 Javascript를 배우면서 강사님이 말씀하시기를 내가 불편해하고 쉽게 할 수 있는 방법들은 이미 만들어져 있다고 했다. 정규표현식을 사용하면 코드 속도도 빨라지므로 내가 원하는 기능이 정규표현식에 있는지 찾아보는 습관을 갖아야겠다. 다른사람의 코드를 보고 배우는것도 큰 도움이 되는 것 같다.","categories":[{"name":"Algorism","slug":"Algorism","permalink":"https://swtpumpkin.github.io/categories/Algorism/"},{"name":"level1","slug":"Algorism/level1","permalink":"https://swtpumpkin.github.io/categories/Algorism/level1/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://swtpumpkin.github.io/tags/javascript/"},{"name":"자바스크립트","slug":"자바스크립트","permalink":"https://swtpumpkin.github.io/tags/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/"},{"name":"algorithm","slug":"algorithm","permalink":"https://swtpumpkin.github.io/tags/algorithm/"},{"name":"알고리즘","slug":"알고리즘","permalink":"https://swtpumpkin.github.io/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/"},{"name":"phone number hide","slug":"phone-number-hide","permalink":"https://swtpumpkin.github.io/tags/phone-number-hide/"},{"name":"핸드폰 번호 가리기","slug":"핸드폰-번호-가리기","permalink":"https://swtpumpkin.github.io/tags/%ED%95%B8%EB%93%9C%ED%8F%B0-%EB%B2%88%ED%98%B8-%EA%B0%80%EB%A6%AC%EA%B8%B0/"}]},{"title":"level 1. 스트링을 숫자로 바꾸기 (Javascript)","slug":"algorithm/level1/stringToNum","date":"2017-08-17T23:00:00.000Z","updated":"2020-02-17T03:49:00.306Z","comments":true,"path":"algorithm/level1/stringToNum/","link":"","permalink":"https://swtpumpkin.github.io/algorithm/level1/stringToNum/","excerpt":"","text":"스트링을 숫자로 바꾸기문제strToInt 메소드는 String형 str을 매개변수로 받습니다.str을 숫자로 변환한 결과를 반환하도록 strToInt를 완성하세요.예를들어 str이 “1234”이면 1234를 반환하고, “-1234”이면 -1234를 반환하면 됩니다.str은 부호(+,-)와 숫자로만 구성되어 있고, 잘못된 값이 입력되는 경우는 없습니다. 풀이 (본인)12345function strToInt(str)&#123; return str*1;&#125;// 아래는 테스트로 출력해 보기 위한 코드입니다.console.log(strToInt(\"-1234\")); 풀이 (다른 사람)1234567function strToInt(str)&#123; var result = 0; result = Number(str) return result;&#125;// 아래는 테스트로 출력해 보기 위한 코드입니다.console.log(strToInt(\"-1234\")); 배운점 문자열을 숫자로 바꾸는 방법에는 여러가지 방법이 있다. 함수를 활용하는 방법123456//parseInt()var num = parseInt(\"111\")//parseFloat()var num = parseFloat(\"111\")//Number()var num = Number(\"111\") 더하기 곱하기 나누기 등의 연산을 사용하는 방법123456//더하기var num = +\"111\"//곱하기var num = 1 * \"111\"//나누기var num = \"111\" / 1 만약 parseInt 함수를 사용하려면 10진법이라고 명기한 것이 안한것보다 속도가 빠르다고 한다.","categories":[{"name":"Algorism","slug":"Algorism","permalink":"https://swtpumpkin.github.io/categories/Algorism/"},{"name":"level1","slug":"Algorism/level1","permalink":"https://swtpumpkin.github.io/categories/Algorism/level1/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://swtpumpkin.github.io/tags/javascript/"},{"name":"자바스크립트","slug":"자바스크립트","permalink":"https://swtpumpkin.github.io/tags/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/"},{"name":"algorithm","slug":"algorithm","permalink":"https://swtpumpkin.github.io/tags/algorithm/"},{"name":"알고리즘","slug":"알고리즘","permalink":"https://swtpumpkin.github.io/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/"},{"name":"string to number","slug":"string-to-number","permalink":"https://swtpumpkin.github.io/tags/string-to-number/"},{"name":"스트링을 숫자로 바꾸기","slug":"스트링을-숫자로-바꾸기","permalink":"https://swtpumpkin.github.io/tags/%EC%8A%A4%ED%8A%B8%EB%A7%81%EC%9D%84-%EC%88%AB%EC%9E%90%EB%A1%9C-%EB%B0%94%EA%BE%B8%EA%B8%B0/"}]},{"title":"level 1. 역삼각형 출력하기 (Javascript)","slug":"algorithm/level1/invertedTriangle","date":"2017-08-14T23:00:00.000Z","updated":"2020-02-17T03:49:00.303Z","comments":true,"path":"algorithm/level1/invertedTriangle/","link":"","permalink":"https://swtpumpkin.github.io/algorithm/level1/invertedTriangle/","excerpt":"","text":"역삼각형 출력하기문제printReversedTriangle 메소드는 양의 정수 num을 매개변수로 입력받습니다.다음을 참고해 *(별)로 높이가 num인 삼각형을 문자열로 리턴하는 printReversedTriangle 메소드를 완성하세요.높이(num)가 3일때 다음과 같은 문자열을 리턴하면 됩니다. 123****** 풀이 (본인)123456789101112function printReversedTriangle(num) &#123; var result = \"\" for(var height = num-1; height&gt;=0; height--)&#123; for(var star = 0; star &lt;= height ; star++)&#123; result += \"*\"; &#125; result += \"\\n\" &#125; return result&#125;// 아래는 테스트로 출력해 보기 위한 코드입니다.console.log(\"결과 : \" +'\\n'+ printReversedTriangle(3)); 풀이 (다른 사람)1234567function printReversedTriangle(num) &#123; var result = '' while(num&gt;0)&#123;result+=Array(num+1).join(\"*\")+'\\n';num--&#125; return result&#125;// 아래는 테스트로 출력해 보기 위한 코드입니다.console.log(\"결과 : \" +'\\n'+ printReversedTriangle(3)); 배운점 이중 for문을 이용하여 삼각형을 찍는 방법 이외에도 방법이 있다는 것을 배웠다.","categories":[{"name":"Algorism","slug":"Algorism","permalink":"https://swtpumpkin.github.io/categories/Algorism/"},{"name":"level1","slug":"Algorism/level1","permalink":"https://swtpumpkin.github.io/categories/Algorism/level1/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://swtpumpkin.github.io/tags/javascript/"},{"name":"자바스크립트","slug":"자바스크립트","permalink":"https://swtpumpkin.github.io/tags/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/"},{"name":"algorithm","slug":"algorithm","permalink":"https://swtpumpkin.github.io/tags/algorithm/"},{"name":"알고리즘","slug":"알고리즘","permalink":"https://swtpumpkin.github.io/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/"},{"name":"inverted triangle","slug":"inverted-triangle","permalink":"https://swtpumpkin.github.io/tags/inverted-triangle/"},{"name":"역삼각형","slug":"역삼각형","permalink":"https://swtpumpkin.github.io/tags/%EC%97%AD%EC%82%BC%EA%B0%81%ED%98%95/"}]},{"title":"level 1. 짝수와 홀수 (Javascript)","slug":"algorithm/level1/evenOdd","date":"2017-07-28T23:00:00.000Z","updated":"2020-02-17T03:49:00.307Z","comments":true,"path":"algorithm/level1/evenOdd/","link":"","permalink":"https://swtpumpkin.github.io/algorithm/level1/evenOdd/","excerpt":"","text":"짝수와 홀수문제evenOrOdd 메소드는 숫자형 num을 매개변수로 받습니다.num이 짝수일 경우 “even”을 반환하고 홀수인 경우 “odd”를 반환하도록 evenOrOdd에 코드를 작성해 보세요.num은 0이상의 정수이며, num이 음수인 경우는 없습니다. 풀이 (본인)1234567function evenOrOdd(inputNum) &#123; return (inputNum%2 === 0)? 'Even' : 'Odd';&#125;//테스트를 출력하기 위한 코드입니다.console.log(evenOrOdd(9)); //oddconsole.log(evenOrOdd(1111)); //oddconsole.log(evenOrOdd(-102310)); //even 풀이 (다른 사람)123456789function evenOdd(num) &#123; if(num%2 === 0)&#123; return 'Even'; &#125; return 'Odd';&#125;console.log(evenOrOdd(9)); //oddconsole.log(evenOrOdd(1111)); //oddconsole.log(evenOrOdd(-102310)); //even 풀이 (더 간결한 삼항연산자)123456function evenOrOdd(inputNum) &#123; return (inputNum%2)? 'odd' : 'even';&#125;console.log(evenOrOdd(9)); //oddconsole.log(evenOrOdd(1111)); //oddconsole.log(evenOrOdd(-102310)); //even 배운점 if 이외에도 삼항연산자를 이용하여 문제를 풀 수 있었다. 하지만 javascript 특성상 0이면 false 1이면 true를 이용하여 삼항연산자를 더욱 간결하게 사용 할 수도 있었다.","categories":[{"name":"Algorism","slug":"Algorism","permalink":"https://swtpumpkin.github.io/categories/Algorism/"},{"name":"level1","slug":"Algorism/level1","permalink":"https://swtpumpkin.github.io/categories/Algorism/level1/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://swtpumpkin.github.io/tags/javascript/"},{"name":"자바스크립트","slug":"자바스크립트","permalink":"https://swtpumpkin.github.io/tags/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/"},{"name":"algorithm","slug":"algorithm","permalink":"https://swtpumpkin.github.io/tags/algorithm/"},{"name":"알고리즘","slug":"알고리즘","permalink":"https://swtpumpkin.github.io/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/"},{"name":"even","slug":"even","permalink":"https://swtpumpkin.github.io/tags/even/"},{"name":"odd","slug":"odd","permalink":"https://swtpumpkin.github.io/tags/odd/"},{"name":"짝수와 홀수","slug":"짝수와-홀수","permalink":"https://swtpumpkin.github.io/tags/%EC%A7%9D%EC%88%98%EC%99%80-%ED%99%80%EC%88%98/"}]}]}